<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
<meta charset="UTF-8" />
<link rel="stylesheet" href="file:///C:/Users/madvirus/git/kotlin-web-site/css/reset.css" />
<link rel="stylesheet" href="file:///C:/Users/madvirus/git/kotlin-web-site/css/com/page-content/page-content.css" />
</head>
<body>


    
        <section>
          <h1 id="%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0"
              class="section-title">
            시작하기
          </h1>

          
              <article id="basic-syntax.html" class="page-content">
                <h2 id='basic-syntax.html_section'>기본 구문<a class='anchor' href='#%23section'> </a></h2><h3 id='basic-syntax.html_section-1'>패키지 정의<a class='anchor' href='#%23section-1'> </a></h3><p>소스 파일 최상단에 패키지를 지정해야 한다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>package</span> <span class='nn'>my.demo</span>

<span class='k'>import</span> <span class='nn'>java.util.*</span>

<span class='c1'>// ...</span></code></pre><p>디렉토리와 패키지가 일치할 필요는 없다. 소스 파일은 아무 디렉토리에나 위치할 수 있다.</p><p><a href='#packages.html'>패키지</a> 참고.</p><h3 id='basic-syntax.html_section-2'>함수 정의<a class='anchor' href='#%23section-2'> </a></h3><p>두 개의 <code>Int</code> 파라미터와 <code>Int</code> 리턴 타입을 갖는 함수:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>sum</span><span class='p'>(</span><span class='n'>a</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>,</span> <span class='n'>b</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>):</span> <span class='n'>Int</span> <span class='p'>{</span>
  <span class='k'>return</span> <span class='n'>a</span> <span class='p'>+</span> <span class='n'>b</span>
<span class='p'>}</span></code></pre><p>식(expression) 몸체를 갖고 리턴 타입을 추론하는 함수:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>sum</span><span class='p'>(</span><span class='n'>a</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>,</span> <span class='n'>b</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>)</span> <span class='p'>=</span> <span class='n'>a</span> <span class='p'>+</span> <span class='n'>b</span></code></pre><p>의미있는 값을 리턴하지 않는 함수:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>printSum</span><span class='p'>(</span><span class='n'>a</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>,</span> <span class='n'>b</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>):</span> <span class='n'>Unit</span> <span class='p'>{</span>
  <span class='n'>print</span><span class='p'>(</span><span class='n'>a</span> <span class='p'>+</span> <span class='n'>b</span><span class='p'>)</span>
<span class='p'>}</span></code></pre><p><code>Unit</code> 리턴 타입은 생략할 수 있음:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>printSum</span><span class='p'>(</span><span class='n'>a</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>,</span> <span class='n'>b</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>)</span> <span class='p'>{</span>
  <span class='n'>print</span><span class='p'>(</span><span class='n'>a</span> <span class='p'>+</span> <span class='n'>b</span><span class='p'>)</span>
<span class='p'>}</span></code></pre><p><a href='#functions.html'>함수</a> 참고.</p><h3 id='basic-syntax.html_section-3'>로컬 변수 정의<a class='anchor' href='#%23section-3'> </a></h3><p>한 번만 할당하는 (읽기 전용) 로컬 변수:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>a</span><span class='p'>:</span> <span class='n'>Int</span> <span class='p'>=</span> <span class='m'>1</span>
<span class='k'>val</span> <span class='py'>b</span> <span class='p'>=</span> <span class='m'>1</span>   <span class='c1'>// `Int` 타입 추론</span>
<span class='k'>val</span> <span class='py'>c</span><span class='p'>:</span> <span class='n'>Int</span>  <span class='c1'>// 값을 할당하지 않을 경우 타입 필요</span>
<span class='n'>c</span> <span class='p'>=</span> <span class='m'>1</span>       <span class='c1'>// 확정(definite) 할당</span></code></pre><p>변경 가능 변수:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>var</span> <span class='py'>x</span> <span class='p'>=</span> <span class='m'>5</span> <span class='c1'>// `Int` 타입 추론</span>
<span class='n'>x</span> <span class='p'>+=</span> <span class='m'>1</span></code></pre><p><a href='#properties.html'>프로퍼티와 필드</a> 참고.</p><h3 id='basic-syntax.html_section-4'>주석<a class='anchor' href='#%23section-4'> </a></h3><p>자바와 자바스크립트처럼, 코틀린도 라인(end-of-line) 주석과 블록 주석을 지원한다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='c1'>// 이것은 라인(end-of-line) 주석</span>

<span class='cm'>/* 이 코드는 여러 줄에 걸치는</span>
<span class='cm'>   블록 주석입니다. */</span></code></pre><p>자바와 달리, 코틀린은 블록 주석을 중첩할 수 있다.</p><p>문서화를 위한 주석 문법은 <a href='#kotlin-doc.html'>코틀린 코드 문서화</a>를 참고한다.</p><h3 id='basic-syntax.html_section-5'>문자열 템플릿 사용하기<a class='anchor' href='#%23section-5'> </a></h3><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>main</span><span class='p'>(</span><span class='n'>args</span><span class='p'>:</span> <span class='n'>Array</span><span class='p'>&lt;</span><span class='n'>String</span><span class='p'>&gt;)</span> <span class='p'>{</span>
  <span class='k'>if</span> <span class='p'>(</span><span class='n'>args</span><span class='p'>.</span><span class='n'>size</span> <span class='p'>==</span> <span class='m'>0</span><span class='p'>)</span> <span class='k'>return</span>

  <span class='n'>print</span><span class='p'>(</span><span class='s'>&quot;First argument: ${args[0]}&quot;</span><span class='p'>)</span>
<span class='p'>}</span></code></pre><p><a href='#basic-types.html%23string-templates'>문자열 템플릿</a> 참고.</p><h3 id='basic-syntax.html_section-6'>조건 식 사용하기<a class='anchor' href='#%23section-6'> </a></h3><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>max</span><span class='p'>(</span><span class='n'>a</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>,</span> <span class='n'>b</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>):</span> <span class='n'>Int</span> <span class='p'>{</span>
  <span class='k'>if</span> <span class='p'>(</span><span class='n'>a</span> <span class='p'>&gt;</span> <span class='n'>b</span><span class='p'>)</span>
    <span class='k'>return</span> <span class='n'>a</span>
  <span class='k'>else</span>
    <span class='k'>return</span> <span class='n'>b</span>
<span class='p'>}</span></code></pre><p>식에 <em class='keyword'>if</em> 사용하기:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>max</span><span class='p'>(</span><span class='n'>a</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>,</span> <span class='n'>b</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>)</span> <span class='p'>=</span> <span class='k'>if</span> <span class='p'>(</span><span class='n'>a</span> <span class='p'>&gt;</span> <span class='n'>b</span><span class='p'>)</span> <span class='n'>a</span> <span class='k'>else</span> <span class='n'>b</span></code></pre><p><a href='#control-flow.html%23if-expression'><em class='keyword'>if</em>-식</a> 참고.</p><h3 id='basic-syntax.html_nullable---null-keyword--'>nullable 값 사용과 <em class='keyword'>null</em> 검사<a class='anchor' href='#%23nullable---null-keyword--'> </a></h3><p>레퍼런스가 <em class='keyword'>null</em> 값을 가질 수 있으면 반드시 nullable하다고 표시해야 한다.</p><p><code>str</code>이 정수를 포함하지 않을 때 <em class='keyword'>null</em>을 리턴하는 코드 예:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>parseInt</span><span class='p'>(</span><span class='n'>str</span><span class='p'>:</span> <span class='n'>String</span><span class='p'>):</span> <span class='n'>Int</span><span class='p'>?</span> <span class='p'>{</span>
  <span class='c1'>// ...</span>
<span class='p'>}</span></code></pre><p>nullable 값을 리턴하는 함수 사용하기:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>main</span><span class='p'>(</span><span class='n'>args</span><span class='p'>:</span> <span class='n'>Array</span><span class='p'>&lt;</span><span class='n'>String</span><span class='p'>&gt;)</span> <span class='p'>{</span>
  <span class='k'>if</span> <span class='p'>(</span><span class='n'>args</span><span class='p'>.</span><span class='n'>size</span> <span class='p'>&lt;</span> <span class='m'>2</span><span class='p'>)</span> <span class='p'>{</span>
    <span class='n'>print</span><span class='p'>(</span><span class='s'>&quot;Two integers expected&quot;</span><span class='p'>)</span>
    <span class='k'>return</span>
  <span class='p'>}</span>

  <span class='k'>val</span> <span class='py'>x</span> <span class='p'>=</span> <span class='n'>parseInt</span><span class='p'>(</span><span class='n'>args</span><span class='p'>[</span><span class='m'>0</span><span class='p'>])</span>
  <span class='k'>val</span> <span class='py'>y</span> <span class='p'>=</span> <span class='n'>parseInt</span><span class='p'>(</span><span class='n'>args</span><span class='p'>[</span><span class='m'>1</span><span class='p'>])</span>

  <span class='c1'>// 두 값이 null일 수 있으므로 `x * y`는 에러를 발생할 수 있다.</span>
  <span class='k'>if</span> <span class='p'>(</span><span class='n'>x</span> <span class='p'>!=</span> <span class='k'>null</span> <span class='p'>&amp;&amp;</span> <span class='n'>y</span> <span class='p'>!=</span> <span class='k'>null</span><span class='p'>)</span> <span class='p'>{</span>
    <span class='c1'>// null 검사 후에 x와 y를 non-nullable로 자동 변환</span>
    <span class='n'>print</span><span class='p'>(</span><span class='n'>x</span> <span class='p'>*</span> <span class='n'>y</span><span class='p'>)</span>
  <span class='p'>}</span>
<span class='p'>}</span></code></pre><p>또는</p><pre><code class='code-block _highlighted lang_kotlin'>  <span class='c1'>// ...</span>
  <span class='k'>if</span> <span class='p'>(</span><span class='n'>x</span> <span class='p'>==</span> <span class='k'>null</span><span class='p'>)</span> <span class='p'>{</span>
    <span class='n'>print</span><span class='p'>(</span><span class='s'>&quot;Wrong number format in &#39;${args[0]}&#39;&quot;</span><span class='p'>)</span>
    <span class='k'>return</span>
  <span class='p'>}</span>
  <span class='k'>if</span> <span class='p'>(</span><span class='n'>y</span> <span class='p'>==</span> <span class='k'>null</span><span class='p'>)</span> <span class='p'>{</span>
    <span class='n'>print</span><span class='p'>(</span><span class='s'>&quot;Wrong number format in &#39;${args[1]}&#39;&quot;</span><span class='p'>)</span>
    <span class='k'>return</span>
  <span class='p'>}</span>

  <span class='c1'>// null 검사 후에 x와 y를 non-nullable로 자동 변환</span>
  <span class='n'>print</span><span class='p'>(</span><span class='n'>x</span> <span class='p'>*</span> <span class='n'>y</span><span class='p'>)</span></code></pre><p><a href='#null-safety.html'>null-안전성</a> 참고.</p><h3 id='basic-syntax.html_section-7'>타입 검사와 자동 변환 사용하기<a class='anchor' href='#%23section-7'> </a></h3><p><em class='keyword'>is</em> 연산자는 대상이 지정한 타입의 인스턴스인지 검사한다.
불변(immutable) 로컬 변수나 프로퍼티에 대해 특정 타입인지 검사하면, 명시적으로 타입을 변환할 필요가 없다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>getStringLength</span><span class='p'>(</span><span class='n'>obj</span><span class='p'>:</span> <span class='n'>Any</span><span class='p'>):</span> <span class='n'>Int</span><span class='p'>?</span> <span class='p'>{</span>
  <span class='k'>if</span> <span class='p'>(</span><span class='n'>obj</span> <span class='k'>is</span> <span class='n'>String</span><span class='p'>)</span> <span class='p'>{</span>
    <span class='c1'>// 이 코드 브랜치(branch)에서 `obj`는 자동으로 `String`으로 변환</span>
    <span class='k'>return</span> <span class='n'>obj</span><span class='p'>.</span><span class='n'>length</span>
  <span class='p'>}</span>

  <span class='c1'>// 타입 검사 브랜치 밖에서 `obj`는 여전히 `Any` 타입</span>
  <span class='k'>return</span> <span class='k'>null</span>
<span class='p'>}</span></code></pre><p>또는</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>getStringLength</span><span class='p'>(</span><span class='n'>obj</span><span class='p'>:</span> <span class='n'>Any</span><span class='p'>):</span> <span class='n'>Int</span><span class='p'>?</span> <span class='p'>{</span>
  <span class='k'>if</span> <span class='p'>(</span><span class='n'>obj</span> <span class='p'>!</span><span class='k'>is</span> <span class='n'>String</span><span class='p'>)</span>
    <span class='k'>return</span> <span class='k'>null</span>

  <span class='c1'>// `obj`는 이 브랜치에서 자동으로 `String`으로 변환</span>
  <span class='k'>return</span> <span class='n'>obj</span><span class='p'>.</span><span class='n'>length</span>
<span class='p'>}</span></code></pre><p>또는 심지어 아래도 가능</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>getStringLength</span><span class='p'>(</span><span class='n'>obj</span><span class='p'>:</span> <span class='n'>Any</span><span class='p'>):</span> <span class='n'>Int</span><span class='p'>?</span> <span class='p'>{</span>
  <span class='c1'>// `&amp;&amp;`의 우측에서 자동으로 `String`으로 변환</span>
  <span class='k'>if</span> <span class='p'>(</span><span class='n'>obj</span> <span class='k'>is</span> <span class='n'>String</span> <span class='p'>&amp;&amp;</span> <span class='n'>obj</span><span class='p'>.</span><span class='n'>length</span> <span class='p'>&gt;</span> <span class='m'>0</span><span class='p'>)</span>
    <span class='k'>return</span> <span class='n'>obj</span><span class='p'>.</span><span class='n'>length</span>

  <span class='k'>return</span> <span class='k'>null</span>
<span class='p'>}</span></code></pre><p><a href='#classes.html'>클래스</a>와 <a href='#typecasts.html'>타입 변환</a> 참고.</p><h3 id='basic-syntax.html_for--'><code>for</code> 루프 사용하기<a class='anchor' href='#%23for--'> </a></h3><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>main</span><span class='p'>(</span><span class='n'>args</span><span class='p'>:</span> <span class='n'>Array</span><span class='p'>&lt;</span><span class='n'>String</span><span class='p'>&gt;)</span> <span class='p'>{</span>
  <span class='k'>for</span> <span class='p'>(</span><span class='n'>arg</span> <span class='k'>in</span> <span class='n'>args</span><span class='p'>)</span>
    <span class='n'>print</span><span class='p'>(</span><span class='n'>arg</span><span class='p'>)</span>
<span class='p'>}</span></code></pre><p>또는</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>for</span> <span class='p'>(</span><span class='n'>i</span> <span class='k'>in</span> <span class='n'>args</span><span class='p'>.</span><span class='n'>indices</span><span class='p'>)</span>
  <span class='n'>print</span><span class='p'>(</span><span class='n'>args</span><span class='p'>[</span><span class='n'>i</span><span class='p'>])</span></code></pre><p><a href='#control-flow.html%23for-loops'>for 루프</a> 참고.</p><h3 id='basic-syntax.html_while--'><code>while</code> 루프 사용하기<a class='anchor' href='#%23while--'> </a></h3><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>main</span><span class='p'>(</span><span class='n'>args</span><span class='p'>:</span> <span class='n'>Array</span><span class='p'>&lt;</span><span class='n'>String</span><span class='p'>&gt;)</span> <span class='p'>{</span>
  <span class='k'>var</span> <span class='py'>i</span> <span class='p'>=</span> <span class='m'>0</span>
  <span class='k'>while</span> <span class='p'>(</span><span class='n'>i</span> <span class='p'>&lt;</span> <span class='n'>args</span><span class='p'>.</span><span class='n'>size</span><span class='p'>)</span>
    <span class='n'>print</span><span class='p'>(</span><span class='n'>args</span><span class='p'>[</span><span class='n'>i</span><span class='p'>++])</span>
<span class='p'>}</span></code></pre><p><a href='#control-flow.html%23while-loops'>while 루프</a> 참고.</p><h3 id='basic-syntax.html_when--'><code>when</code> 식 사용하기<a class='anchor' href='#%23when--'> </a></h3><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>cases</span><span class='p'>(</span><span class='n'>obj</span><span class='p'>:</span> <span class='n'>Any</span><span class='p'>)</span> <span class='p'>{</span>
  <span class='k'>when</span> <span class='p'>(</span><span class='n'>obj</span><span class='p'>)</span> <span class='p'>{</span>
    <span class='m'>1</span>          <span class='p'>-&gt;</span> <span class='n'>print</span><span class='p'>(</span><span class='s'>&quot;One&quot;</span><span class='p'>)</span>
    <span class='s'>&quot;Hello&quot;</span>    <span class='p'>-&gt;</span> <span class='n'>print</span><span class='p'>(</span><span class='s'>&quot;Greeting&quot;</span><span class='p'>)</span>
    <span class='k'>is</span> <span class='n'>Long</span>    <span class='p'>-&gt;</span> <span class='n'>print</span><span class='p'>(</span><span class='s'>&quot;Long&quot;</span><span class='p'>)</span>
    <span class='p'>!</span><span class='k'>is</span> <span class='n'>String</span> <span class='p'>-&gt;</span> <span class='n'>print</span><span class='p'>(</span><span class='s'>&quot;Not a string&quot;</span><span class='p'>)</span>
    <span class='k'>else</span>       <span class='p'>-&gt;</span> <span class='n'>print</span><span class='p'>(</span><span class='s'>&quot;Unknown&quot;</span><span class='p'>)</span>
  <span class='p'>}</span>
<span class='p'>}</span></code></pre><p><a href='#control-flow.html%23when-expression'>when 식</a> 참고.</p><h3 id='basic-syntax.html_range-'>범위(range) 사용하기<a class='anchor' href='#%23range-'> </a></h3><p><em class='keyword'>in</em> 연산자를 사용해서 숫자가 특정 범위 안에 있는지 검사:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>if</span> <span class='p'>(</span><span class='n'>x</span> <span class='k'>in</span> <span class='m'>1.</span><span class='p'>.</span><span class='n'>y</span><span class='p'>-</span><span class='m'>1</span><span class='p'>)</span>
  <span class='n'>print</span><span class='p'>(</span><span class='s'>&quot;OK&quot;</span><span class='p'>)</span></code></pre><p>숫자가 범위 밖인지 검사:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>if</span> <span class='p'>(</span><span class='n'>x</span> <span class='p'>!</span><span class='k'>in</span> <span class='m'>0.</span><span class='p'>.</span><span class='n'>array</span><span class='p'>.</span><span class='n'>lastIndex</span><span class='p'>)</span>
  <span class='n'>print</span><span class='p'>(</span><span class='s'>&quot;Out&quot;</span><span class='p'>)</span></code></pre><p>범위에 속한 숫자를 반복(iteration):</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>for</span> <span class='p'>(</span><span class='n'>x</span> <span class='k'>in</span> <span class='m'>1.</span><span class='p'>.</span><span class='m'>5</span><span class='p'>)</span>
  <span class='n'>print</span><span class='p'>(</span><span class='n'>x</span><span class='p'>)</span></code></pre><p><a href='#ranges.html'>범위</a> 참고.</p><h3 id='basic-syntax.html_section-8'>콜렉션 사용하기<a class='anchor' href='#%23section-8'> </a></h3><p>콜렉션 반복:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>for</span> <span class='p'>(</span><span class='n'>name</span> <span class='k'>in</span> <span class='n'>names</span><span class='p'>)</span>
  <span class='n'>println</span><span class='p'>(</span><span class='n'>name</span><span class='p'>)</span></code></pre><p><em class='keyword'>in</em> 연산자를 사용해서 콜렉션이 객체를 포함하고 있는지 검사하기:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>if</span> <span class='p'>(</span><span class='n'>text</span> <span class='k'>in</span> <span class='n'>names</span><span class='p'>)</span> <span class='c1'>// names.contains(text) 호출</span>
  <span class='n'>print</span><span class='p'>(</span><span class='s'>&quot;Yes&quot;</span><span class='p'>)</span></code></pre><p>콜렉션을 필터링하고 변환(맵)할 때 람다식 사용하기:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>names</span>
    <span class='p'>.</span><span class='n'>filter</span> <span class='p'>{</span> <span class='n'>it</span><span class='p'>.</span><span class='n'>startsWith</span><span class='p'>(</span><span class='s'>&quot;A&quot;</span><span class='p'>)</span> <span class='p'>}</span>
    <span class='p'>.</span><span class='n'>sortedBy</span> <span class='p'>{</span> <span class='n'>it</span> <span class='p'>}</span>
    <span class='p'>.</span><span class='n'>map</span> <span class='p'>{</span> <span class='n'>it</span><span class='p'>.</span><span class='n'>toUpperCase</span><span class='p'>()</span> <span class='p'>}</span>
    <span class='p'>.</span><span class='n'>forEach</span> <span class='p'>{</span> <span class='n'>print</span><span class='p'>(</span><span class='n'>it</span><span class='p'>)</span> <span class='p'>}</span></code></pre><p><a href='#lambdas.html'>고차함수와 람다</a> 참고.</p>
              </article>
          
              <article id="idioms.html" class="page-content">
                <h2 id='idioms.html_idioms'>이디엄(Idioms)<a class='anchor' href='#%23idioms'> </a></h2><p>코틀린에서 자주 사용하는 코딩 방식을 모은 것이다. 여러분도 자주 사용하는 코딩 방식이 있다면 풀 리퀘스트를 날려 공헌해보자.</p><h4 id='idioms.html_dto--pojopoco'>DTO 만들기 (POJO/POCO)<a class='anchor' href='#%23dto--pojopoco'> </a></h4><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>data</span> <span class='k'>class</span> <span class='nc'>Customer</span><span class='p'>(</span><span class='k'>val</span> <span class='py'>name</span><span class='p'>:</span> <span class='n'>String</span><span class='p'>,</span> <span class='k'>val</span> <span class='py'>email</span><span class='p'>:</span> <span class='n'>String</span><span class='p'>)</span></code></pre><p>이 코드는 다음 기능을 가진 <code>Customer</code> 클래스를 제공한다:</p><ul>
  <li>모든 프로퍼티에 대한 getter (<em class='keyword'>var</em> 프로퍼티는 setter 포함)</li>
  <li><code>equals()</code></li>
  <li><code>hashCode()</code></li>
  <li><code>toString()</code></li>
  <li><code>copy()</code></li>
  <li>모든 프로퍼티에 대해 <code>component1()</code>, <code>component2()</code>, … (<a href='#data-classes.html'>데이터 클래스</a> 참고)</li>
</ul><h4 id='idioms.html_section'>함수 파라피터의 기본 값<a class='anchor' href='#%23section'> </a></h4><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>foo</span><span class='p'>(</span><span class='n'>a</span><span class='p'>:</span> <span class='n'>Int</span> <span class='p'>=</span> <span class='m'>0</span><span class='p'>,</span> <span class='n'>b</span><span class='p'>:</span> <span class='n'>String</span> <span class='p'>=</span> <span class='s'>&quot;&quot;</span><span class='p'>)</span> <span class='p'>{</span> <span class='p'>...</span> <span class='p'>}</span></code></pre><h4 id='idioms.html_section-1'>리스트 필터<a class='anchor' href='#%23section-1'> </a></h4><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>positives</span> <span class='p'>=</span> <span class='n'>list</span><span class='p'>.</span><span class='n'>filter</span> <span class='p'>{</span> <span class='n'>x</span> <span class='p'>-&gt;</span> <span class='n'>x</span> <span class='p'>&gt;</span> <span class='m'>0</span> <span class='p'>}</span></code></pre><p>또는 다음과 같이 짧게:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>positives</span> <span class='p'>=</span> <span class='n'>list</span><span class='p'>.</span><span class='n'>filter</span> <span class='p'>{</span> <span class='n'>it</span> <span class='p'>&gt;</span> <span class='m'>0</span> <span class='p'>}</span></code></pre><h4 id='idioms.html_section-2'>문자열 인터폴레이션(삽입)<a class='anchor' href='#%23section-2'> </a></h4><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>println</span><span class='p'>(</span><span class='s'>&quot;Name $name&quot;</span><span class='p'>)</span></code></pre><h4 id='idioms.html_section-3'>인스턴스 검사<a class='anchor' href='#%23section-3'> </a></h4><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>when</span> <span class='p'>(</span><span class='n'>x</span><span class='p'>)</span> <span class='p'>{</span>
    <span class='k'>is</span> <span class='n'>Foo</span> <span class='p'>-&gt;</span> <span class='p'>...</span>
    <span class='k'>is</span> <span class='n'>Bar</span> <span class='p'>-&gt;</span> <span class='p'>...</span>
    <span class='k'>else</span>   <span class='p'>-&gt;</span> <span class='p'>...</span>
<span class='p'>}</span></code></pre><h4 id='idioms.html_maplist-pair-'>map/list pair 탐색<a class='anchor' href='#%23maplist-pair-'> </a></h4><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>for</span> <span class='p'>((</span><span class='n'>k</span><span class='p'>,</span> <span class='n'>v</span><span class='p'>)</span> <span class='k'>in</span> <span class='n'>map</span><span class='p'>)</span> <span class='p'>{</span>
    <span class='n'>println</span><span class='p'>(</span><span class='s'>&quot;$k -&gt; $v&quot;</span><span class='p'>)</span>
<span class='p'>}</span></code></pre><p><code>k</code>, <code>v</code>에 아무 이름이나 붙여도 된다.</p><h4 id='idioms.html_section-4'>범위 사용<a class='anchor' href='#%23section-4'> </a></h4><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>for</span> <span class='p'>(</span><span class='n'>i</span> <span class='k'>in</span> <span class='m'>1.</span><span class='p'>.</span><span class='m'>100</span><span class='p'>)</span> <span class='p'>{</span> <span class='p'>...</span> <span class='p'>}</span>
<span class='k'>for</span> <span class='p'>(</span><span class='n'>x</span> <span class='k'>in</span> <span class='m'>2.</span><span class='p'>.</span><span class='m'>10</span><span class='p'>)</span> <span class='p'>{</span> <span class='p'>...</span> <span class='p'>}</span></code></pre><h4 id='idioms.html_section-5'>읽기 전용 리스트<a class='anchor' href='#%23section-5'> </a></h4><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>list</span> <span class='p'>=</span> <span class='n'>listOf</span><span class='p'>(</span><span class='s'>&quot;a&quot;</span><span class='p'>,</span> <span class='s'>&quot;b&quot;</span><span class='p'>,</span> <span class='s'>&quot;c&quot;</span><span class='p'>)</span></code></pre><h4 id='idioms.html_section-6'>읽기 전용 맵<a class='anchor' href='#%23section-6'> </a></h4><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>map</span> <span class='p'>=</span> <span class='n'>mapOf</span><span class='p'>(</span><span class='s'>&quot;a&quot;</span> <span class='n'>to</span> <span class='m'>1</span><span class='p'>,</span> <span class='s'>&quot;b&quot;</span> <span class='n'>to</span> <span class='m'>2</span><span class='p'>,</span> <span class='s'>&quot;c&quot;</span> <span class='n'>to</span> <span class='m'>3</span><span class='p'>)</span></code></pre><h4 id='idioms.html_section-7'>맵 접근<a class='anchor' href='#%23section-7'> </a></h4><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>println</span><span class='p'>(</span><span class='n'>map</span><span class='p'>[</span><span class='s'>&quot;key&quot;</span><span class='p'>])</span>
<span class='n'>map</span><span class='p'>[</span><span class='s'>&quot;key&quot;</span><span class='p'>]</span> <span class='p'>=</span> <span class='n'>value</span></code></pre><h4 id='idioms.html_lazy-'>지연(lazy) 프로퍼티<a class='anchor' href='#%23lazy-'> </a></h4><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>p</span><span class='p'>:</span> <span class='n'>String</span> <span class='k'>by</span> <span class='n'>lazy</span> <span class='p'>{</span>
    <span class='c1'>// 문자열 계산</span>
<span class='p'>}</span></code></pre><h4 id='idioms.html_section-8'>확장 함수<a class='anchor' href='#%23section-8'> </a></h4><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>String</span><span class='p'>.</span><span class='n'>spaceToCamelCase</span><span class='p'>()</span> <span class='p'>{</span> <span class='p'>...</span> <span class='p'>}</span>

<span class='s'>&quot;Convert this to camelcase&quot;</span><span class='p'>.</span><span class='n'>spaceToCamelCase</span><span class='p'>()</span></code></pre><h4 id='idioms.html_section-9'>싱글톤 생성<a class='anchor' href='#%23section-9'> </a></h4><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>object</span> <span class='nc'>Resource</span> <span class='p'>{</span>
    <span class='k'>val</span> <span class='py'>name</span> <span class='p'>=</span> <span class='s'>&quot;Name&quot;</span>
<span class='p'>}</span></code></pre><h4 id='idioms.html_if-not-null--'>if not null 단축 표현<a class='anchor' href='#%23if-not-null--'> </a></h4><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>files</span> <span class='p'>=</span> <span class='n'>File</span><span class='p'>(</span><span class='s'>&quot;Test&quot;</span><span class='p'>).</span><span class='n'>listFiles</span><span class='p'>()</span>

<span class='n'>println</span><span class='p'>(</span><span class='n'>files</span><span class='o'>?.</span><span class='n'>size</span><span class='p'>)</span></code></pre><h4 id='idioms.html_if-not-null-else--'>if not null과 else 단축 표현<a class='anchor' href='#%23if-not-null-else--'> </a></h4><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>files</span> <span class='p'>=</span> <span class='n'>File</span><span class='p'>(</span><span class='s'>&quot;Test&quot;</span><span class='p'>).</span><span class='n'>listFiles</span><span class='p'>()</span>

<span class='n'>println</span><span class='p'>(</span><span class='n'>files</span><span class='o'>?.</span><span class='n'>size</span> <span class='o'>?:</span> <span class='s'>&quot;empty&quot;</span><span class='p'>)</span></code></pre><h4 id='idioms.html_null--'>null이면 문장 실행하기<a class='anchor' href='#%23null--'> </a></h4><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>data</span> <span class='p'>=</span> <span class='p'>...</span>
<span class='k'>val</span> <span class='py'>email</span> <span class='p'>=</span> <span class='n'>data</span><span class='p'>[</span><span class='s'>&quot;email&quot;</span><span class='p'>]</span> <span class='o'>?:</span> <span class='k'>throw</span> <span class='n'>IllegalStateException</span><span class='p'>(</span><span class='s'>&quot;Email is missing!&quot;</span><span class='p'>)</span></code></pre><h4 id='idioms.html_null---1'>null이 아니면 실행하기<a class='anchor' href='#%23null---1'> </a></h4><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>data</span> <span class='p'>=</span> <span class='p'>...</span>

<span class='n'>data</span><span class='o'>?.</span><span class='n'>let</span> <span class='p'>{</span>
    <span class='p'>...</span> <span class='c1'>// null이 아니면 이 블록을 실행</span>
<span class='p'>}</span></code></pre><h4 id='idioms.html_when--'>when 문장에서 리턴하기<a class='anchor' href='#%23when--'> </a></h4><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>transform</span><span class='p'>(</span><span class='n'>color</span><span class='p'>:</span> <span class='n'>String</span><span class='p'>):</span> <span class='n'>Int</span> <span class='p'>{</span>
    <span class='k'>return</span> <span class='k'>when</span> <span class='p'>(</span><span class='n'>color</span><span class='p'>)</span> <span class='p'>{</span>
        <span class='s'>&quot;Red&quot;</span> <span class='p'>-&gt;</span> <span class='m'>0</span>
        <span class='s'>&quot;Green&quot;</span> <span class='p'>-&gt;</span> <span class='m'>1</span>
        <span class='s'>&quot;Blue&quot;</span> <span class='p'>-&gt;</span> <span class='m'>2</span>
        <span class='k'>else</span> <span class='p'>-&gt;</span> <span class='k'>throw</span> <span class='n'>IllegalArgumentException</span><span class='p'>(</span><span class='s'>&quot;Invalid color param value&quot;</span><span class='p'>)</span>
    <span class='p'>}</span>
<span class='p'>}</span></code></pre><h4 id='idioms.html_trycatch-'>‘try/catch’ 식<a class='anchor' href='#%23trycatch-'> </a></h4><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>test</span><span class='p'>()</span> <span class='p'>{</span>
    <span class='k'>val</span> <span class='py'>result</span> <span class='p'>=</span> <span class='k'>try</span> <span class='p'>{</span>
        <span class='n'>count</span><span class='p'>()</span>
    <span class='p'>}</span> <span class='k'>catch</span> <span class='p'>(</span><span class='n'>e</span><span class='p'>:</span> <span class='n'>ArithmeticException</span><span class='p'>)</span> <span class='p'>{</span>
        <span class='k'>throw</span> <span class='n'>IllegalStateException</span><span class='p'>(</span><span class='n'>e</span><span class='p'>)</span>
    <span class='p'>}</span>

    <span class='c1'>// result로 작업</span>
<span class='p'>}</span></code></pre><h4 id='idioms.html_if-'>‘if’ 식<a class='anchor' href='#%23if-'> </a></h4><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>foo</span><span class='p'>(</span><span class='n'>param</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>)</span> <span class='p'>{</span>
    <span class='k'>val</span> <span class='py'>result</span> <span class='p'>=</span> <span class='k'>if</span> <span class='p'>(</span><span class='n'>param</span> <span class='p'>==</span> <span class='m'>1</span><span class='p'>)</span> <span class='p'>{</span>
        <span class='s'>&quot;one&quot;</span>
    <span class='p'>}</span> <span class='k'>else</span> <span class='k'>if</span> <span class='p'>(</span><span class='n'>param</span> <span class='p'>==</span> <span class='m'>2</span><span class='p'>)</span> <span class='p'>{</span>
        <span class='s'>&quot;two&quot;</span>
    <span class='p'>}</span> <span class='k'>else</span> <span class='p'>{</span>
        <span class='s'>&quot;three&quot;</span>
    <span class='p'>}</span>
<span class='p'>}</span></code></pre><h4 id='idioms.html_unit---builder--'><code>Unit</code>을 리턴하는 메서드를 빌더(Builder) 스타일로 사용<a class='anchor' href='#%23unit---builder--'> </a></h4><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>arrayOfMinusOnes</span><span class='p'>(</span><span class='n'>size</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>):</span> <span class='n'>IntArray</span> <span class='p'>{</span>
    <span class='k'>return</span> <span class='n'>IntArray</span><span class='p'>(</span><span class='n'>size</span><span class='p'>).</span><span class='n'>apply</span> <span class='p'>{</span> <span class='n'>fill</span><span class='p'>(-</span><span class='m'>1</span><span class='p'>)</span> <span class='p'>}</span>
<span class='p'>}</span></code></pre><h4 id='idioms.html_section-10'>한 개 식을 갖는 함수<a class='anchor' href='#%23section-10'> </a></h4><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>theAnswer</span><span class='p'>()</span> <span class='p'>=</span> <span class='m'>42</span></code></pre><p>이 코드는 다음 코드와 동일하다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>theAnswer</span><span class='p'>():</span> <span class='n'>Int</span> <span class='p'>{</span>
    <span class='k'>return</span> <span class='m'>42</span>
<span class='p'>}</span></code></pre><p>코드를 더 짧게 하기 위해 이 코드를 다른 이디엄과 함께 사용할 수 있다. 다음은 <em class='keyword'>when</em> 식과 함께 사용한 예이다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>transform</span><span class='p'>(</span><span class='n'>color</span><span class='p'>:</span> <span class='n'>String</span><span class='p'>):</span> <span class='n'>Int</span> <span class='p'>=</span> <span class='k'>when</span> <span class='p'>(</span><span class='n'>color</span><span class='p'>)</span> <span class='p'>{</span>
    <span class='s'>&quot;Red&quot;</span> <span class='p'>-&gt;</span> <span class='m'>0</span>
    <span class='s'>&quot;Green&quot;</span> <span class='p'>-&gt;</span> <span class='m'>1</span>
    <span class='s'>&quot;Blue&quot;</span> <span class='p'>-&gt;</span> <span class='m'>2</span>
    <span class='k'>else</span> <span class='p'>-&gt;</span> <span class='k'>throw</span> <span class='n'>IllegalArgumentException</span><span class='p'>(</span><span class='s'>&quot;Invalid color param value&quot;</span><span class='p'>)</span>
<span class='p'>}</span></code></pre><h4 id='idioms.html_with'>객체 인스턴스의 메서드 여러 번 호출하기 (‘with’)<a class='anchor' href='#%23with'> </a></h4><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>class</span> <span class='nc'>Turtle</span> <span class='p'>{</span>
    <span class='k'>fun</span> <span class='nf'>penDown</span><span class='p'>()</span>
    <span class='k'>fun</span> <span class='nf'>penUp</span><span class='p'>()</span>
    <span class='k'>fun</span> <span class='nf'>turn</span><span class='p'>(</span><span class='n'>degrees</span><span class='p'>:</span> <span class='n'>Double</span><span class='p'>)</span>
    <span class='k'>fun</span> <span class='nf'>forward</span><span class='p'>(</span><span class='n'>pixels</span><span class='p'>:</span> <span class='n'>Double</span><span class='p'>)</span>
<span class='p'>}</span>

<span class='k'>val</span> <span class='py'>myTurtle</span> <span class='p'>=</span> <span class='n'>Turtle</span><span class='p'>()</span>
<span class='n'>with</span><span class='p'>(</span><span class='n'>myTurtle</span><span class='p'>)</span> <span class='p'>{</span> <span class='c1'>// 100 픽셀 정사각형 그리기</span>
    <span class='n'>penDown</span><span class='p'>()</span>
    <span class='k'>for</span><span class='p'>(</span><span class='n'>i</span> <span class='k'>in</span> <span class='m'>1.</span><span class='p'>.</span><span class='m'>4</span><span class='p'>)</span> <span class='p'>{</span>
        <span class='n'>forward</span><span class='p'>(</span><span class='m'>100.0</span><span class='p'>)</span>
        <span class='n'>turn</span><span class='p'>(</span><span class='m'>90.0</span><span class='p'>)</span>
    <span class='p'>}</span>
    <span class='n'>penUp</span><span class='p'>()</span>
<span class='p'>}</span></code></pre><h4 id='idioms.html_try-with-resources'>자바 7의 try-with-resources<a class='anchor' href='#%23try-with-resources'> </a></h4><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>stream</span> <span class='p'>=</span> <span class='n'>Files</span><span class='p'>.</span><span class='n'>newInputStream</span><span class='p'>(</span><span class='n'>Paths</span><span class='p'>.</span><span class='k'>get</span><span class='p'>(</span><span class='s'>&quot;/some/file.txt&quot;</span><span class='p'>))</span>
<span class='n'>stream</span><span class='p'>.</span><span class='n'>buffered</span><span class='p'>().</span><span class='n'>reader</span><span class='p'>().</span><span class='n'>use</span> <span class='p'>{</span> <span class='n'>reader</span> <span class='p'>-&gt;</span>
    <span class='n'>println</span><span class='p'>(</span><span class='n'>reader</span><span class='p'>.</span><span class='n'>readText</span><span class='p'>())</span>
<span class='p'>}</span></code></pre><h4 id='idioms.html_section-11'>지네릭 타입 정보가 필요한 지네릭 함수를 위한 간편 형식<a class='anchor' href='#%23section-11'> </a></h4><pre><code class='code-block _highlighted lang_kotlin'><span class='c1'>//  public final class Gson {</span>
<span class='c1'>//     ...</span>
<span class='c1'>//     public &lt;T&gt; T fromJson(JsonElement json, Class&lt;T&gt; classOfT) throws JsonSyntaxException {</span>
<span class='c1'>//     ...</span>

<span class='n'>inline</span> <span class='k'>fun</span> <span class='err'>&lt;</span><span class='nf'>reified</span> <span class='n'>T</span><span class='p'>:</span> <span class='n'>Any</span><span class='p'>&gt;</span> <span class='n'>Gson</span><span class='p'>.</span><span class='n'>fromJson</span><span class='p'>(</span><span class='n'>json</span><span class='p'>):</span> <span class='n'>T</span> <span class='p'>=</span> <span class='k'>this</span><span class='p'>.</span><span class='n'>fromJson</span><span class='p'>(</span><span class='n'>json</span><span class='p'>,</span> <span class='n'>T</span><span class='o'>::</span><span class='k'>class</span><span class='p'>.</span><span class='n'>java</span><span class='p'>)</span></code></pre>
              </article>
          
              <article id="coding-conventions.html" class="page-content">
                <h2 id='coding-conventions.html_section'>코딩 규칙<a class='anchor' href='#%23section'> </a></h2><p>이 문서는 코틀린 언어를 위해 현재 사용 중인 코딩 스타일을 포함한다.</p><h3 id='coding-conventions.html_section-1'>이름 규칙<a class='anchor' href='#%23section-1'> </a></h3><p>애매하지 않다면, 다음 자바 코딩 규칙을 기본으로 사용한다:</p><ul>
  <li>이름에는 낙타표기법을 사용한다(이름에 밑줄을 넣지 않는다)</li>
  <li>타입은 대문자로 시작한다</li>
  <li>메서드와 프로퍼티는 소문자로 시작한다</li>
  <li>들여쓰기에 공백 4개를 사용한다</li>
  <li>public 함수는 코틀린 문서에 보이도록 문서화를 한다</li>
</ul><h3 id='coding-conventions.html_section-2'>콜론<a class='anchor' href='#%23section-2'> </a></h3><p>콜론이 타입과 상위 타입을 구분하면 콜론 전에 공백을 넣고, 콜론이 인스턴스와 타입을 구분하면 공백을 넣지 않는다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>interface</span> <span class='n'>Foo</span><span class='p'>&lt;</span><span class='k'>out</span> <span class='n'>T</span> <span class='p'>:</span> <span class='n'>Any</span><span class='p'>&gt;</span> <span class='p'>:</span> <span class='n'>Bar</span> <span class='p'>{</span>
    <span class='k'>fun</span> <span class='nf'>foo</span><span class='p'>(</span><span class='n'>a</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>):</span> <span class='n'>T</span>
<span class='p'>}</span></code></pre><h3 id='coding-conventions.html_section-3'>람다<a class='anchor' href='#%23section-3'> </a></h3><p>람다식에서, 중괄호 주변에 공백을 사용하고, 파라미터와 몸체를 구분하는 -&gt; 주변에도 공백을 사용한다.
가능하면 람다를 괄호 밖에 전달한다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>list</span><span class='p'>.</span><span class='n'>filter</span> <span class='p'>{</span> <span class='n'>it</span> <span class='p'>&gt;</span> <span class='m'>10</span> <span class='p'>}.</span><span class='n'>map</span> <span class='p'>{</span> <span class='n'>element</span> <span class='p'>-&gt;</span> <span class='n'>element</span> <span class='p'>*</span> <span class='m'>2</span> <span class='p'>}</span></code></pre><p>짧고 중첩되지 않은 람다의 경우, 파라미터를 명시적으로 선언하지 말고 대신 <code>it</code>을 사용한다.
파라미터를 가진 중첩된 람다는 파라미터를 항상 명시적으로 지정한다.</p><h3 id='coding-conventions.html_unit'>Unit<a class='anchor' href='#%23unit'> </a></h3><p>함수가 Unit을 리턴하면 리턴 타입을 생략한다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>foo</span><span class='p'>()</span> <span class='p'>{</span> <span class='c1'>// &quot;: Unit&quot;을 생략함</span>

<span class='p'>}</span></code></pre><h3 id='coding-conventions.html_section-4'>함수 대 프로퍼티<a class='anchor' href='#%23section-4'> </a></h3><p>인자 없는 함수와 읽기 전용 프로퍼티는 서로 대신 사용할 수 있다.
비록 의미가 비슷하긴 하지만, 몇 가지 규칙에 따라 둘 중 하나를 선택한다.</p><p>다음 알고리즘일 때 함수보다 프로퍼티를 선호한다:</p><ul>
  <li>익셉션을 던지지 않음</li>
  <li><code>O(1)</code> 복잡도를 가짐</li>
  <li>계산 비용이 작다 (또는 처음 실행시 캐시한다)</li>
  <li>호출과 같은 결과를 리턴한다</li>
</ul>
              </article>
          

        </section>
    

    
        <section>
          <h1 id="Basics"
              class="section-title">
            Basics
          </h1>

          
              <article id="basic-types.html" class="page-content">
                <h2 id='basic-types.html_section'>기본 타입<a class='anchor' href='#%23section'> </a></h2><p>코틀린은 모든 게 객체라서 변수에 대해 멤버 함수나 프로퍼티를 사용할 수 있다. 최적화 목적의 일부 타입을 제공하고 있지만 사용자에게는 일반 클래스와 같다. 이 절에서는 이 타입 중 숫자, 문자, 부울, 배열에 대해 설명한다.</p><h3 id='basic-types.html_section-1'>숫자<a class='anchor' href='#%23section-1'> </a></h3><p>코틀린은 자바와 유사한 방법으로 숫자를 다루지만 완전히 동일한 것은 아니다. 예를 들어, 숫자의 경우 큰 범위로의 자동 변환이 없고, 리터럴은 경우에 따라 약간 다르다.</p><p>코틀린은 숫자를 위해 다음의 내장 타입을 제공한다(자바와 유사하다):</p><table>
  <thead>
    <tr>
      <th>타입</th>
      <th>비트 길이</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Double</td>
      <td>64</td>
    </tr>
    <tr>
      <td>Float</td>
      <td>32</td>
    </tr>
    <tr>
      <td>Long</td>
      <td>64</td>
    </tr>
    <tr>
      <td>Int</td>
      <td>32</td>
    </tr>
    <tr>
      <td>Short</td>
      <td>16</td>
    </tr>
    <tr>
      <td>Byte</td>
      <td>8</td>
    </tr>
  </tbody>
</table><p>코틀린에서 문자는 숫자가 아니다.</p><h4 id='basic-types.html_section-2'>리터럴 상수<a class='anchor' href='#%23section-2'> </a></h4><p>정수 값에 대해 다음의 리터럴 상수가 존재한다:</p><ul>
  <li>십진법: <code>123</code>
    <ul>
      <li>Long은 대문자 ‘L’을 붙인다: <code>123L</code></li>
    </ul>
  </li>
  <li>16진법: <code>0x0F</code></li>
  <li>이진법: <code>0b00001011</code></li>
</ul><p>주의: 8진법 리터럴은 지원하지 않는다.</p><p>코틀린은 또한 실수에 대해 다음 표기법을 지원한다.</p><ul>
  <li>기본은 Double: <code>123.5</code>, <code>123.5e10</code></li>
  <li><code>f</code>나 <code>F</code>를 붙여 Float 표현: <code>123.5f</code></li>
</ul><h4 id='basic-types.html_representation'>표현(Representation)<a class='anchor' href='#%23representation'> </a></h4><p>자바 플랫폼에서는 물리적으로 JVM 기본 타입으로 숫자를 보관한다.
nullable 숫자 참조(예, <code>Int?</code>)가 필요하거나 지네릭과 연관이 있다면 박싱 타입을 사용한다.</p><p>숫자를 박싱하면 참조 동일성(identity)는 유지되지 않는 것에 주의해야 한다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>a</span><span class='p'>:</span> <span class='n'>Int</span> <span class='p'>=</span> <span class='m'>10000</span>
<span class='n'>print</span><span class='p'>(</span><span class='n'>a</span> <span class='p'>===</span> <span class='n'>a</span><span class='p'>)</span> <span class='c1'>// &#39;true&#39; 출력</span>
<span class='k'>val</span> <span class='py'>boxedA</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>?</span> <span class='p'>=</span> <span class='n'>a</span>
<span class='k'>val</span> <span class='py'>anotherBoxedA</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>?</span> <span class='p'>=</span> <span class='n'>a</span>
<span class='n'>print</span><span class='p'>(</span><span class='n'>boxedA</span> <span class='p'>===</span> <span class='n'>anotherBoxedA</span><span class='p'>)</span> <span class='c1'>// !!!&#39;false&#39; 출력!!!</span></code></pre><p>반면에 값 동등성(equality)은 유지된다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>a</span><span class='p'>:</span> <span class='n'>Int</span> <span class='p'>=</span> <span class='m'>10000</span>
<span class='n'>print</span><span class='p'>(</span><span class='n'>a</span> <span class='p'>==</span> <span class='n'>a</span><span class='p'>)</span> <span class='c1'>// &#39;true&#39; 출력</span>
<span class='k'>val</span> <span class='py'>boxedA</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>?</span> <span class='p'>=</span> <span class='n'>a</span>
<span class='k'>val</span> <span class='py'>anotherBoxedA</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>?</span> <span class='p'>=</span> <span class='n'>a</span>
<span class='n'>print</span><span class='p'>(</span><span class='n'>boxedA</span> <span class='p'>==</span> <span class='n'>anotherBoxedA</span><span class='p'>)</span> <span class='c1'>// &#39;true&#39; 출력</span></code></pre><h4 id='basic-types.html_section-3'>명시적 변환<a class='anchor' href='#%23section-3'> </a></h4><p>표현이 다르기 때문에, 작은 범위 타입은 큰 범위 타입의 하위타입이 아니다.
만약 하위타입이 된다면, 다음과 같은 상황에서 문제가 된다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='c1'>// 가상의 코드로, 실제로는 컴파일되지 않는다:</span>
<span class='k'>val</span> <span class='py'>a</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>?</span> <span class='p'>=</span> <span class='m'>1</span> <span class='c1'>// Int의 박싱 타입 (java.lang.Integer)</span>
<span class='k'>val</span> <span class='py'>b</span><span class='p'>:</span> <span class='n'>Long</span><span class='p'>?</span> <span class='p'>=</span> <span class='n'>a</span> <span class='c1'>// Long의 박싱 타입(java.lang.Long)을 만드는 자동 타입 변환</span>
<span class='n'>print</span><span class='p'>(</span><span class='n'>a</span> <span class='p'>==</span> <span class='n'>b</span><span class='p'>)</span> <span class='c1'>// 깜놀! Long의 equals()는 비교 대상이 Long인지 검사하기 때문에 이 코드는 &quot;false&quot;를 출력한다.</span></code></pre><p>따라서, 동일성(identity)뿐만 아니라, 모든 곳에서 동등성(equality)까지 잃게 될 수 있다.</p><p>이런 까닭에, 작은 타입을 큰 타입으로 자동 변환하지 않는다.
이는 명시적 변환없이 <code>Byte</code> 값을 <code>Int</code> 변수에 할당할 수 없음을 의미한다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>b</span><span class='p'>:</span> <span class='n'>Byte</span> <span class='p'>=</span> <span class='m'>1</span> <span class='c1'>// OK, 리터럴은 정적으로 검사한다.</span>
<span class='k'>val</span> <span class='py'>i</span><span class='p'>:</span> <span class='n'>Int</span> <span class='p'>=</span> <span class='n'>b</span> <span class='c1'>// 에러</span></code></pre><p>큰 범위 숫자로 명시적으로 타입 변환을 할 수 있다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>i</span><span class='p'>:</span> <span class='n'>Int</span> <span class='p'>=</span> <span class='n'>b</span><span class='p'>.</span><span class='n'>toInt</span><span class='p'>()</span> <span class='c1'>// OK: 명시적으로 큰 범위 타입으로 변환</span></code></pre><p>모든 숫자 타입은 다음 변환을 지원한다:</p><ul>
  <li><code>toByte(): Byte</code></li>
  <li><code>toShort(): Short</code></li>
  <li><code>toInt(): Int</code></li>
  <li><code>toLong(): Long</code></li>
  <li><code>toFloat(): Float</code></li>
  <li><code>toDouble(): Double</code></li>
  <li><code>toChar(): Char</code></li>
</ul><p>문맥에서 타입을 추론할 수 있고, 수치 연산자를 각 타입 변환에 맞게 오버로딩했기 때문에,
자동 타입 변환이 없어도 거의 문제가 되지 않는다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>l</span> <span class='p'>=</span> <span class='m'>1L</span> <span class='p'>+</span> <span class='m'>3</span> <span class='c1'>// Long + Int =&gt; Long</span></code></pre><h4 id='basic-types.html_section-4'>연산<a class='anchor' href='#%23section-4'> </a></h4><p>코틀린은 숫자에 대한 표준 수치 연산을 지원한다. 이 연산자는 각 타입의 멤버로 정의되어 있다(컴파일러가 해당 명령어로 최적화한다).
<a href='#operator-overloading.html'>연산자 오버로딩</a> 참고.</p><p>비트 연산의 경우, 이를 위한 특수 문자를 사용하지 않고, 중위 형식으로 호출할 수 있는 (이름을 가진) 함수가 존재한다. 다음은 예이다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>x</span> <span class='p'>=</span> <span class='p'>(</span><span class='m'>1</span> <span class='n'>shl</span> <span class='m'>2</span><span class='p'>)</span> <span class='n'>and</span> <span class='m'>0</span><span class='n'>x000FF000</span></code></pre><p>다음은 전체 비트 연산 목록이다(<code>Int</code>와 <code>Long</code>만 가능).</p><ul>
  <li><code>shl(bits)</code> – 부호가진 좌측 쉬프트 (자바의 <code>&lt;&lt;</code>)</li>
  <li><code>shr(bits)</code> – 부호가진 우측 쉬프트 (자바의 <code>&gt;&gt;</code>)</li>
  <li><code>ushr(bits)</code> – 부호없는 오른쪽 쉬프트 (자바의 <code>&gt;&gt;&gt;</code>)</li>
  <li><code>and(bits)</code> – and 비트연산</li>
  <li><code>or(bits)</code> – or 비트연산</li>
  <li><code>xor(bits)</code> – xor 비트연산</li>
  <li><code>inv()</code> – 역 비트연산</li>
</ul><h3 id='basic-types.html_section-5'>문자<a class='anchor' href='#%23section-5'> </a></h3><p><code>Char</code> 타입으로 문자를 표현한다. 문자를 숫자로 다룰 수 없다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>check</span><span class='p'>(</span><span class='n'>c</span><span class='p'>:</span> <span class='n'>Char</span><span class='p'>)</span> <span class='p'>{</span>
  <span class='k'>if</span> <span class='p'>(</span><span class='n'>c</span> <span class='p'>==</span> <span class='m'>1</span><span class='p'>)</span> <span class='p'>{</span> <span class='c1'>// ERROR: 호환되지 않는 타입</span>
    <span class='c1'>// ...</span>
  <span class='p'>}</span>
<span class='p'>}</span></code></pre><p>문자 리터럴은 단일 따옴표 안에 위치한다: <code>'1'</code>.
특수 문자는 역슬래시를 이용해서 표시한다.
지원하는 이스케이프 시퀀스는 다음과 같다: <code>\t</code>, <code>\b</code>, <code>\n</code>, <code>\r</code>, <code>\'</code>, <code>\"</code>, <code>\\</code> 그리고 <code>\$</code>.
다른 문자를 인코딩하려면, 유니코드 이스케이프 시퀀스 구문을 사용한다: <code>'\uFF00'</code>.</p><p>문자를 <code>Int</code> 숫자로 변환할 수 있다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>decimalDigitValue</span><span class='p'>(</span><span class='n'>c</span><span class='p'>:</span> <span class='n'>Char</span><span class='p'>):</span> <span class='n'>Int</span> <span class='p'>{</span>
  <span class='k'>if</span> <span class='p'>(</span><span class='n'>c</span> <span class='p'>!</span><span class='k'>in</span> <span class='sc'>&#39;0&#39;</span><span class='p'>..</span><span class='sc'>&#39;9&#39;</span><span class='p'>)</span>
    <span class='k'>throw</span> <span class='n'>IllegalArgumentException</span><span class='p'>(</span><span class='s'>&quot;Out of range&quot;</span><span class='p'>)</span>
  <span class='k'>return</span> <span class='n'>c</span><span class='p'>.</span><span class='n'>toInt</span><span class='p'>()</span> <span class='p'>-</span> <span class='sc'>&#39;0&#39;</span><span class='p'>.</span><span class='n'>toInt</span><span class='p'>()</span> <span class='c1'>// 숫자로 변환</span>
<span class='p'>}</span></code></pre><p>숫자처럼, nullable 참조가 필요하면 문자를 박싱한다. 박싱 연산은 동일성(identity)을 유지하지 않는다.</p><h3 id='basic-types.html_boolean'>부울(Boolean)<a class='anchor' href='#%23boolean'> </a></h3><p><code>Boolean</code> 타입은 부울을 표현하며 <em class='keyword'>true</em>와 <em class='keyword'>false</em>의 두 값을 갖는다.</p><p>nullable 참조가 필요하면 Boolean을 박싱한다.</p><p>부울 타입의 내장 연산은 다음과 같다.</p><ul>
  <li><code>||</code> – lazy 논리 합(disjunction)</li>
  <li><code>&amp;&amp;</code> – lazy 논리 곱(conjunction)</li>
  <li><code>!</code> - 부정</li>
</ul><h3 id='basic-types.html_section-6'>배열<a class='anchor' href='#%23section-6'> </a></h3><p>코틀린은 <code>Array</code> 클래스를 이용해서 배열을 표현한다. 이 클래스는 <code>get</code>과 <code>set</code> 함수와 <code>size</code> 프로퍼티를 가지며, 몇 개의 다른 유용한 멤버 함수가 있다(<code>get</code>, <code>set</code> 함수는 연산자 오버로딩 규칙에 따라 <code>[]</code>로 바뀐다):</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>class</span> <span class='nc'>Array</span><span class='p'>&lt;</span><span class='n'>T</span><span class='p'>&gt;</span> <span class='k'>private</span> <span class='n'>constructor</span><span class='p'>()</span> <span class='p'>{</span>
  <span class='k'>val</span> <span class='py'>size</span><span class='p'>:</span> <span class='n'>Int</span>
  <span class='k'>fun</span> <span class='nf'>get</span><span class='p'>(</span><span class='n'>index</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>):</span> <span class='n'>T</span>
  <span class='k'>fun</span> <span class='nf'>set</span><span class='p'>(</span><span class='n'>index</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>,</span> <span class='n'>value</span><span class='p'>:</span> <span class='n'>T</span><span class='p'>):</span> <span class='n'>Unit</span>

  <span class='k'>fun</span> <span class='nf'>iterator</span><span class='p'>():</span> <span class='n'>Iterator</span><span class='p'>&lt;</span><span class='n'>T</span><span class='p'>&gt;</span>
  <span class='c1'>// ...</span>
<span class='p'>}</span></code></pre><p><code>arrayOf()</code> 라이브러리 함수를 이용해서 배열을 생성한다. 이 함수에 값 목록을 제공한다. 예를 들어, <code>arrayOf(1, 2, 3)</code>는 [1, 2, 3] 배열을 생성한다.
<code>arrayOfNulls()</code> 라이브러리 함수를 사용하면 null을 값으로 갖는 지정한 크기의 배열을 생성한다.</p><p>팩토리 함수를 사용할 수도 있다. 팩토리 함수는 배열 크기와 배열의 각 인덱스에 대해 초기 값을 생성하는 함수를 인자로 받는다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='c1'>// [&quot;0&quot;, &quot;1&quot;, &quot;4&quot;, &quot;9&quot;, &quot;16&quot;]을 값으로 갖는 Array&lt;String&gt; 생성</span>
<span class='k'>val</span> <span class='py'>asc</span> <span class='p'>=</span> <span class='n'>Array</span><span class='p'>(</span><span class='m'>5</span><span class='p'>,</span> <span class='p'>{</span> <span class='n'>i</span> <span class='p'>-&gt;</span> <span class='p'>(</span><span class='n'>i</span> <span class='p'>*</span> <span class='n'>i</span><span class='p'>).</span><span class='n'>toString</span><span class='p'>()</span> <span class='p'>})</span></code></pre><p>앞서 말했듯이 <code>[]</code> 연산은 <code>get()</code>과 <code>set()</code> 함수 호출을 의미한다.</p><p>주의: 자바와 달리 코틀린의 배열은 무공변(invarint)이다. 이는 <code>Array&lt;String&gt;</code>을 <code>Array&lt;Any&gt;</code>에 할당할 수 없음을 의미하는데,
이는 런타임 실패를 가능한 방지한다(하지만 <code>Array&lt;out Any&gt;</code>는 사용할 수 있는데 이에 대한 내용은 <a href='#generics.html%23type-projections'>Type Projections</a>을 참고한다).</p><p>코틀린은 기본 타입 배열을 위해 박싱 오버헤드가 없는 <code>ByteArray</code>, <code>ShortArray</code>, <code>IntArray</code> 등의 클래스를 제공한다.
이 클래스는 <code>Array</code> 클래스와 상속 관계를 갖지 않지만, 동일한 메서드와 프로퍼티를 갖는다. 또한 각 클래스를 위한 팩토리 함수가 존재한다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>x</span><span class='p'>:</span> <span class='n'>IntArray</span> <span class='p'>=</span> <span class='n'>intArrayOf</span><span class='p'>(</span><span class='m'>1</span><span class='p'>,</span> <span class='m'>2</span><span class='p'>,</span> <span class='m'>3</span><span class='p'>)</span>
<span class='n'>x</span><span class='p'>[</span><span class='m'>0</span><span class='p'>]</span> <span class='p'>=</span> <span class='n'>x</span><span class='p'>[</span><span class='m'>1</span><span class='p'>]</span> <span class='p'>+</span> <span class='n'>x</span><span class='p'>[</span><span class='m'>2</span><span class='p'>]</span></code></pre><h3 id='basic-types.html_section-7'>문자열<a class='anchor' href='#%23section-7'> </a></h3><p><code>String</code> 타입으로 문자열을 표현한다. 문자열은 불변(immutable)이다.
문자열의 요소는 문자이며, 각 요소는 인덱스 연산을 이용해서 접근할 수 있다: <code>s[i]</code>
<em class='keyword'>for</em>-루프를 통해 문자열을 이터레이션할 수 있다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>for</span> <span class='p'>(</span><span class='n'>c</span> <span class='k'>in</span> <span class='n'>str</span><span class='p'>)</span> <span class='p'>{</span>
  <span class='n'>println</span><span class='p'>(</span><span class='n'>c</span><span class='p'>)</span>
<span class='p'>}</span></code></pre><h4 id='basic-types.html_section-8'>문자열 리터럴<a class='anchor' href='#%23section-8'> </a></h4><p>코틀린은 두 종류의 문자열 리터럴을 갖는다. 하나는 이스케이프 문자를 가질 수 있는 이스케이프드(escaped) 문자열이고, 다른 하나는 뉴라인과 임의 텍스트를 가질 수 있는 raw 문자열이다.
이스케이프드 문자열은 자바 문자열과 매우 유사하다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>s</span> <span class='p'>=</span> <span class='s'>&quot;Hello, world!\n&quot;</span></code></pre><p>백슬래시를 사용해서 이스케이프 문자를 처리한다. 지원하는 이스케이프 시퀀스 목록은 앞서 <a href='#%23characters'>Characters</a>를 참고한다.</p><p>raw 문자열은 세 따옴표(<code>"""</code>)로 구분한다. 이스케이프는 안 되고, 뉴라인과 모든 다른 문자를 포함할 수 있다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>text</span> <span class='p'>=</span> <span class='s'>&quot;&quot;&quot;</span>
  <span class='k'>for</span> <span class='p'>(</span><span class='n'>c</span> <span class='k'>in</span> <span class='s'>&quot;foo&quot;</span><span class='p'>)</span>
    <span class='n'>print</span><span class='p'>(</span><span class='n'>c</span><span class='p'>)</span>
<span class='s'>&quot;&quot;&quot;</span></code></pre><p><a href='#https%3A%2F%2Fkotlinlang.org%2Fapi%2Flatest%2Fjvm%2Fstdlib%2Fkotlin.text%2Ftrim-margin.html'><code>trimMargin()</code></a> 함수로 앞 공백을 제거할 수 있다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>text</span> <span class='p'>=</span> <span class='s'>&quot;&quot;&quot;</span>
    <span class='p'>|</span><span class='n'>Tell</span> <span class='n'>me</span> <span class='n'>and</span> <span class='n'>I</span> <span class='n'>forget</span><span class='p'>.</span>
    <span class='p'>|</span><span class='n'>Teach</span> <span class='n'>me</span> <span class='n'>and</span> <span class='n'>I</span> <span class='n'>remember</span><span class='p'>.</span>
    <span class='p'>|</span><span class='n'>Involve</span> <span class='n'>me</span> <span class='n'>and</span> <span class='n'>I</span> <span class='n'>learn</span><span class='p'>.</span>
    <span class='p'>|(</span><span class='n'>Benjamin</span> <span class='n'>Franklin</span><span class='p'>)</span>
    <span class='s'>&quot;&quot;&quot;.trimMargin()</span></code></pre><p>기본적으로 <code>|</code> 문자를 가장자리 접두사로 사용하며, <code>trimMargin("&gt;")</code>와 같이 파라미터를 이용해서 접두사를 변경할 수 있다.</p><h4 id='basic-types.html_section-9'>문자열 템플릿<a class='anchor' href='#%23section-9'> </a></h4><p>문자열은 템플릿 표현식을 포함할 수 있다. 예를 들어, 코드의 일부를 평가해서 그 결과를 문자열에 연결할 수 있다.
템플릿 표현식은 달라 기호($)로 시작하고 단순 이름을 포함한다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>i</span> <span class='p'>=</span> <span class='m'>10</span>
<span class='k'>val</span> <span class='py'>s</span> <span class='p'>=</span> <span class='s'>&quot;i = $i&quot;</span> <span class='c1'>// evaluates to &quot;i = 10&quot;</span></code></pre><p>또는 다음과 같이 중괄호 안에 위치한다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>s</span> <span class='p'>=</span> <span class='s'>&quot;abc&quot;</span>
<span class='k'>val</span> <span class='py'>str</span> <span class='p'>=</span> <span class='s'>&quot;$s.length is ${s.length}&quot;</span> <span class='c1'>// &quot;abc.length is 3&quot;로 계산</span></code></pre><p>템플릿은 raw 문자열과 이스케이프드 문자열에서 모두 지원한다.
(역슬래시를 이용한 특수 문자 표기를 지원하지 않는) raw 문자열에서 <code>$</code> 문자를 표현하고 싶다면, 다음 구문을 사용한다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>price</span> <span class='p'>=</span> <span class='s'>&quot;&quot;&quot;</span>
<span class='err'>$</span><span class='p'>{</span><span class='sc'>&#39;$&#39;</span><span class='p'>}</span><span class='m'>9.99</span>
<span class='s'>&quot;&quot;&quot;</span></code></pre>
              </article>
          
              <article id="packages.html" class="page-content">
                <h2 id='packages.html_section'>패키지<a class='anchor' href='#%23section'> </a></h2><p>소스 파일은 패키지 선언으로 시작한다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>package</span> <span class='nn'>foo.bar</span>

<span class='k'>fun</span> <span class='nf'>baz</span><span class='p'>()</span> <span class='p'>{}</span>

<span class='k'>class</span> <span class='nc'>Goo</span> <span class='p'>{}</span>

<span class='c1'>// ...</span></code></pre><p>클래스나 함수와 같은 소스 파일의 모든 내용은 선언한 패키지에 속한다.
위 예의 경우 <code>baz()</code>의 전체 이름은 <code>foo.bar.baz</code>이고 <code>Goo</code>의 전체 이름은 <code>foo.bar.Goo</code>이다.</p><p>패키지를 지정하지 않으면, 파일의 모든 내용은 이름이 없는 “기본(default)” 패키지에 속한다.</p><h3 id='packages.html_section-1'>임포트<a class='anchor' href='#%23section-1'> </a></h3><p>기본 임포트 외에 각 파일은 자신의 import 디렉티브를 포함할 수 있다.
임포트 구문은 <a href='#grammar.html%23import'>grammar</a>에서 설명한다.</p><p>다음은 한 개 이름을 임포트하는 예이다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>import</span> <span class='nn'>foo.Bar</span> <span class='c1'>// Bar에 전체 이름을 사용하지 않고 접근할 수 있다.</span></code></pre><p>해당 범위의 모든 요소(패키지, 클래스, 오브젝트 등)에 접근할 수도 있다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>import</span> <span class='nn'>foo.*</span> <span class='c1'>// &#39;foo&#39;의 모든 요소에 접근 가능</span></code></pre><p>이름이 충돌하면, <em class='keyword'>as</em> 키워드로 로컬에서 사용할 이름을 변경해서 충돌을 피할 수 있다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>import</span> <span class='nn'>foo.Bar</span> <span class='c1'>// Bar로 접근</span>
<span class='k'>import</span> <span class='nn'>bar.Bar</span> <span class='k'>as</span> <span class='n'>bBar</span> <span class='c1'>// bBar는 &#39;bar.Bar&#39;를 의미</span></code></pre><p><code>import</code> 키워드는 클래스뿐만 아니라 다른 것도 임포트할 수 있다:</p><ul>
  <li>최상위 레벨 함수와 프로퍼티;</li>
  <li><a href='#object-declarations.html%23object-declarations'>오브젝트 선언</a>에 선언한 함수와 프로퍼티;</li>
  <li><a href='#enum-classes.html'>열거형 상수</a></li>
</ul><p>자바와 달리, 코틀린은 별도의 “import static” 구문을 지원하지 않는다. 모든 선언을 <code>import</code> 키워드를 사용해서 임포트할 수 있다.</p><h3 id='packages.html_section-2'>최상위 선언의 가시성<a class='anchor' href='#%23section-2'> </a></h3><p>최상위 선언이 <em class='keyword'>private</em>이면, 그것이 선언된 파일에 대해 private이다(<a href='#visibility-modifiers.html'>가시성 제한자</a> 참고)</p>
              </article>
          
              <article id="control-flow.html" class="page-content">
                <h2 id='control-flow.html_section'>흐름 제어<a class='anchor' href='#%23section'> </a></h2><h3 id='control-flow.html_if-'>If 식<a class='anchor' href='#%23if-'> </a></h3><p>코틀린에서 <em class='keyword'>if</em>는 식이며 값을 리턴한다.
삼항 연산자(condition ? then : else)는 없는데, 이유는 <em class='keyword'>if</em>로 충분히 할 수 있기 때문이다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='c1'>// 구식 용법</span>
<span class='k'>var</span> <span class='py'>max</span> <span class='p'>=</span> <span class='n'>a</span>
<span class='k'>if</span> <span class='p'>(</span><span class='n'>a</span> <span class='p'>&lt;</span> <span class='n'>b</span><span class='p'>)</span>
  <span class='n'>max</span> <span class='p'>=</span> <span class='n'>b</span>

<span class='c1'>// else와 함께 사용</span>
<span class='k'>var</span> <span class='py'>max</span><span class='p'>:</span> <span class='n'>Int</span>
<span class='k'>if</span> <span class='p'>(</span><span class='n'>a</span> <span class='p'>&gt;</span> <span class='n'>b</span><span class='p'>)</span>
  <span class='n'>max</span> <span class='p'>=</span> <span class='n'>a</span>
<span class='k'>else</span>
  <span class='n'>max</span> <span class='p'>=</span> <span class='n'>b</span>

<span class='c1'>// 식으로 사용</span>
<span class='k'>val</span> <span class='py'>max</span> <span class='p'>=</span> <span class='k'>if</span> <span class='p'>(</span><span class='n'>a</span> <span class='p'>&gt;</span> <span class='n'>b</span><span class='p'>)</span> <span class='n'>a</span> <span class='k'>else</span> <span class='n'>b</span></code></pre><p><em class='keyword'>if</em> 브랜치는 블록이 될 수 있고, 마지막 식이 블록의 값이 된다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>max</span> <span class='p'>=</span> <span class='k'>if</span> <span class='p'>(</span><span class='n'>a</span> <span class='p'>&gt;</span> <span class='n'>b</span><span class='p'>)</span> <span class='p'>{</span>
    <span class='n'>print</span><span class='p'>(</span><span class='s'>&quot;Choose a&quot;</span><span class='p'>)</span>
    <span class='n'>a</span>
  <span class='p'>}</span>
  <span class='k'>else</span> <span class='p'>{</span>
    <span class='n'>print</span><span class='p'>(</span><span class='s'>&quot;Choose b&quot;</span><span class='p'>)</span>
    <span class='n'>b</span>
  <span class='p'>}</span></code></pre><p><em class='keyword'>if</em>를 문장이 아닌 식으로 사용할 경우, <code>else</code> 브랜치를 가지려면 식이 필요하다.</p><p><a href='#grammar.html%23if'><em class='keyword'>if</em> 문법</a> 참고.</p><h3 id='control-flow.html_when-'>When 식<a class='anchor' href='#%23when-'> </a></h3><p><em class='keyword'>when</em>은 C와 유사한 언어의 switch 연산자를 대체한다. 가장 단순한 형태는 다음과 같다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>when</span> <span class='p'>(</span><span class='n'>x</span><span class='p'>)</span> <span class='p'>{</span>
  <span class='m'>1</span> <span class='p'>-&gt;</span> <span class='n'>print</span><span class='p'>(</span><span class='s'>&quot;x == 1&quot;</span><span class='p'>)</span>
  <span class='m'>2</span> <span class='p'>-&gt;</span> <span class='n'>print</span><span class='p'>(</span><span class='s'>&quot;x == 2&quot;</span><span class='p'>)</span>
  <span class='k'>else</span> <span class='p'>-&gt;</span> <span class='p'>{</span> <span class='c1'>// 블록 가능</span>
    <span class='n'>print</span><span class='p'>(</span><span class='s'>&quot;x is neither 1 nor 2&quot;</span><span class='p'>)</span>
  <span class='p'>}</span>
<span class='p'>}</span></code></pre><p><em class='keyword'>when</em>은 충족하는 브랜치 조건이 나올때까지 모든 브랜치를 순차적으로 찾는다.
<em class='keyword'>when</em>은 식이나 문장으로 사용할 수 있다. 만약 식으로 사용하면, 충족한 브랜치의 값이 전체 식의 값이 된다.
문장으로 사용하면, 개별 브랜치의 값은 무시한다. (<em class='keyword'>if</em>처럼 각 브랜치는 블록일 수 있으며, 블록의 마지막 식이 값이 된다.)
<em class='keyword'>else</em> 브랜치는 모든 브랜치 조건이 맞지 않을 때 사용한다.
<em class='keyword'>when</em>을 식으로 사용할 경우, 각 브랜치 조건이 모든 경우의 수를 다뤘다고 컴파일러에서 판명할 수 없으면,
<em class='keyword'>else</em>를 필수로 사용해야 한다.</p><p>여러 경우를 동일하게 처리해야 할 경우, 브랜치 조건을 콤마로 묶을 수 있다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>when</span> <span class='p'>(</span><span class='n'>x</span><span class='p'>)</span> <span class='p'>{</span>
  <span class='m'>0</span><span class='p'>,</span> <span class='m'>1</span> <span class='p'>-&gt;</span> <span class='n'>print</span><span class='p'>(</span><span class='s'>&quot;x == 0 or x == 1&quot;</span><span class='p'>)</span>
  <span class='k'>else</span> <span class='p'>-&gt;</span> <span class='n'>print</span><span class='p'>(</span><span class='s'>&quot;otherwise&quot;</span><span class='p'>)</span>
<span class='p'>}</span></code></pre><p>브랜치 조건으로 (상수뿐만 아니라) 임의 식을 사용할 수 있다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>when</span> <span class='p'>(</span><span class='n'>x</span><span class='p'>)</span> <span class='p'>{</span>
  <span class='n'>parseInt</span><span class='p'>(</span><span class='n'>s</span><span class='p'>)</span> <span class='p'>-&gt;</span> <span class='n'>print</span><span class='p'>(</span><span class='s'>&quot;s encodes x&quot;</span><span class='p'>)</span>
  <span class='k'>else</span> <span class='p'>-&gt;</span> <span class='n'>print</span><span class='p'>(</span><span class='s'>&quot;s does not encode x&quot;</span><span class='p'>)</span>
<span class='p'>}</span></code></pre><p><a href='#ranges.html'>range</a>나 콜렉션에 대해 <em class='keyword'>in</em>이나 <em class='keyword'>!in</em>을 사용해서 값을 검사할 수 있다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>when</span> <span class='p'>(</span><span class='n'>x</span><span class='p'>)</span> <span class='p'>{</span>
  <span class='k'>in</span> <span class='m'>1.</span><span class='p'>.</span><span class='m'>10</span> <span class='p'>-&gt;</span> <span class='n'>print</span><span class='p'>(</span><span class='s'>&quot;x is in the range&quot;</span><span class='p'>)</span>
  <span class='k'>in</span> <span class='n'>validNumbers</span> <span class='p'>-&gt;</span> <span class='n'>print</span><span class='p'>(</span><span class='s'>&quot;x is valid&quot;</span><span class='p'>)</span>
  <span class='p'>!</span><span class='k'>in</span> <span class='m'>10.</span><span class='p'>.</span><span class='m'>20</span> <span class='p'>-&gt;</span> <span class='n'>print</span><span class='p'>(</span><span class='s'>&quot;x is outside the range&quot;</span><span class='p'>)</span>
  <span class='k'>else</span> <span class='p'>-&gt;</span> <span class='n'>print</span><span class='p'>(</span><span class='s'>&quot;none of the above&quot;</span><span class='p'>)</span>
<span class='p'>}</span></code></pre><p><em class='keyword'>is</em>나 <em class='keyword'>!is</em>로 특정 타입의 값인지 검사할 수 있다. <a href='#typecasts.html%23smart-casts'>스마트 변환</a> 덕에
추가 검사 없이 타입의 프로퍼티와 메서드에 접근할 수 있다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>hasPrefix</span> <span class='p'>=</span> <span class='k'>when</span><span class='p'>(</span><span class='n'>x</span><span class='p'>)</span> <span class='p'>{</span>
  <span class='k'>is</span> <span class='n'>String</span> <span class='p'>-&gt;</span> <span class='n'>x</span><span class='p'>.</span><span class='n'>startsWith</span><span class='p'>(</span><span class='s'>&quot;prefix&quot;</span><span class='p'>)</span>
  <span class='k'>else</span> <span class='p'>-&gt;</span> <span class='k'>false</span>
<span class='p'>}</span></code></pre><p><em class='keyword'>if</em>-<em class='keyword'>else</em> <em class='keyword'>if</em> 체인 대신 <em class='keyword'>when</em>을 사용할 수 있다.
인자를 제공하지 않으면, 브랜치 조건은 단순 부울 식이며, 각 조건이 true일 때 브랜치를 실행한다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>when</span> <span class='p'>{</span>
  <span class='n'>x</span><span class='p'>.</span><span class='n'>isOdd</span><span class='p'>()</span> <span class='p'>-&gt;</span> <span class='n'>print</span><span class='p'>(</span><span class='s'>&quot;x is odd&quot;</span><span class='p'>)</span>
  <span class='n'>x</span><span class='p'>.</span><span class='n'>isEven</span><span class='p'>()</span> <span class='p'>-&gt;</span> <span class='n'>print</span><span class='p'>(</span><span class='s'>&quot;x is even&quot;</span><span class='p'>)</span>
  <span class='k'>else</span> <span class='p'>-&gt;</span> <span class='n'>print</span><span class='p'>(</span><span class='s'>&quot;x is funny&quot;</span><span class='p'>)</span>
<span class='p'>}</span></code></pre><p><a href='#grammar.html%23when'><em class='keyword'>when</em> 문법</a> 참고.</p><h3 id='control-flow.html_for-'>For 루트<a class='anchor' href='#%23for-'> </a></h3><p><em class='keyword'>for</em> 루트는 이터레이터를 제공하는 모든 것에 대해 반복을 수행한다. 구문은 다음과 같다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>for</span> <span class='p'>(</span><span class='n'>item</span> <span class='k'>in</span> <span class='n'>collection</span><span class='p'>)</span>
  <span class='n'>print</span><span class='p'>(</span><span class='n'>item</span><span class='p'>)</span></code></pre><p>몸체는 블록일 수 있다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>for</span> <span class='p'>(</span><span class='n'>item</span><span class='p'>:</span> <span class='n'>Int</span> <span class='k'>in</span> <span class='n'>ints</span><span class='p'>)</span> <span class='p'>{</span>
  <span class='c1'>// ...</span>
<span class='p'>}</span></code></pre><p>앞서 언급한 것처럼, <em class='keyword'>for</em>는 다음에 맞는 이터레이터(iterator)를 제공하는 모든 것을 반복한다.</p><ul>
  <li><code>iterator()</code> 멤버 함수나 확장 함수를 갖고, 이 함수의 리턴 타입이
    <ul>
      <li><code>next()</code> 멤버 함수나 확장 함수를 갖고,</li>
      <li><code>Boolean</code>을 리턴하는 <code>hasNext()</code> 함수나 확장 함수를 갖는다.</li>
    </ul>
  </li>
</ul><p>이 세 함수는 <code>operator</code>로 표시해야 한다.</p><p>배열에 대한 <code>for</code> 루프는 이터레이터 객체를 생성하지 않는 인덱스 기반 루프로 컴파일된다.</p><p>인덱스를 이용해서 배열이나 리스트를 반복하고 싶다면, 다음 방법을 사용하면 된다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>for</span> <span class='p'>(</span><span class='n'>i</span> <span class='k'>in</span> <span class='n'>array</span><span class='p'>.</span><span class='n'>indices</span><span class='p'>)</span>
  <span class='n'>print</span><span class='p'>(</span><span class='n'>array</span><span class='p'>[</span><span class='n'>i</span><span class='p'>])</span></code></pre><p>이 “범위를 통한 반복”는 추가 객체 생성 없는 최적화된 코드로 컴파일된다.</p><p>대신, <code>withIndex</code> 라이브러리 함수로 처리할 수도 있다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>for</span> <span class='p'>((</span><span class='n'>index</span><span class='p'>,</span> <span class='n'>value</span><span class='p'>)</span> <span class='k'>in</span> <span class='n'>array</span><span class='p'>.</span><span class='n'>withIndex</span><span class='p'>())</span> <span class='p'>{</span>
    <span class='n'>println</span><span class='p'>(</span><span class='s'>&quot;the element at $index is $value&quot;</span><span class='p'>)</span>
<span class='p'>}</span></code></pre><p><a href='#grammar.html%23for'><em class='keyword'>for</em> 문법</a> 참고.</p><h3 id='control-flow.html_while-'>While 루프<a class='anchor' href='#%23while-'> </a></h3><p><em class='keyword'>while</em>과 <em class='keyword'>do</em>..<em class='keyword'>while</em>은 예상하는대로 동작한다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>while</span> <span class='p'>(</span><span class='n'>x</span> <span class='p'>&gt;</span> <span class='m'>0</span><span class='p'>)</span> <span class='p'>{</span>
  <span class='n'>x</span><span class='p'>--</span>
<span class='p'>}</span>

<span class='k'>do</span> <span class='p'>{</span>
  <span class='k'>val</span> <span class='py'>y</span> <span class='p'>=</span> <span class='n'>retrieveData</span><span class='p'>()</span>
<span class='p'>}</span> <span class='k'>while</span> <span class='p'>(</span><span class='n'>y</span> <span class='p'>!=</span> <span class='k'>null</span><span class='p'>)</span> <span class='c1'>// 여기서 y에 접근 가능!</span></code></pre><p><a href='#grammar.html%23while'><em class='keyword'>while</em> 문법</a> 참고.</p><h3 id='control-flow.html_break-continue'>루프에서 break와 continue<a class='anchor' href='#%23break-continue'> </a></h3><p>코틀린은 루프에서 전통적인 <em class='keyword'>break</em>와 <em class='keyword'>continue</em>를 지원한다. <a href='#returns.html'>리턴과 점프</a>를 참고한다.</p>
              </article>
          
              <article id="returns.html" class="page-content">
                <h2 id='returns.html_section'>리턴과 점프<a class='anchor' href='#%23section'> </a></h2><p>코틀린은 세 가지 구조적인(structural) 점프 연산자를 제공한다.</p><ul>
  <li><em class='keyword'>return</em>. 기본적으로 가장 가깝게 둘러 싼 함수나 <a href='#lambdas.html%23anonymous-functions'>임의 함수</a>에서 리턴한다.</li>
  <li><em class='keyword'>break</em>. 가장 가깝게 둘러 싼 루프를 끝낸다.</li>
  <li><em class='keyword'>continue</em>. 가장 가깝게 둘러 싼 루프의 다음으로 넘어간다.</li>
</ul><h3 id='returns.html_break-continue-'>Break와 Continue 라벨<a class='anchor' href='#%23break-continue-'> </a></h3><p>코틀린의 모든 식은 <em class='keyword'>라벨</em>로 표식을 가질 수 있다.
라벨은 <code>@</code> 기호 뒤에 구분자를 갖는다. 예를 들어 <code>abc@</code>, <code>fooBar@</code>는 유효한 라벨이다(<a href='#grammar.html%23label'>문법</a> 참고).
식에 라벨을 붙이려면, 식 앞에 라벨을 위치시키면 된다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>loop</span><span class='err'>@</span> <span class='k'>for</span> <span class='p'>(</span><span class='n'>i</span> <span class='k'>in</span> <span class='m'>1.</span><span class='p'>.</span><span class='m'>100</span><span class='p'>)</span> <span class='p'>{</span>
  <span class='c1'>// ...</span>
<span class='p'>}</span></code></pre><p>이제, <em class='keyword'>break</em>나 <em class='keyword'>continue</em>를 라벨로 한정할 수 있다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>loop</span><span class='err'>@</span> <span class='k'>for</span> <span class='p'>(</span><span class='n'>i</span> <span class='k'>in</span> <span class='m'>1.</span><span class='p'>.</span><span class='m'>100</span><span class='p'>)</span> <span class='p'>{</span>
  <span class='k'>for</span> <span class='p'>(</span><span class='n'>j</span> <span class='k'>in</span> <span class='m'>1.</span><span class='p'>.</span><span class='m'>100</span><span class='p'>)</span> <span class='p'>{</span>
    <span class='k'>if</span> <span class='p'>(...)</span>
      <span class='k'>break</span><span class='n'>@loop</span>
  <span class='p'>}</span>
<span class='p'>}</span></code></pre><p>라벨로 한정한 <em class='keyword'>break</em>는 그 라벨이 붙은 루프 이후로 실행 지점을 이동한다.
<em class='keyword'>continue</em>는 루프의 다음 반복을 처리한다.</p><h3 id='returns.html_section-1'>라벨에 리턴하기<a class='anchor' href='#%23section-1'> </a></h3><p>코틀린은 함수 리터럴, 로컬 함수와 객체 식에서 함수를 중첩할 수 있다.
한정한 <em class='keyword'>return</em>은 바깥(outer) 함수에서 리턴할 수 있도록 한다.
가장 중요한 쓰임새는 람다 식에서 리턴하는 것이다. 다음 코드를 보자:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>foo</span><span class='p'>()</span> <span class='p'>{</span>
  <span class='n'>ints</span><span class='p'>.</span><span class='n'>forEach</span> <span class='p'>{</span>
    <span class='k'>if</span> <span class='p'>(</span><span class='n'>it</span> <span class='p'>==</span> <span class='m'>0</span><span class='p'>)</span> <span class='k'>return</span>
    <span class='n'>print</span><span class='p'>(</span><span class='n'>it</span><span class='p'>)</span>
  <span class='p'>}</span>
<span class='p'>}</span></code></pre><p><em class='keyword'>return</em> 식은 가장 가깝게 둘러싼 함수인 <code>foo</code>에서 리턴한다.
(비-로컬(non-local) 리턴은 <a href='#inline-functions.html'>인라인 함수</a>)로 전달한 람다 식만 지원한다.)
만약 람다 식에서 리턴하고 싶다면 라벨을 붙여서 <em class='keyword'>return</em>을 한정해야 한다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>foo</span><span class='p'>()</span> <span class='p'>{</span>
  <span class='n'>ints</span><span class='p'>.</span><span class='n'>forEach</span> <span class='n'>lit</span><span class='err'>@</span> <span class='p'>{</span>
    <span class='k'>if</span> <span class='p'>(</span><span class='n'>it</span> <span class='p'>==</span> <span class='m'>0</span><span class='p'>)</span> <span class='k'>return</span><span class='n'>@lit</span>
    <span class='n'>print</span><span class='p'>(</span><span class='n'>it</span><span class='p'>)</span>
  <span class='p'>}</span>
<span class='p'>}</span></code></pre><p>이제, 이 return은 람다식에서 리턴한다. 종종, 임의 라벨을 사용하는게 더 편리하다:
임의 라벨은 람다를 전달받은 함수와 같은 이름을 갖는다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>foo</span><span class='p'>()</span> <span class='p'>{</span>
  <span class='n'>ints</span><span class='p'>.</span><span class='n'>forEach</span> <span class='p'>{</span>
    <span class='k'>if</span> <span class='p'>(</span><span class='n'>it</span> <span class='p'>==</span> <span class='m'>0</span><span class='p'>)</span> <span class='k'>return</span><span class='n'>@forEach</span>
    <span class='n'>print</span><span class='p'>(</span><span class='n'>it</span><span class='p'>)</span>
  <span class='p'>}</span>
<span class='p'>}</span></code></pre><p>다른 방법으로, 람다 식 대신 <a href='#lambdas.html%23anonymous-functions'>임의 함수</a>를 사용할 수 있다.
임의 함수에서 <em class='keyword'>return</em> 문은 임의 함수 자체에서 리턴한다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>foo</span><span class='p'>()</span> <span class='p'>{</span>
  <span class='n'>ints</span><span class='p'>.</span><span class='n'>forEach</span><span class='p'>(</span><span class='k'>fun</span><span class='p'>(</span><span class='n'>value</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>)</span> <span class='p'>{</span>
    <span class='k'>if</span> <span class='p'>(</span><span class='n'>value</span> <span class='p'>==</span> <span class='m'>0</span><span class='p'>)</span> <span class='k'>return</span>
    <span class='n'>print</span><span class='p'>(</span><span class='n'>value</span><span class='p'>)</span>
  <span class='p'>})</span>
<span class='p'>}</span></code></pre><p>값을 리턴할 때, 파서는 한정한 리턴에 우선순위를 준다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>return</span><span class='n'>@a</span> <span class='m'>1</span></code></pre><p>이는 “라벨 식 <code>(@a 1)</code>을 리턴한다”가 아닌 “라벨 <code>@a</code>에 <code>1</code>을 리턴한다”를 의미한다.</p>
              </article>
          

        </section>
    

    
        <section>
          <h1 id="%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80_%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8"
              class="section-title">
            클래스와 오브젝트
          </h1>

          
              <article id="classes.html" class="page-content">
                <h2 id='classes.html_section'>클래스와 상속<a class='anchor' href='#%23section'> </a></h2><h3 id='classes.html_section-1'>클래스<a class='anchor' href='#%23section-1'> </a></h3><p>코틀린은 <em class='keyword'>class</em> 키워드를 사용해서 클래스를 선언한다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>class</span> <span class='nc'>Invoice</span> <span class='p'>{</span>
<span class='p'>}</span></code></pre><p>클래스 선언은 클래스 이름, 클래스 헤더(타입 파라미터 지정, 주요 생성자 등)와 중괄호로 둘러 싼 클래스 몸체로 구성된다.
헤더와 몸체는 필수가 아니다. 클래스가 몸체를 갖지 않으면 중괄호를 생략할 수 있다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>class</span> <span class='nc'>Empty</span></code></pre><h4 id='classes.html_section-2'>생성자<a class='anchor' href='#%23section-2'> </a></h4><p>코틀린 클래스는 한 개의 <strong>주요 생성자</strong>와 한 개 이상의 <strong>보조secondary 생성자</strong>를 가질 수 있다.
주요 생성자는 클래스 헤더에 속한다. 클래스 헤더는 클래스 이름 뒤에(타입 파라미터가 있다면 그 뒤에) 위치한다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>class</span> <span class='nc'>Person</span> <span class='n'>constructor</span><span class='p'>(</span><span class='n'>firstName</span><span class='p'>:</span> <span class='n'>String</span><span class='p'>)</span> <span class='p'>{</span>
<span class='p'>}</span></code></pre><p>주요 생성자가 애노테이션이나 가시성 제한자를 갖지 않으면 <em class='keyword'>constructor</em> 키워드를 생략할 수 있다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>class</span> <span class='nc'>Person</span><span class='p'>(</span><span class='n'>firstName</span><span class='p'>:</span> <span class='n'>String</span><span class='p'>)</span> <span class='p'>{</span>
<span class='p'>}</span></code></pre><p>주요 생성자는 어떤 코드도 포함할 수 없다. 초기화 코드는 <em class='keyword'>init</em> 키워드를 이용한
<strong>initializer 블록</strong>에 위치할 수 있다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>class</span> <span class='nc'>Customer</span><span class='p'>(</span><span class='n'>name</span><span class='p'>:</span> <span class='n'>String</span><span class='p'>)</span> <span class='p'>{</span>
    <span class='n'>init</span> <span class='p'>{</span>
        <span class='n'>logger</span><span class='p'>.</span><span class='n'>info</span><span class='p'>(</span><span class='s'>&quot;Customer initialized with value ${name}&quot;</span><span class='p'>)</span>
    <span class='p'>}</span>
<span class='p'>}</span></code></pre><p>주요 생성자의 파라미터는 initializer 초기화 블록과 클래스 몸체에 선언한 프로퍼티 initializer에서 사용할 수 있다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>class</span> <span class='nc'>Customer</span><span class='p'>(</span><span class='n'>name</span><span class='p'>:</span> <span class='n'>String</span><span class='p'>)</span> <span class='p'>{</span>
    <span class='k'>val</span> <span class='py'>customerKey</span> <span class='p'>=</span> <span class='n'>name</span><span class='p'>.</span><span class='n'>toUpperCase</span><span class='p'>()</span>
<span class='p'>}</span></code></pre><p>코틀린은 주요 생성자에서 프로퍼티를 선언하고 초기화할 수 있도록 간결한 구문을 제공한다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>class</span> <span class='nc'>Person</span><span class='p'>(</span><span class='k'>val</span> <span class='py'>firstName</span><span class='p'>:</span> <span class='n'>String</span><span class='p'>,</span> <span class='k'>val</span> <span class='py'>lastName</span><span class='p'>:</span> <span class='n'>String</span><span class='p'>,</span> <span class='k'>var</span> <span class='py'>age</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>)</span> <span class='p'>{</span>
  <span class='c1'>// ...</span>
<span class='p'>}</span></code></pre><p>일반 프로퍼티와 동일하게 주요 생성자에 선언한 프로퍼티도 변경 가능(<em class='keyword'>var</em>)하거나
읽기 전용(<em class='keyword'>val</em>)이 될 수 있다.</p><p>생성자가 애노테이션이나 가시성 제한자를 가질 경우 <em class='keyword'>constructor</em> 키워드가 필요하며,
키워드 전에 제한자가 위치하게 된다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>class</span> <span class='nc'>Customer</span> <span class='k'>public</span> <span class='n'>@Inject</span> <span class='n'>constructor</span><span class='p'>(</span><span class='n'>name</span><span class='p'>:</span> <span class='n'>String</span><span class='p'>)</span> <span class='p'>{</span> <span class='p'>...</span> <span class='p'>}</span></code></pre><p>자세한 내용은 <a href='#visibility-modifiers.html%23constructors'>가시성 제한자</a>를 참고한다.</p><h5 id='classes.html_secondary-constructors'>보조 생성자(Secondary Constructors)</h5><p>클래스는 <em class='keyword'>constructor</em>를 이용해서 <strong>보조 생성자</strong>를 선언할 수 있다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>class</span> <span class='nc'>Person</span> <span class='p'>{</span>
    <span class='n'>constructor</span><span class='p'>(</span><span class='n'>parent</span><span class='p'>:</span> <span class='n'>Person</span><span class='p'>)</span> <span class='p'>{</span>
        <span class='n'>parent</span><span class='p'>.</span><span class='n'>children</span><span class='p'>.</span><span class='n'>add</span><span class='p'>(</span><span class='k'>this</span><span class='p'>)</span>
    <span class='p'>}</span>
<span class='p'>}</span></code></pre><p>클래스가 주요 생성자를 가지면, 각 보조 생성자는 직접 주요 생성자에 위임하거나 다른 보조 생성자를 통해 간접적으로 주요 생성자에
위임해야 한다. <em class='keyword'>this</em> 키워드를 이용해서 같은 클래스의 다른 생성자에 위임할 수 있다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>class</span> <span class='nc'>Person</span><span class='p'>(</span><span class='k'>val</span> <span class='py'>name</span><span class='p'>:</span> <span class='n'>String</span><span class='p'>)</span> <span class='p'>{</span>
    <span class='n'>constructor</span><span class='p'>(</span><span class='n'>name</span><span class='p'>:</span> <span class='n'>String</span><span class='p'>,</span> <span class='n'>parent</span><span class='p'>:</span> <span class='n'>Person</span><span class='p'>)</span> <span class='p'>:</span> <span class='k'>this</span><span class='p'>(</span><span class='n'>name</span><span class='p'>)</span> <span class='p'>{</span>
        <span class='n'>parent</span><span class='p'>.</span><span class='n'>children</span><span class='p'>.</span><span class='n'>add</span><span class='p'>(</span><span class='k'>this</span><span class='p'>)</span>
    <span class='p'>}</span>
<span class='p'>}</span></code></pre><p>추상이 아닌 클래스가 어떤 생성자도 선언하지 않으면, 인자를 갖지 않은 주요 생성자를 만든다.
클래스가 공개(public) 생성자를 갖는 것을 원치 않으면, 기본 가시성이 아닌 다른 가시성을 갖는 빈(empty) 주요 생성자를 추가해야 한다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>class</span> <span class='nc'>DontCreateMe</span> <span class='k'>private</span> <span class='n'>constructor</span> <span class='p'>()</span> <span class='p'>{</span>
<span class='p'>}</span></code></pre><blockquote class='info'>
  <p><strong>주의</strong>: JVM에서, 주요 생성자의 모든 파라미터가 기본 값을 가지면 컴파일러는 기본 값을 사용하는 파라미터 없는 생성자를 추가로 만든다.
이는 Jackson이나 JPA처럼 파라미터없는 생성자를 이용해서 클래스 인스턴스를 생성하는 라이브러리에 대해 코틀린을 사용하기 쉽게 만들어준다.</p>

  <pre><code class='code-block _highlighted lang_kotlin'><span class='k'>class</span> <span class='nc'>Customer</span><span class='p'>(</span><span class='k'>val</span> <span class='py'>customerName</span><span class='p'>:</span> <span class='n'>String</span> <span class='p'>=</span> <span class='s'>&quot;&quot;</span><span class='p'>)</span></code></pre>
</blockquote><h4 id='classes.html_section-3'>클래스의 인스턴스 생성하기<a class='anchor' href='#%23section-3'> </a></h4><p>클래스의 인스턴스를 생성하려면, 일반 함수와 비슷하게 생성자를 호출한다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>invoice</span> <span class='p'>=</span> <span class='n'>Invoice</span><span class='p'>()</span>

<span class='k'>val</span> <span class='py'>customer</span> <span class='p'>=</span> <span class='n'>Customer</span><span class='p'>(</span><span class='s'>&quot;Joe Smith&quot;</span><span class='p'>)</span></code></pre><p>코틀린은 <em class='keyword'>new</em>가 없음에 유의한다.</p><h4 id='classes.html_section-4'>클래스 멤버<a class='anchor' href='#%23section-4'> </a></h4><p>클래스는 다음을 갖는다.</p><ul>
  <li>생성자와 initializer 블록</li>
  <li><a href='#functions.html'>함수</a></li>
  <li><a href='#properties.html'>프로퍼티</a></li>
  <li><a href='#nested-classes.html'>중첩 클래스와 내부 클래스</a></li>
  <li><a href='#object-declarations.html'>오브젝트 선언</a></li>
</ul><h3 id='classes.html_section-5'>상속<a class='anchor' href='#%23section-5'> </a></h3><p>코틀린의 모든 클래스는 공통의 상위클래스(superclass)인 <code>Any</code>를 갖는다. <code>Any</code>는 상위타입(supertype)을 지정하지 않은 클래스의 기본 상위타입이다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>class</span> <span class='nc'>Example</span> <span class='c1'>// 기본으로 Any를 상속한다</span></code></pre><p><code>Any</code>는 <code>java.lang.Object</code>가 아니다; 특히, <code>equals()</code>, <code>hashCode()</code> 그리고 <code>toString()</code>외에 다른 멤버를 갖지 않는다.
보다 자세한 내용은 <a href='#java-interop.html%23object-methods'>자바 상호운용</a> 절을 참고한다.</p><p>상위타입을 직접 선언하려면 클래스 헤더에 콜론 뒤에 타입을 위치시킨다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>open</span> <span class='k'>class</span> <span class='nc'>Base</span><span class='p'>(</span><span class='n'>p</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>)</span>

<span class='k'>class</span> <span class='nc'>Derived</span><span class='p'>(</span><span class='n'>p</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>)</span> <span class='p'>:</span> <span class='n'>Base</span><span class='p'>(</span><span class='n'>p</span><span class='p'>)</span></code></pre><p>클래스가 주요 생성자를 가지면 주요 생성자의 파라미터를 이용해서 베이스 타입을 바로 초기화할 수 있다(그리고 반드시 초기화해야 한다).</p><p>클래스가 주요 생성자를 갖지 않으면 각 보조 생성자는 <em class='keyword'>super</em> 키워드를 사용해서 베이스 타입을 초기화하거나
그것을 하는 다른 생성자에 위임해야 한다.
이 경우 다른 보조 생성자는 베이스 타입의 다른 생성자를 호출할 수 있다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>class</span> <span class='nc'>MyView</span> <span class='p'>:</span> <span class='n'>View</span> <span class='p'>{</span>
    <span class='n'>constructor</span><span class='p'>(</span><span class='n'>ctx</span><span class='p'>:</span> <span class='n'>Context</span><span class='p'>)</span> <span class='p'>:</span> <span class='k'>super</span><span class='p'>(</span><span class='n'>ctx</span><span class='p'>)</span> <span class='p'>{</span>
    <span class='p'>}</span>

    <span class='n'>constructor</span><span class='p'>(</span><span class='n'>ctx</span><span class='p'>:</span> <span class='n'>Context</span><span class='p'>,</span> <span class='n'>attrs</span><span class='p'>:</span> <span class='n'>AttributeSet</span><span class='p'>)</span> <span class='p'>:</span> <span class='k'>super</span><span class='p'>(</span><span class='n'>ctx</span><span class='p'>,</span> <span class='n'>attrs</span><span class='p'>)</span> <span class='p'>{</span>
    <span class='p'>}</span>
<span class='p'>}</span></code></pre><p>클래스의 <em class='keyword'>open</em> 애노테이션은 자바의 <em class='keyword'>final</em>과 정반대이다. <em class='keyword'>open</em>은 다른 클래스가
이 클래스를 상속할 수 있도록 한다. 기본적으로 코틀린에서 모든 클래스는 final이다. 이는
<a href='#http%3A%2F%2Fwww.oracle.com%2Ftechnetwork%2Fjava%2Feffectivejava-136174.html'>Effective Java</a>의
Item 17: <em>Design and document for inheritance or else prohibit it</em> 내용을 따른 것이다.</p><h4 id='classes.html_section-6'>멤버 오버라이딩<a class='anchor' href='#%23section-6'> </a></h4><p>앞서 언급한 것처럼 코틀린에서는 뭐든 명시적으로 만드는 것을 고수한다. 자바와 달리 코틀린은 오버라이딩 가능한 멤버(<em>열렸open</em>다고 함)와
오버라이드를 위해 명시적으로 애노테이션을 붙여야 한다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>open</span> <span class='k'>class</span> <span class='nc'>Base</span> <span class='p'>{</span>
  <span class='k'>open</span> <span class='k'>fun</span> <span class='nf'>v</span><span class='p'>()</span> <span class='p'>{}</span>
  <span class='k'>fun</span> <span class='nf'>nv</span><span class='p'>()</span> <span class='p'>{}</span>
<span class='p'>}</span>
<span class='k'>class</span> <span class='nc'>Derived</span><span class='p'>()</span> <span class='p'>:</span> <span class='n'>Base</span><span class='p'>()</span> <span class='p'>{</span>
  <span class='k'>override</span> <span class='k'>fun</span> <span class='nf'>v</span><span class='p'>()</span> <span class='p'>{}</span>
<span class='p'>}</span></code></pre><p><code>Derived.v()</code>는 <em class='keyword'>override</em> 애노테이션이 필요하다. 붙이지 않으면 컴파일 에러가 발생한다.
<code>Base.nv()</code>와 같이 함수에 <em class='keyword'>open</em>을 붙이지 않으면 <em class='keyword'>override</em> 여부에 상관없이 하위클래스에서 동일 시그너처럴 갖는 메서드를 선언할 수 없다.
(<em class='keyword'>open</em> 애노테이션이 없는) final 클래스에는 open 멤버가 금지된다.</p><p><em class='keyword'>override</em>를 갖는 멤버는 그 자체로 open이며 하위클래스에서 오버라이딩할 수 있다. 오버라이딩을 막고 싶다면 <em class='keyword'>final</em>을 사용하면 된다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>open</span> <span class='k'>class</span> <span class='nc'>AnotherDerived</span><span class='p'>()</span> <span class='p'>:</span> <span class='n'>Base</span><span class='p'>()</span> <span class='p'>{</span>
  <span class='k'>final</span> <span class='k'>override</span> <span class='k'>fun</span> <span class='nf'>v</span><span class='p'>()</span> <span class='p'>{}</span>
<span class='p'>}</span></code></pre><h5 id='classes.html_section-7'>잠깐? 내가 만든 라이브러리를 어떻게 해킹하지?!</h5><p>오버라이딩에 대해 클래스와 멤버가 기본적으로 final인 접근 방식은 한 가지 이슈가 있다. 그것은 바로 라이브러리 설계자가
오버라이딩하도록 의도하지 않은 어떤 메서드를 오버라이딩하거나 무언가 위험한(nasty) 해킹을 위해 라이브러리에 있는 무언가를 상속하기 어렵다는 점이다.</p><p>우리는 다음과 같은 이유로 이는 단점이 아니라 생각한다:</p><ul>
  <li>어쨋든 이런 류의 해킹은 허용하지 않는게 최상(best practice)이다</li>
  <li>유사한 방식을 갖는 다른 언어(C++, C#)를 성공적으로 사용하고 있다</li>
  <li>실제로 해킹을 원한다면 방법이 존재한다. 자바로 해킹 코드를 작성해서 코틀린에서 호출할 수 있고 (<em><a href='#java-interop.html'>자바 상호운용</a> 참고</em>), Aspect 프레임워크로 해킹할 수 있다.</li>
</ul><h4 id='classes.html_section-8'>오버라이딩 규칙<a class='anchor' href='#%23section-8'> </a></h4><p>코틀린에서 구현 상속은 다음 규칙을 따른다: 클래스가 바로 상위의 여러 상위클래스에서 같은 멤버 구현을 상속하면,
반드시 이 멤버를 오버라이딩하고 자신의 구현을 제공해야 한다(대게 상속받은 것 중의 하나를 사용하는 구현을 제공).
사용할 상위타입의 구현을 지정하려면 화살괄호에 상위타입 이름을 지정한 <em class='keyword'>super</em>를 사용한다. 예, <code>super&lt;Base&gt;</code>:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>open</span> <span class='k'>class</span> <span class='nc'>A</span> <span class='p'>{</span>
  <span class='k'>open</span> <span class='k'>fun</span> <span class='nf'>f</span><span class='p'>()</span> <span class='p'>{</span> <span class='n'>print</span><span class='p'>(</span><span class='s'>&quot;A&quot;</span><span class='p'>)</span> <span class='p'>}</span>
  <span class='k'>fun</span> <span class='nf'>a</span><span class='p'>()</span> <span class='p'>{</span> <span class='n'>print</span><span class='p'>(</span><span class='s'>&quot;a&quot;</span><span class='p'>)</span> <span class='p'>}</span>
<span class='p'>}</span>

<span class='n'>interface</span> <span class='n'>B</span> <span class='p'>{</span>
  <span class='k'>fun</span> <span class='nf'>f</span><span class='p'>()</span> <span class='p'>{</span> <span class='n'>print</span><span class='p'>(</span><span class='s'>&quot;B&quot;</span><span class='p'>)</span> <span class='p'>}</span> <span class='c1'>// 인터페이스의 멤버는 기본적으로 &#39;open&#39;이다</span>
  <span class='k'>fun</span> <span class='nf'>b</span><span class='p'>()</span> <span class='p'>{</span> <span class='n'>print</span><span class='p'>(</span><span class='s'>&quot;b&quot;</span><span class='p'>)</span> <span class='p'>}</span>
<span class='p'>}</span>

<span class='k'>class</span> <span class='nc'>C</span><span class='p'>()</span> <span class='p'>:</span> <span class='n'>A</span><span class='p'>(),</span> <span class='n'>B</span> <span class='p'>{</span>
  <span class='c1'>// 컴파일하려면 f()를 오버라이딩해야 한다:</span>
  <span class='k'>override</span> <span class='k'>fun</span> <span class='nf'>f</span><span class='p'>()</span> <span class='p'>{</span>
    <span class='k'>super</span><span class='p'>&lt;</span><span class='n'>A</span><span class='p'>&gt;.</span><span class='n'>f</span><span class='p'>()</span> <span class='c1'>// call to A.f()</span>
    <span class='k'>super</span><span class='p'>&lt;</span><span class='n'>B</span><span class='p'>&gt;.</span><span class='n'>f</span><span class='p'>()</span> <span class='c1'>// call to B.f()</span>
  <span class='p'>}</span>
<span class='p'>}</span></code></pre><p><code>A</code>와 <code>B</code>를 상속받는 것은 괜찮으며, <code>a()</code>와 <code>b()</code>와 관련된 문제가 없다. 왜냐면 <code>C</code>는 이 두 함수에 대해 각각 한 개의 구현만 상속받기 때문이다.
하지만, <code>f()</code>의 경우 <code>C</code>가 두 개의 구현을 상속받기 때문에, 모호함을 제거하기 위해 <code>C</code>에 <code>f()</code> 구현을 제공해야 한다.</p><h3 id='classes.html_section-9'>추상 클래스<a class='anchor' href='#%23section-9'> </a></h3><p>클래스와 멤버를 <em class='keyword'>abstract</em>로 선언할 수 있다.
추상 멤버는 구현을 갖지 않는다.
추상 클래스나 함수는 open을 붙일 필요가 없다.</p><p>추상이 아닌 open 멤버를 추상 멤버로 오버라이딩할 수 있다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>open</span> <span class='k'>class</span> <span class='nc'>Base</span> <span class='p'>{</span>
  <span class='k'>open</span> <span class='k'>fun</span> <span class='nf'>f</span><span class='p'>()</span> <span class='p'>{}</span>
<span class='p'>}</span>

<span class='k'>abstract</span> <span class='k'>class</span> <span class='nc'>Derived</span> <span class='p'>:</span> <span class='n'>Base</span><span class='p'>()</span> <span class='p'>{</span>
  <span class='k'>override</span> <span class='k'>abstract</span> <span class='k'>fun</span> <span class='nf'>f</span><span class='p'>()</span>
<span class='p'>}</span></code></pre><h3 id='classes.html_companion-objects'>컴페니언 오브젝트(Companion Objects)<a class='anchor' href='#%23companion-objects'> </a></h3><p>자바나 C#과 달리 코틀린의 클래스는 정적 메서드를 갖지 않는다. 많은 경우 그 대신 패키지 수준의 함수를 사용할 것을 권한다.</p><p>만약 클래스 인스턴스없이 클래스의 내부에 접근해야하는 함수를 작성하고 싶다면(예, 팩토리 메서드)
그 클래스 안에 <a href='#object-declarations.html'>선언한 오브젝트</a>의 멤버로 함수를 작성할 수 있다.</p><p>좀 더 구체적으로 말하면 클래스 안에 <a href='#object-declarations.html%23companion-objects'>컴페니언 오브젝트</a>를 선언하면
클래스 이름만으로 자바/C#의 정적 메서드를 호출하는 것처럼 컴페니언 오브젝트의 멤버를 호출할 수 있다.</p><h3 id='classes.html_sealed-classes'>실드 클래스(Sealed Classes)<a class='anchor' href='#%23sealed-classes'> </a></h3><p>가질 수 있는 타입을 특정 타입 집합으로 제한하고 다른 타입은 가질 수 없도록 하고 싶을 때,
클래스 상속을 제한할 목적으로 실드 클래스를 사용한다. 실드 클래스는 어떤 의미에서 열거형 클래스의 확장이다.
열거 타입은 제한된 값 집합을 갖지만, 각 열거형 상수는 오직 한 개 인스턴스만 존재한다.
반면에 실드 클래스의 하위클래스는 상태를 포함할 수 있는 여러 인스턴스를 가질 수 있다.</p><p>실드 클래스를 선언하려면 클래스 이름 앞에 <code>sealed</code> 제한자를 쓰면 된다. 실드 클래스는 하위 클래스를 가질 수 있지만
모든 하위 클래스는 실드 클래스 선언 자체에 중첩해야 한다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>sealed</span> <span class='k'>class</span> <span class='nc'>Expr</span> <span class='p'>{</span>
    <span class='k'>class</span> <span class='nc'>Const</span><span class='p'>(</span><span class='k'>val</span> <span class='py'>number</span><span class='p'>:</span> <span class='n'>Double</span><span class='p'>)</span> <span class='p'>:</span> <span class='n'>Expr</span><span class='p'>()</span>
    <span class='k'>class</span> <span class='nc'>Sum</span><span class='p'>(</span><span class='k'>val</span> <span class='py'>e1</span><span class='p'>:</span> <span class='n'>Expr</span><span class='p'>,</span> <span class='k'>val</span> <span class='py'>e2</span><span class='p'>:</span> <span class='n'>Expr</span><span class='p'>)</span> <span class='p'>:</span> <span class='n'>Expr</span><span class='p'>()</span>
    <span class='k'>object</span> <span class='nc'>NotANumber</span> <span class='p'>:</span> <span class='n'>Expr</span><span class='p'>()</span>
<span class='p'>}</span></code></pre><p>실드 클래스의 하위 클래스를 확장하는 클래스(indirect inheritors)는 어디든 위치할 수 있다. 실드 클래스 선언 내부에 위치할 필요는 없다.</p><p>실드 클래스의 최대 장점은 <a href='#control-flow.html%23when-expression'><code>when</code> 식</a>과 함께 사용할 수 있다는 점이다.
모든 경우를 다루는지 확인할 수 있다면, <code>else</code> 절을 추가할 필요가 없다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>eval</span><span class='p'>(</span><span class='n'>expr</span><span class='p'>:</span> <span class='n'>Expr</span><span class='p'>):</span> <span class='n'>Double</span> <span class='p'>=</span> <span class='k'>when</span><span class='p'>(</span><span class='n'>expr</span><span class='p'>)</span> <span class='p'>{</span>
    <span class='k'>is</span> <span class='n'>Expr</span><span class='p'>.</span><span class='n'>Const</span> <span class='p'>-&gt;</span> <span class='n'>expr</span><span class='p'>.</span><span class='n'>number</span>
    <span class='k'>is</span> <span class='n'>Expr</span><span class='p'>.</span><span class='n'>Sum</span> <span class='p'>-&gt;</span> <span class='n'>eval</span><span class='p'>(</span><span class='n'>expr</span><span class='p'>.</span><span class='n'>e1</span><span class='p'>)</span> <span class='p'>+</span> <span class='n'>eval</span><span class='p'>(</span><span class='n'>expr</span><span class='p'>.</span><span class='n'>e2</span><span class='p'>)</span>
    <span class='n'>Expr</span><span class='p'>.</span><span class='n'>NotANumber</span> <span class='p'>-&gt;</span> <span class='n'>Double</span><span class='p'>.</span><span class='n'>NaN</span>
    <span class='c1'>// 모든 경우를 다루기 때문에 `else` 절이 필요없다</span>
<span class='p'>}</span></code></pre>
              </article>
          
              <article id="properties.html" class="page-content">
                <h2 id='properties.html_section'>프로퍼티와 필드<a class='anchor' href='#%23section'> </a></h2><h3 id='properties.html_section-1'>프로퍼티 선언<a class='anchor' href='#%23section-1'> </a></h3><p>코틀린 클래스는 프로퍼티를 가질 수 있다.
<em class='keyword'>var</em> 키워드로 변경 가능 프로퍼티를 또는 <em class='keyword'>val</em> 키워드로 읽기 전용 프로퍼티를 선언할 수 있다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>public</span> <span class='k'>class</span> <span class='nc'>Address</span> <span class='p'>{</span>
  <span class='k'>public</span> <span class='k'>var</span> <span class='py'>name</span><span class='p'>:</span> <span class='n'>String</span> <span class='p'>=</span> <span class='p'>...</span>
  <span class='k'>public</span> <span class='k'>var</span> <span class='py'>street</span><span class='p'>:</span> <span class='n'>String</span> <span class='p'>=</span> <span class='p'>...</span>
  <span class='k'>public</span> <span class='k'>var</span> <span class='py'>city</span><span class='p'>:</span> <span class='n'>String</span> <span class='p'>=</span> <span class='p'>...</span>
  <span class='k'>public</span> <span class='k'>var</span> <span class='py'>state</span><span class='p'>:</span> <span class='n'>String</span><span class='p'>?</span> <span class='p'>=</span> <span class='p'>...</span>
  <span class='k'>public</span> <span class='k'>var</span> <span class='py'>zip</span><span class='p'>:</span> <span class='n'>String</span> <span class='p'>=</span> <span class='p'>...</span>
<span class='p'>}</span></code></pre><p>프로퍼티를 사용하려면 자바 필드처럼 단순히 이름으로 참조하면 된다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>copyAddress</span><span class='p'>(</span><span class='n'>address</span><span class='p'>:</span> <span class='n'>Address</span><span class='p'>):</span> <span class='n'>Address</span> <span class='p'>{</span>
  <span class='k'>val</span> <span class='py'>result</span> <span class='p'>=</span> <span class='n'>Address</span><span class='p'>()</span> <span class='c1'>// 코틀린은 &#39;new&#39; 키워드가 없다</span>
  <span class='n'>result</span><span class='p'>.</span><span class='n'>name</span> <span class='p'>=</span> <span class='n'>address</span><span class='p'>.</span><span class='n'>name</span> <span class='c1'>// accessor 실행</span>
  <span class='n'>result</span><span class='p'>.</span><span class='n'>street</span> <span class='p'>=</span> <span class='n'>address</span><span class='p'>.</span><span class='n'>street</span>
  <span class='c1'>// ...</span>
  <span class='k'>return</span> <span class='n'>result</span>
<span class='p'>}</span></code></pre><h3 id='properties.html_getters-setters'>Getters와 Setters<a class='anchor' href='#%23getters-setters'> </a></h3><p>프로퍼티 선언의 전체 구문은 다음과 같다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>var</span> <span class='err'>&lt;</span><span class='py'>propertyName</span><span class='p'>&gt;:</span> <span class='p'>&lt;</span><span class='n'>PropertyType</span><span class='p'>&gt;</span> <span class='p'>[=</span> <span class='p'>&lt;</span><span class='n'>property_initializer</span><span class='p'>&gt;]</span>
<span class='na'>  [&lt;getter&gt;]</span>
<span class='na'>  [&lt;setter&gt;]</span></code></pre><p>initializer, getter, setter는 선택 사항이다. initializer나 오버라이딩한 베이스 클래스 멤버에서 타입을 유추할 수 있다면 프로퍼티 타입을 생략해도 된다.</p><p>예:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>var</span> <span class='py'>allByDefault</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>?</span> <span class='c1'>// 에러: initializer 필요, 기본 getter와 setter 포함</span>
<span class='k'>var</span> <span class='py'>initialized</span> <span class='p'>=</span> <span class='m'>1</span> <span class='c1'>// Int 타입, 기본 getter와 setter 가짐</span></code></pre><p>읽기 전용 프로퍼티 선언의 전체 구문은 변경 가능 프로퍼티와 두 가지가 다르다. <code>var</code> 대신에 <code>val</code>로 시작하고 setter를 허용하지 않는다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>simple</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>?</span> <span class='c1'>// Int 타입과 기본 getter를 갖고, 생성자에서 초기화해야 한다</span>
<span class='k'>val</span> <span class='py'>inferredType</span> <span class='p'>=</span> <span class='m'>1</span> <span class='c1'>// Int 타입과 기본 getter를 갖는다</span></code></pre><p>프로퍼티 선언에서 바로 뒤에 일반 함수와 유사한 커스텀 accessor를 작성할 수 있다. 다음은 커스텀 getter의 예다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>isEmpty</span><span class='p'>:</span> <span class='n'>Boolean</span>
  <span class='k'>get</span><span class='p'>()</span> <span class='p'>=</span> <span class='k'>this</span><span class='p'>.</span><span class='n'>size</span> <span class='p'>==</span> <span class='m'>0</span></code></pre><p>다음은 커스텀 setter의 예다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>var</span> <span class='py'>stringRepresentation</span><span class='p'>:</span> <span class='n'>String</span>
  <span class='k'>get</span><span class='p'>()</span> <span class='p'>=</span> <span class='k'>this</span><span class='p'>.</span><span class='n'>toString</span><span class='p'>()</span>
  <span class='k'>set</span><span class='p'>(</span><span class='n'>value</span><span class='p'>)</span> <span class='p'>{</span>
    <span class='n'>setDataFromString</span><span class='p'>(</span><span class='n'>value</span><span class='p'>)</span> <span class='c1'>// 문자열을 파싱해서 다른 프로퍼티에 할당한다</span>
  <span class='p'>}</span></code></pre><p>보통 setter의 파라미터 이름으로 <code>value</code>를 사용하지만 원하는 다른 이름을 사용할 수 있다.</p><p>accessor의 기본 구현을 변경하지 않고 가시성을 변경하거나 애노테이션을 적용하고 싶다면
몸체 선언 없이 accessor를 정의할 수 있다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>var</span> <span class='py'>setterVisibility</span><span class='p'>:</span> <span class='n'>String</span> <span class='p'>=</span> <span class='s'>&quot;abc&quot;</span>
  <span class='k'>private</span> <span class='k'>set</span> <span class='c1'>// setter는 private이고 기본 구현을 갖는다</span>

<span class='k'>var</span> <span class='py'>setterWithAnnotation</span><span class='p'>:</span> <span class='n'>Any</span><span class='p'>?</span> <span class='p'>=</span> <span class='k'>null</span>
  <span class='n'>@Inject</span> <span class='k'>set</span> <span class='c1'>// setter에 @Inject를 붙인다</span></code></pre><h4 id='properties.html_backing-'>Backing 필드<a class='anchor' href='#%23backing-'> </a></h4><p>코틀린 클래스는 필드를 가질 수 없다. 하지만 커스텀 accessor를 사용하면 backing 필드가 필요할 때가 있다.
이를 위해 코틀린은 <code>field</code> 식별자를 사용해서 접근할 수 있는 backing 필드를 제공한다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>var</span> <span class='py'>counter</span> <span class='p'>=</span> <span class='m'>0</span> <span class='c1'>// 초기화 값을 backing 필드에 직접 쓴다</span>
  <span class='k'>set</span><span class='p'>(</span><span class='n'>value</span><span class='p'>)</span> <span class='p'>{</span>
    <span class='k'>if</span> <span class='p'>(</span><span class='n'>value</span> <span class='p'>&gt;=</span> <span class='m'>0</span><span class='p'>)</span>
      <span class='n'>field</span> <span class='p'>=</span> <span class='n'>value</span>
  <span class='p'>}</span></code></pre><p><code>field</code> 식별자는 프로퍼티 accessor에서만 사용할 수 있다.</p><p>accessor 몸체에서 backing 필드를 사용하면 (또는 기본 구현을 사용하면), 컴파일러는backing 필드를 생성한다. 그렇지 않으면 생성하지 않는다.</p><p>예를 들어, 다음 경우 backing 필드가 없다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>isEmpty</span><span class='p'>:</span> <span class='n'>Boolean</span>
  <span class='k'>get</span><span class='p'>()</span> <span class='p'>=</span> <span class='k'>this</span><span class='p'>.</span><span class='n'>size</span> <span class='p'>==</span> <span class='m'>0</span></code></pre><h4 id='properties.html_backing--1'>Backing 프로퍼티<a class='anchor' href='#%23backing--1'> </a></h4><p>“기본(implicit) backing 필드” 방식과 맞지 않는 것을 하고 싶다면 <em>backing 프로퍼티</em>로 대체할 수 있다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>private</span> <span class='k'>var</span> <span class='py'>_table</span><span class='p'>:</span> <span class='n'>Map</span><span class='p'>&lt;</span><span class='n'>String</span><span class='p'>,</span> <span class='n'>Int</span><span class='p'>&gt;?</span> <span class='p'>=</span> <span class='k'>null</span>
<span class='k'>public</span> <span class='k'>val</span> <span class='py'>table</span><span class='p'>:</span> <span class='n'>Map</span><span class='p'>&lt;</span><span class='n'>String</span><span class='p'>,</span> <span class='n'>Int</span><span class='p'>&gt;</span>
  <span class='k'>get</span><span class='p'>()</span> <span class='p'>{</span>
    <span class='k'>if</span> <span class='p'>(</span><span class='n'>_table</span> <span class='p'>==</span> <span class='k'>null</span><span class='p'>)</span>
      <span class='n'>_table</span> <span class='p'>=</span> <span class='n'>HashMap</span><span class='p'>()</span> <span class='c1'>// 타입 파라미터를 유추</span>
    <span class='k'>return</span> <span class='n'>_table</span> <span class='o'>?:</span> <span class='k'>throw</span> <span class='n'>AssertionError</span><span class='p'>(</span><span class='s'>&quot;Set to null by another thread&quot;</span><span class='p'>)</span>
  <span class='p'>}</span></code></pre><p>기본 getter와 setter로 private 프로퍼티에 접근하는 것을 최적화해서 추가되는 함수 호출 오버헤드가 없기 때문에 모든 점에서 자바와 같다.</p><h3 id='properties.html_section-2'>컴파일 타임 상수<a class='anchor' href='#%23section-2'> </a></h3><p>컴파일 타임에 값을 알 수 있는 프로퍼티는 <code>const</code> 제한자를 이용해서  _컴파일 타임 상수_로 지정할 수 있다.
이 프로퍼티는 다음 요건을 충족해야 한다:</p><ul>
  <li>최상위 레벨 또는 <code>오브젝트</code>의 멤버</li>
  <li><code>String</code>이나 기본 타입 값으로 초기화</li>
  <li>커스텀 getter 없음</li>
</ul><p>이 프로퍼티는 애노테이션에서 사용할 수 있다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>const</span> <span class='k'>val</span> <span class='py'>SUBSYSTEM_DEPRECATED</span><span class='p'>:</span> <span class='n'>String</span> <span class='p'>=</span> <span class='s'>&quot;This subsystem is deprecated&quot;</span>

<span class='n'>@Deprecated</span><span class='p'>(</span><span class='n'>SUBSYSTEM_DEPRECATED</span><span class='p'>)</span> <span class='k'>fun</span> <span class='nf'>foo</span><span class='p'>()</span> <span class='p'>{</span> <span class='p'>...</span> <span class='p'>}</span></code></pre><h3 id='properties.html_late-initialized-'>Late-Initialized 프로퍼티<a class='anchor' href='#%23late-initialized-'> </a></h3><p>보통 non-null 타입을 갖는 프로퍼티를 선언하면 생성자에서 초기화해야 한다.
하지만 이게 늘 편한 것은 아니다. 예를 들어, 의존 주입이나 단위 테스트의 셋업 메서드에서 프로퍼티를 초기화할 수 있다.
이 경우 생성자에 non-null initializer를 제공할 수 없지만 클래스 몸체 안에서 프로퍼티를 참조할 때 null 검사를 하고 싶지 않을 것이다.</p><p>이 경우를 처리하기 위해 프로퍼티를 <code>lateinit</code>로 제한할 수 있다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>public</span> <span class='k'>class</span> <span class='nc'>MyTest</span> <span class='p'>{</span>
    <span class='n'>lateinit</span> <span class='k'>var</span> <span class='py'>subject</span><span class='p'>:</span> <span class='n'>TestSubject</span>

    <span class='n'>@SetUp</span> <span class='k'>fun</span> <span class='nf'>setup</span><span class='p'>()</span> <span class='p'>{</span>
        <span class='n'>subject</span> <span class='p'>=</span> <span class='n'>TestSubject</span><span class='p'>()</span>
    <span class='p'>}</span>

    <span class='n'>@Test</span> <span class='k'>fun</span> <span class='nf'>test</span><span class='p'>()</span> <span class='p'>{</span>
        <span class='n'>subject</span><span class='p'>.</span><span class='n'>method</span><span class='p'>()</span>  <span class='c1'>// null 검사 없이 직접 접근(dereference directly)</span>
    <span class='p'>}</span>
<span class='p'>}</span></code></pre><p>이 제한자는 (주요 생성자가 아닌) 클래스 몸체에 선언되고 커스텀 getter나 setter를 갖지 않는 <code>var</code> 프로퍼티에만 사용할 수 있다.
프로퍼티 타입은 non-null이어야 하고 기본 타입이면 안 된다.</p><p>초기화되기 전에 <code>lateinit</code> 프로퍼티에 접근하면, 초기화되지 않은 프로퍼티에 접근했음을 정확하게 알려주기 위해 특수한 익셉션을 발생한다.</p><h3 id='properties.html_section-3'>프로퍼티 오버라이딩<a class='anchor' href='#%23section-3'> </a></h3><p><a href='#classes.html%23overriding-members'>멤버 오버라이딩</a> 참고</p><h3 id='properties.html_section-4'>위임 프로퍼티<a class='anchor' href='#%23section-4'> </a></h3><p>대부분 프로퍼티는 단순히 backing 필드에서 값을 읽거나 쓴다.
반면에 커스텀 getter와 setter를 갖는 프로퍼티는 프로퍼티의 행위를 구현할 수 있다.
프로퍼티 행위 구현에는 프로퍼티가 어떻게 작동하는지에 대한 어떤 공통 패턴이 있다. 키로 맵에서 읽기, 데이터베이스 접근하기, 접근시 리스너에 통지하기 등이 공톤 패턴에 해당한다.</p><p>이런 공통 행위는 <a href='#delegated-properties.html'><em>위임 프로퍼티</em></a>를 사용하는 라이브러리로 구현할 수 있다.</p>
              </article>
          
              <article id="interfaces.html" class="page-content">
                <h2 id='interfaces.html_section'>인터페이스<a class='anchor' href='#%23section'> </a></h2><p>코틀린 인터페이스는 자바 8과 매우 유사하다. 추상 메서드뿐만 아니라 메서드 구현을 가질 수 있다.
추상 클래스와의 차이점은 인터페이스는 상태를 가질 수 없다는 점이다. 프로퍼티를 가질 수는 있지만
추상이거나 accessor 구현을 제공해야 한다.</p><p><em class='keyword'>interface</em> 키워드로 인터페이스를 정의한다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>interface</span> <span class='n'>MyInterface</span> <span class='p'>{</span>
    <span class='k'>fun</span> <span class='nf'>bar</span><span class='p'>()</span>
    <span class='k'>fun</span> <span class='nf'>foo</span><span class='p'>()</span> <span class='p'>{</span>
      <span class='c1'>// 몸체 선택</span>
    <span class='p'>}</span>
<span class='p'>}</span></code></pre><h3 id='interfaces.html_section-1'>인터페이스 구현<a class='anchor' href='#%23section-1'> </a></h3><p>클래스나 오브젝트는 한 개 이상의 인터페이스를 구현할 수 있다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>class</span> <span class='nc'>Child</span> <span class='p'>:</span> <span class='n'>MyInterface</span> <span class='p'>{</span>
   <span class='k'>override</span> <span class='k'>fun</span> <span class='nf'>bar</span><span class='p'>()</span> <span class='p'>{</span>
      <span class='c1'>// 몸체</span>
   <span class='p'>}</span>
<span class='p'>}</span></code></pre><h3 id='interfaces.html_section-2'>인터페이스의 프로퍼티<a class='anchor' href='#%23section-2'> </a></h3><p>인터페이스에 프로퍼티를 선언할 수 있다. 인터페이스에 선언된 프로퍼티는 추상이거나 accessor를 위한 구현을 제공해야 한다.
인터페이스에 선언된 프로퍼티는 backing 필드를 가질 수 없으므로 인터페이스에 선언한 accessor는 backing 필드를 참조할 수 없다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>interface</span> <span class='n'>MyInterface</span> <span class='p'>{</span>
    <span class='k'>val</span> <span class='py'>property</span><span class='p'>:</span> <span class='n'>Int</span> <span class='c1'>// 추상</span>

    <span class='k'>val</span> <span class='py'>propertyWithImplementation</span><span class='p'>:</span> <span class='n'>String</span>
        <span class='k'>get</span><span class='p'>()</span> <span class='p'>=</span> <span class='s'>&quot;foo&quot;</span>

    <span class='k'>fun</span> <span class='nf'>foo</span><span class='p'>()</span> <span class='p'>{</span>
        <span class='n'>print</span><span class='p'>(</span><span class='n'>property</span><span class='p'>)</span>
    <span class='p'>}</span>
<span class='p'>}</span>

<span class='k'>class</span> <span class='nc'>Child</span> <span class='p'>:</span> <span class='n'>MyInterface</span> <span class='p'>{</span>
    <span class='k'>override</span> <span class='k'>val</span> <span class='py'>property</span><span class='p'>:</span> <span class='n'>Int</span> <span class='p'>=</span> <span class='m'>29</span>
<span class='p'>}</span></code></pre><h3 id='interfaces.html_section-3'>오버라이딩 충돌 해결<a class='anchor' href='#%23section-3'> </a></h3><p>상위타입 목록에 여러 타입을 지정하면 같은 메서드에 대해 한 개 이상의 구현을 상속받기도 한다. 다음 예를 보자.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>interface</span> <span class='n'>A</span> <span class='p'>{</span>
  <span class='k'>fun</span> <span class='nf'>foo</span><span class='p'>()</span> <span class='p'>{</span> <span class='n'>print</span><span class='p'>(</span><span class='s'>&quot;A&quot;</span><span class='p'>)</span> <span class='p'>}</span>
  <span class='k'>fun</span> <span class='nf'>bar</span><span class='p'>()</span>
<span class='p'>}</span>

<span class='n'>interface</span> <span class='n'>B</span> <span class='p'>{</span>
  <span class='k'>fun</span> <span class='nf'>foo</span><span class='p'>()</span> <span class='p'>{</span> <span class='n'>print</span><span class='p'>(</span><span class='s'>&quot;B&quot;</span><span class='p'>)</span> <span class='p'>}</span>
  <span class='k'>fun</span> <span class='nf'>bar</span><span class='p'>()</span> <span class='p'>{</span> <span class='n'>print</span><span class='p'>(</span><span class='s'>&quot;bar&quot;</span><span class='p'>)</span> <span class='p'>}</span>
<span class='p'>}</span>

<span class='k'>class</span> <span class='nc'>C</span> <span class='p'>:</span> <span class='n'>A</span> <span class='p'>{</span>
  <span class='k'>override</span> <span class='k'>fun</span> <span class='nf'>bar</span><span class='p'>()</span> <span class='p'>{</span> <span class='n'>print</span><span class='p'>(</span><span class='s'>&quot;bar&quot;</span><span class='p'>)</span> <span class='p'>}</span>
<span class='p'>}</span>

<span class='k'>class</span> <span class='nc'>D</span> <span class='p'>:</span> <span class='n'>A</span><span class='p'>,</span> <span class='n'>B</span> <span class='p'>{</span>
  <span class='k'>override</span> <span class='k'>fun</span> <span class='nf'>foo</span><span class='p'>()</span> <span class='p'>{</span>
    <span class='k'>super</span><span class='p'>&lt;</span><span class='n'>A</span><span class='p'>&gt;.</span><span class='n'>foo</span><span class='p'>()</span>
    <span class='k'>super</span><span class='p'>&lt;</span><span class='n'>B</span><span class='p'>&gt;.</span><span class='n'>foo</span><span class='p'>()</span>
  <span class='p'>}</span>
<span class='p'>}</span></code></pre><p><em>A</em>와 <em>B</em> 인터페이스가 <em>foo()</em>와 <em>bar()</em> 함수를 선언하고 있다. <em>foo()</em>는 두 인터페이스가 모두 구현하고 있고, <em>bar()</em>는 <em>B</em>만 구현하고 있다(<em>A</em>에서 <em>bar()</em>를 abstract로 지정하지 않았는데,
그 이유는 인터페이스에서는 함수에 몸체가 없으면 기본으로 추상이기 때문이다). 이제 컨크리트 클래스 <em>C</em>가 <em>A</em>를 상속받으면, <em>C</em>는 명백하게 <em>bar()</em>를 오버라이딩해서 구현을 제공해야 한다.
그리고 <em>A</em>와 <em>B</em>를 상속받은 <em>D</em>는 <em>bar()</em>를 오버라이딩 할 필요가 없다. 왜냐면 한 개 구현만 상속받기 때문이다.
하지만 <em>foo()</em>는 두 개 구현을 상속받기 때문에 컴파일러는 둘 중 무엇을 선택해야 하는지 알 수 없다. 따라서 컴파일러는 <em>foo()</em>를 명시적으로 오버라이딩할 것을 강제한다.</p>
              </article>
          
              <article id="visibility-modifiers.html" class="page-content">
                <h2 id='visibility-modifiers.html_section'>가시성 제한자<a class='anchor' href='#%23section'> </a></h2><p>클래스, 오브젝트, 인터페이스, 생성자, 함수, 프로퍼티와 프로퍼티의 setter는 _가시성 제한자_를 가질 수 있다(getter는 항상 프로퍼티와 동일한 가시성을 갖는다).
코틀린에는 <code>private</code>, <code>protected</code>, <code>internal</code>, <code>public</code>의 네 개의 가시성 제한자가 존재한다.
명시적으로 제한자를 지정하지 않으면 기본적으로 <code>public</code> 가시성을 갖는다.</p><p>다른 종류의 스코프 선언별로 제한자에 대한 설명은 아래를 참고한다.</p><h3 id='visibility-modifiers.html_section-1'>패키지<a class='anchor' href='#%23section-1'> </a></h3><p>함수, 프로퍼티와 클래스, 오브젝트와 인터페이스는 “최상위 레벨”로 선언할 수 있다. 예를 들어 패키지 안에 바로 선언할 수 있다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='c1'>// 파일 이름: example.kt</span>
<span class='k'>package</span> <span class='nn'>foo</span>

<span class='k'>fun</span> <span class='nf'>baz</span><span class='p'>()</span> <span class='p'>{}</span>
<span class='k'>class</span> <span class='nc'>Bar</span> <span class='p'>{}</span></code></pre><ul>
  <li>만약 가시성 제한자를 지정하지 않으면 기본으로 <code>public</code>을 사용한다. 모든 곳에서 해당 선언에 접근할 수 있다;</li>
  <li><code>private</code>으로 지정하면 해당 선언을 포함한 파일에서만 접근할 수 있다;</li>
  <li><code>internal</code>로 지정하면 같은 모듈 안에서 접근할 수 있다;</li>
  <li>최상위 레벨 선언은 <code>protected</code>로 지정할 수 없다.</li>
</ul><p>예제:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='c1'>// 파일 이름: example.kt</span>
<span class='k'>package</span> <span class='nn'>foo</span>

<span class='k'>private</span> <span class='k'>fun</span> <span class='nf'>foo</span><span class='p'>()</span> <span class='p'>{}</span> <span class='c1'>// example.kt에서만 접근 가능</span>

<span class='k'>public</span> <span class='k'>var</span> <span class='py'>bar</span><span class='p'>:</span> <span class='n'>Int</span> <span class='p'>=</span> <span class='m'>5</span> <span class='c1'>// 프로퍼티는 모든 곳에서 접근 가능</span>
    <span class='k'>private</span> <span class='k'>set</span>         <span class='c1'>// setter는 example.kt에서만 접근 가능</span>

<span class='k'>internal</span> <span class='k'>val</span> <span class='py'>baz</span> <span class='p'>=</span> <span class='m'>6</span>    <span class='c1'>// 같은 모듈 안에서 접근 가능</span></code></pre><h3 id='visibility-modifiers.html_section-2'>클래스와 인터페이스<a class='anchor' href='#%23section-2'> </a></h3><p>클래스 안에서 선언할 때:</p><ul>
  <li><code>private</code>은 (클래스의 모든 멤버를 포함한) 클래스 안에서만 접근 가능하다;</li>
  <li><code>protected</code> — <code>private</code>과 동일 + 하위클래스에서 접근 가능하다;</li>
  <li><code>internal</code> — 선언한 클래스에 접근할 수 있는 <em>모듈에 속한</em> 모든 클라이언트가 <code>internal</code> 멤버에 접근 가능하다;</li>
  <li><code>public</code> — 선언한 클래스에 접근할 수 있는 모든 클라이언트가 <code>public</code> 멤버에 접근 가능하다.</li>
</ul><p>자바 개발자 대상 <em>주의</em>: 코틀린에서 외부 클래스는 자신의 내부 클래스에 있는 private 멤버에 접근할 수 없다.</p><p>예제:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>open</span> <span class='k'>class</span> <span class='nc'>Outer</span> <span class='p'>{</span>
    <span class='k'>private</span> <span class='k'>val</span> <span class='py'>a</span> <span class='p'>=</span> <span class='m'>1</span>
    <span class='k'>protected</span> <span class='k'>val</span> <span class='py'>b</span> <span class='p'>=</span> <span class='m'>2</span>
    <span class='k'>internal</span> <span class='k'>val</span> <span class='py'>c</span> <span class='p'>=</span> <span class='m'>3</span>
    <span class='k'>val</span> <span class='py'>d</span> <span class='p'>=</span> <span class='m'>4</span>  <span class='c1'>// 기본으로 public</span>

    <span class='k'>protected</span> <span class='k'>class</span> <span class='nc'>Nested</span> <span class='p'>{</span>
        <span class='k'>public</span> <span class='k'>val</span> <span class='py'>e</span><span class='p'>:</span> <span class='n'>Int</span> <span class='p'>=</span> <span class='m'>5</span>
    <span class='p'>}</span>
<span class='p'>}</span>

<span class='k'>class</span> <span class='nc'>Subclass</span> <span class='p'>:</span> <span class='n'>Outer</span><span class='p'>()</span> <span class='p'>{</span>
    <span class='c1'>// a에 접근 불가</span>
    <span class='c1'>// b, c 그리고 d에 접근 가능</span>
    <span class='c1'>// Nested와 e에 접근 가능</span>
<span class='p'>}</span>

<span class='k'>class</span> <span class='nc'>Unrelated</span><span class='p'>(</span><span class='n'>o</span><span class='p'>:</span> <span class='n'>Outer</span><span class='p'>)</span> <span class='p'>{</span>
    <span class='c1'>// o.a, o.b에 접근 불가</span>
    <span class='c1'>// o.c(같은 모듈)와 o.d에 접근 가능</span>
    <span class='c1'>// Outer.Nested에 접근 불가, 그리고 Nested::e에도 접근 불가</span>
<span class='p'>}</span></code></pre><h4 id='visibility-modifiers.html_section-3'>생성자<a class='anchor' href='#%23section-3'> </a></h4><p>클래스의 주요 생성자에 가시성을 지정하려면 다음 구문을 사용한다(<em class='keyword'>constructor</em> 키워드를 사용해야 한다):</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>class</span> <span class='nc'>C</span> <span class='k'>private</span> <span class='n'>constructor</span><span class='p'>(</span><span class='n'>a</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>)</span> <span class='p'>{</span> <span class='p'>...</span> <span class='p'>}</span></code></pre><p>여기서 생성자는 private이다. 모든 생성자의 기본 가시성은 <code>public</code>이며 클래스에 접근 가능한 모든 곳에서 접근 가능하다(예를 들어, <code>internal</code> 클래스의 생성자는 오직 동일 모듈에서만 접근 가능하다).</p><h4 id='visibility-modifiers.html_section-4'>로컬 선언<a class='anchor' href='#%23section-4'> </a></h4><p>로컬에 선언한 변수, 함수, 클래스는 가시성 제한자를 가질 수 없다.</p><h3 id='visibility-modifiers.html_section-5'>모듈<a class='anchor' href='#%23section-5'> </a></h3><p><code>internal</code> 가시성 제한자는 같은 모듈에서 멤버에 접근할 수 있다. 더 구체적으로 말하면
모듈은 함께 컴파일되는 코틀린 파일 집합이다:</p><ul>
  <li>IntelliJ IDEA 모듈;</li>
  <li>Maven이나 Gradle 프로젝트;</li>
  <li>한 <kotlinc> Ant 태스크 실행 시 컴파일되는 파일 집합.</kotlinc></li>
</ul>
              </article>
          
              <article id="extensions.html" class="page-content">
                <h2 id='extensions.html_section'>확장<a class='anchor' href='#%23section'> </a></h2><p>C#이나 Gosu와 비슷하게 코틀린은 클래스를 확장하거나 데코레이터와 같은 디자인 패턴을 사용하지 않고 클래스에 새 기능을 확장하는 기능을 제공한다.
_확장(extension)_이라 불리는 특수한 선언을 이용해서 확장할 수 있다. 코틀린은 _확장 함수_와 _확장 프로퍼티_를 지원한다.</p><h3 id='extensions.html_section-1'>확장 함수<a class='anchor' href='#%23section-1'> </a></h3><p>확장 함수를 선언하려면 <em>리시버 타입(receiver type)</em>(확장할 타입)의 이름을 접두어로 사용해야 한다.
다음은 <code>MutableList&lt;Int&gt;</code>에 <code>swap</code> 함수를 추가한다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>MutableList</span><span class='p'>&lt;</span><span class='n'>Int</span><span class='p'>&gt;.</span><span class='n'>swap</span><span class='p'>(</span><span class='n'>index1</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>,</span> <span class='n'>index2</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>)</span> <span class='p'>{</span>
  <span class='k'>val</span> <span class='py'>tmp</span> <span class='p'>=</span> <span class='k'>this</span><span class='p'>[</span><span class='n'>index1</span><span class='p'>]</span> <span class='c1'>// &#39;this&#39;는 리스트에 해당한다</span>
  <span class='k'>this</span><span class='p'>[</span><span class='n'>index1</span><span class='p'>]</span> <span class='p'>=</span> <span class='k'>this</span><span class='p'>[</span><span class='n'>index2</span><span class='p'>]</span>
  <span class='k'>this</span><span class='p'>[</span><span class='n'>index2</span><span class='p'>]</span> <span class='p'>=</span> <span class='n'>tmp</span>
<span class='p'>}</span></code></pre><p>확장 함수에서 <em class='keyword'>this</em> 키워드는 리시버 객체(점 기호 앞에 전달되는 객체)에 해당한다.
이제 <code>MutableList&lt;Int&gt;</code>에 대해 다음과 같이 함수를 호출할 수 있다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>l</span> <span class='p'>=</span> <span class='n'>mutableListOf</span><span class='p'>(</span><span class='m'>1</span><span class='p'>,</span> <span class='m'>2</span><span class='p'>,</span> <span class='m'>3</span><span class='p'>)</span>
<span class='n'>l</span><span class='p'>.</span><span class='n'>swap</span><span class='p'>(</span><span class='m'>0</span><span class='p'>,</span> <span class='m'>2</span><span class='p'>)</span> <span class='c1'>// &#39;swap()&#39;에서 &#39;this&#39;는 &#39;l&#39;의 값을 갖는다.</span></code></pre><p>물론 이 함수는 모든 <code>MutableList&lt;T&gt;</code>에 의미가 있으므로 지네릭으로 만들 수 있다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='err'>&lt;</span><span class='nf'>T</span><span class='p'>&gt;</span> <span class='n'>MutableList</span><span class='p'>&lt;</span><span class='n'>T</span><span class='p'>&gt;.</span><span class='n'>swap</span><span class='p'>(</span><span class='n'>index1</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>,</span> <span class='n'>index2</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>)</span> <span class='p'>{</span>
  <span class='k'>val</span> <span class='py'>tmp</span> <span class='p'>=</span> <span class='k'>this</span><span class='p'>[</span><span class='n'>index1</span><span class='p'>]</span> <span class='c1'>// &#39;this&#39;는 리스트에 해당한다</span>
  <span class='k'>this</span><span class='p'>[</span><span class='n'>index1</span><span class='p'>]</span> <span class='p'>=</span> <span class='k'>this</span><span class='p'>[</span><span class='n'>index2</span><span class='p'>]</span>
  <span class='k'>this</span><span class='p'>[</span><span class='n'>index2</span><span class='p'>]</span> <span class='p'>=</span> <span class='n'>tmp</span>
<span class='p'>}</span></code></pre><p>함수 이름 앞에 리시버 타입 식에서 사용가능한 타입 파라미터를 선언한다.
<a href='#generics.html'>지네릭 함수</a>를 참고한다.</p><h3 id='extensions.html_section-2'><strong>정적</strong>인 확장 결정<a class='anchor' href='#%23section-2'> </a></h3><p>확장은 실제로 확장할 클래스를 수정하지 않는다. 확장을 정의하면 클래스에 새 멤버를 추가하는 것이 아니라
단지 그 클래스의 인스턴스에 대해 점-기호로 호출할 수 있는 새로운 함수를 만드는 것뿐이다.</p><p>실행할 확장 함수는 <strong>정적으로</strong> 결정한다! 예를 들어 리시버 타입에 따라 버추얼하게 결정하지 않는다.
확장 함수를 호출하는 코드의 타입으로 호출할 확장 함수를 결정한다. 런타임에 그 식을 평가한 결과 타입으로 결정하지 않는다.
다음 예를 보자:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>open</span> <span class='k'>class</span> <span class='nc'>C</span>

<span class='k'>class</span> <span class='nc'>D</span><span class='p'>:</span> <span class='n'>C</span><span class='p'>()</span>

<span class='k'>fun</span> <span class='nf'>C</span><span class='p'>.</span><span class='n'>foo</span><span class='p'>()</span> <span class='p'>=</span> <span class='s'>&quot;c&quot;</span>

<span class='k'>fun</span> <span class='nf'>D</span><span class='p'>.</span><span class='n'>foo</span><span class='p'>()</span> <span class='p'>=</span> <span class='s'>&quot;d&quot;</span>

<span class='k'>fun</span> <span class='nf'>printFoo</span><span class='p'>(</span><span class='n'>c</span><span class='p'>:</span> <span class='n'>C</span><span class='p'>)</span> <span class='p'>{</span>
    <span class='n'>println</span><span class='p'>(</span><span class='n'>c</span><span class='p'>.</span><span class='n'>foo</span><span class='p'>())</span>
<span class='p'>}</span>

<span class='n'>printFoo</span><span class='p'>(</span><span class='n'>D</span><span class='p'>())</span></code></pre><p>이 예는 “C”를 출력한다. 왜냐면, 호출할 확장 함수를 선택할 때 <code>c</code> 파라미터의 선언 타입인 <code>C</code> 클래스만 사용하기 때문이다.</p><p>만약 클래스가 멤버 함수를 갖고 동일 리시버 타입을 갖는 동일 이름의 확장 함수가 있고 주어진 인자를 적용할 수 있다면 <strong>항상 멤버가 이긴다</strong>.
다음 예를 보자:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>class</span> <span class='nc'>C</span> <span class='p'>{</span>
    <span class='k'>fun</span> <span class='nf'>foo</span><span class='p'>()</span> <span class='p'>{</span> <span class='n'>println</span><span class='p'>(</span><span class='s'>&quot;member&quot;</span><span class='p'>)</span> <span class='p'>}</span>
<span class='p'>}</span>

<span class='k'>fun</span> <span class='nf'>C</span><span class='p'>.</span><span class='n'>foo</span><span class='p'>()</span> <span class='p'>{</span> <span class='n'>println</span><span class='p'>(</span><span class='s'>&quot;extension&quot;</span><span class='p'>)</span> <span class='p'>}</span></code></pre><p>타입이 <code>C</code>인 <code>c</code>에 에 대해 <code>c.foo()</code>를 호출하면, “extension”이 아닌 “member”를 출력한다..</p><h3 id='extensions.html_nullable-'>Nullable 리서버<a class='anchor' href='#%23nullable-'> </a></h3><p>nullable 리시버 타입을 정의할 수도 있다. 이 확장은 비록 객체 변수가 null이어도 호출되며 확장 함수 몸체에서 <code>this == null</code>로 검사할 수 있다.
이것이 코틀린에서 null 검사 없이 toString()을 호출할 수 있는 이유이다. 확장 함수 안에서 null 여부를 검사한다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>Any</span><span class='o'>?.</span><span class='n'>toString</span><span class='p'>():</span> <span class='n'>String</span> <span class='p'>{</span>
    <span class='k'>if</span> <span class='p'>(</span><span class='k'>this</span> <span class='p'>==</span> <span class='k'>null</span><span class='p'>)</span> <span class='k'>return</span> <span class='s'>&quot;null&quot;</span>
    <span class='c1'>// 검사 이후에 &#39;this&#39;를 non-null 타입으로 자동 변환하므로</span>
    <span class='c1'>// 다음의 toString()은 Any 클래스의 멤버 함수를 사용한다.</span>
    <span class='k'>return</span> <span class='n'>toString</span><span class='p'>()</span>
<span class='p'>}</span></code></pre><h3 id='extensions.html_section-3'>확장 프로퍼티<a class='anchor' href='#%23section-3'> </a></h3><p>함수와 유사하게 코틀린은 확장 프로퍼티를 지원한다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='err'>&lt;</span><span class='py'>T</span><span class='p'>&gt;</span> <span class='n'>List</span><span class='p'>&lt;</span><span class='n'>T</span><span class='p'>&gt;.</span><span class='n'>lastIndex</span><span class='p'>:</span> <span class='n'>Int</span>
  <span class='k'>get</span><span class='p'>()</span> <span class='p'>=</span> <span class='n'>size</span> <span class='p'>-</span> <span class='m'>1</span></code></pre><p>확장은 실제로 클래스에 멤버를 추가하지 않으므로 확장 프로퍼티가 <a href='#properties.html%23backing-fields'>backing 필드</a>를 가질 방법은 없다.
이것이 <strong>확장 프로퍼티에 대해 initializer를 허용하지 않는</strong> 이유이다. 프로퍼티 기능은 명시적으로 제공하는 getter/setter로만 가능하다.</p><p>예제:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>Foo</span><span class='p'>.</span><span class='n'>bar</span> <span class='p'>=</span> <span class='m'>1</span> <span class='c1'>// 에러: 확장 프로퍼티에 대한 initializer 허용하지 않음</span></code></pre><h3 id='extensions.html_section-4'>컴페니언 오브젝트 확장<a class='anchor' href='#%23section-4'> </a></h3><p>클래스가 <a href='#object-declarations.html%23companion-objects'>컴페니언 오브젝트</a>를 가지면, 컴페니언 오브젝트에 대해서 함수와 프로퍼티를
확장할 수 있다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>class</span> <span class='nc'>MyClass</span> <span class='p'>{</span>
  <span class='n'>companion</span> <span class='k'>object</span> <span class='err'>{ }  // &quot;</span><span class='nc'>Companion</span><span class='s'>&quot;으로 불림</span>
<span class='p'>}</span>

<span class='k'>fun</span> <span class='nf'>MyClass</span><span class='p'>.</span><span class='n'>Companion</span><span class='p'>.</span><span class='n'>foo</span><span class='p'>()</span> <span class='p'>{</span>
  <span class='c1'>// ...</span>
<span class='p'>}</span></code></pre><p>컴페니언 오브젝트의 다른 멤버처럼 클래스 이름을 사용해야 확장을 호출할 수 있다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>MyClass</span><span class='p'>.</span><span class='n'>foo</span><span class='p'>()</span></code></pre><h3 id='extensions.html_section-5'>확장의 범위<a class='anchor' href='#%23section-5'> </a></h3><p>대부분 패키지 하위의 최상위 레벨에 직접 확장을 정의한다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>package</span> <span class='nn'>foo.bar</span>

<span class='k'>fun</span> <span class='nf'>Baz</span><span class='p'>.</span><span class='n'>goo</span><span class='p'>()</span> <span class='p'>{</span> <span class='p'>...</span> <span class='p'>}</span></code></pre><p>패키지 밖에서 이런 확장을 사용하려면 사용 측에서 확장을 임포트해야 한다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>package</span> <span class='nn'>com.example.usage</span>

<span class='k'>import</span> <span class='nn'>foo.bar.goo</span> <span class='c1'>// &quot;goo&quot;의 모든 확장을 임포트</span>
                   <span class='c1'>// 또는</span>
<span class='k'>import</span> <span class='nn'>foo.bar.*</span>   <span class='c1'>// &quot;foo.bar&quot;로부터 모두 임포트</span>

<span class='k'>fun</span> <span class='nf'>usage</span><span class='p'>(</span><span class='n'>baz</span><span class='p'>:</span> <span class='n'>Baz</span><span class='p'>)</span> <span class='p'>{</span>
  <span class='n'>baz</span><span class='p'>.</span><span class='n'>goo</span><span class='p'>()</span>
<span class='p'>)</span></code></pre><p>더 많은 정보는 <a href='#packages.html%23imports'>임포트</a>를 참고한다.</p><h3 id='extensions.html_section-6'>멤버로 확장을 선언하기<a class='anchor' href='#%23section-6'> </a></h3><p>클래스 안에서 다른 클래스를 위한 확장을 선언할 수 있다. 그 확장 안에는 <em>리시버가 암묵적(implicit)</em>(한정자(qualifier) 없이 접근할 수 있는 오브젝트 멤버)가 다수 존재한다.
확장을 선언한 클래스의 인스턴스를 _디스패치(dispatch) 리시버_라 부르고, 확장 메서드의 리시버 타입 인스턴스를 _확장 리시버_라고 부른다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>class</span> <span class='nc'>D</span> <span class='p'>{</span>
    <span class='k'>fun</span> <span class='nf'>bar</span><span class='p'>()</span> <span class='p'>{</span> <span class='p'>...</span> <span class='p'>}</span>
<span class='p'>}</span>

<span class='k'>class</span> <span class='nc'>C</span> <span class='p'>{</span>
    <span class='k'>fun</span> <span class='nf'>baz</span><span class='p'>()</span> <span class='p'>{</span> <span class='p'>...</span> <span class='p'>}</span>

    <span class='k'>fun</span> <span class='nf'>D</span><span class='p'>.</span><span class='n'>foo</span><span class='p'>()</span> <span class='p'>{</span>
        <span class='n'>bar</span><span class='p'>()</span>   <span class='c1'>// D.bar 호출</span>
        <span class='n'>baz</span><span class='p'>()</span>   <span class='c1'>// C.baz 호출</span>
    <span class='p'>}</span>

    <span class='k'>fun</span> <span class='nf'>caller</span><span class='p'>(</span><span class='n'>d</span><span class='p'>:</span> <span class='n'>D</span><span class='p'>)</span> <span class='p'>{</span>
        <span class='n'>d</span><span class='p'>.</span><span class='n'>foo</span><span class='p'>()</span>   <span class='c1'>// 확장 함수 호출</span>
    <span class='p'>}</span>
<span class='p'>}</span></code></pre><p>디스패치 리시버와 확장 리시버의 멤버 이름이 충돌하면 확장 리시버가 우선한다. 디스패치 리시버의 멤버를 참조하려면
<a href='#this-expressions.html%23qualified'>한정한 <code>this</code> 구문</a>을 사용하면 된다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>class</span> <span class='nc'>C</span> <span class='p'>{</span>
    <span class='k'>fun</span> <span class='nf'>D</span><span class='p'>.</span><span class='n'>foo</span><span class='p'>()</span> <span class='p'>{</span>
        <span class='n'>toString</span><span class='p'>()</span>         <span class='c1'>// D.toString() 호출</span>
        <span class='k'>this</span><span class='n'>@C</span><span class='p'>.</span><span class='n'>toString</span><span class='p'>()</span>  <span class='c1'>// C.toString() 호출</span>
    <span class='p'>}</span></code></pre><p>멤버로 선언한 확장을 <code>open</code>으로 설정하면 하위클래스에서 오버라이딩할 수 있다. 이는 확장 함수를 디스패치 리시버 타입에 따라 선택한다는 것을
의미한다. 하지만 확장 리시버 타입은 정적이다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>open</span> <span class='k'>class</span> <span class='nc'>D</span> <span class='p'>{</span>
<span class='p'>}</span>

<span class='k'>class</span> <span class='nc'>D1</span> <span class='p'>:</span> <span class='n'>D</span><span class='p'>()</span> <span class='p'>{</span>
<span class='p'>}</span>

<span class='k'>open</span> <span class='k'>class</span> <span class='nc'>C</span> <span class='p'>{</span>
    <span class='k'>open</span> <span class='k'>fun</span> <span class='nf'>D</span><span class='p'>.</span><span class='n'>foo</span><span class='p'>()</span> <span class='p'>{</span>
        <span class='n'>println</span><span class='p'>(</span><span class='s'>&quot;D.foo in C&quot;</span><span class='p'>)</span>
    <span class='p'>}</span>

    <span class='k'>open</span> <span class='k'>fun</span> <span class='nf'>D1</span><span class='p'>.</span><span class='n'>foo</span><span class='p'>()</span> <span class='p'>{</span>
        <span class='n'>println</span><span class='p'>(</span><span class='s'>&quot;D1.foo in C&quot;</span><span class='p'>)</span>
    <span class='p'>}</span>

    <span class='k'>fun</span> <span class='nf'>caller</span><span class='p'>(</span><span class='n'>d</span><span class='p'>:</span> <span class='n'>D</span><span class='p'>)</span> <span class='p'>{</span>
        <span class='n'>d</span><span class='p'>.</span><span class='n'>foo</span><span class='p'>()</span>   <span class='c1'>// 확장 함수 호출</span>
    <span class='p'>}</span>
<span class='p'>}</span>

<span class='k'>class</span> <span class='nc'>C1</span> <span class='p'>:</span> <span class='n'>C</span><span class='p'>()</span> <span class='p'>{</span>
    <span class='k'>override</span> <span class='k'>fun</span> <span class='nf'>D</span><span class='p'>.</span><span class='n'>foo</span><span class='p'>()</span> <span class='p'>{</span>
        <span class='n'>println</span><span class='p'>(</span><span class='s'>&quot;D.foo in C1&quot;</span><span class='p'>)</span>
    <span class='p'>}</span>

    <span class='k'>override</span> <span class='k'>fun</span> <span class='nf'>D1</span><span class='p'>.</span><span class='n'>foo</span><span class='p'>()</span> <span class='p'>{</span>
        <span class='n'>println</span><span class='p'>(</span><span class='s'>&quot;D1.foo in C1&quot;</span><span class='p'>)</span>
    <span class='p'>}</span>
<span class='p'>}</span>

<span class='n'>C</span><span class='p'>().</span><span class='n'>caller</span><span class='p'>(</span><span class='n'>D</span><span class='p'>())</span>   <span class='c1'>// &quot;D.foo in C&quot; 출력</span>
<span class='n'>C1</span><span class='p'>().</span><span class='n'>caller</span><span class='p'>(</span><span class='n'>D</span><span class='p'>())</span>  <span class='c1'>// &quot;D.foo in C1&quot; 출력 - 디스패치 리시버를 버추얼하게 선택</span>
<span class='n'>C</span><span class='p'>().</span><span class='n'>caller</span><span class='p'>(</span><span class='n'>D1</span><span class='p'>())</span>  <span class='c1'>// &quot;D.foo in C&quot; 출력 - 확장 리시버를 정적으로 선택</span></code></pre><h3 id='extensions.html_section-7'>동기<a class='anchor' href='#%23section-7'> </a></h3><p>자바에서는 <code>FileUtils</code>, <code>StringUtils</code>처럼 “*Utils”라는 이름을 갖는 클래스에 익숙하다. 잘 알려진 <code>java.util.Collections</code>도 이에 속한다.
이런 유틸리티 클래스가 싫은 이유는 코드가 다음과 같은 모습을 띄기 때문이다:</p><pre><code class='code-block _highlighted lang_java'><span class='c1'>// Java</span>
<span class='n'>Collections</span><span class='o'>.</span><span class='na'>swap</span><span class='o'>(</span><span class='n'>list</span><span class='o'>,</span> <span class='n'>Collections</span><span class='o'>.</span><span class='na'>binarySearch</span><span class='o'>(</span><span class='n'>list</span><span class='o'>,</span> <span class='n'>Collections</span><span class='o'>.</span><span class='na'>max</span><span class='o'>(</span><span class='n'>otherList</span><span class='o'>)),</span> <span class='n'>Collections</span><span class='o'>.</span><span class='na'>max</span><span class='o'>(</span><span class='n'>list</span><span class='o'>))</span></code></pre><p>클래스 이름이 항상 방해가 된다. 정적 임포트를 사용하면 다음 코드가 된다:</p><pre><code class='code-block _highlighted lang_java'><span class='c1'>// Java</span>
<span class='n'>swap</span><span class='o'>(</span><span class='n'>list</span><span class='o'>,</span> <span class='n'>binarySearch</span><span class='o'>(</span><span class='n'>list</span><span class='o'>,</span> <span class='n'>max</span><span class='o'>(</span><span class='n'>otherList</span><span class='o'>)),</span> <span class='n'>max</span><span class='o'>(</span><span class='n'>list</span><span class='o'>))</span></code></pre><p>조금 나아졌지만 IDE의 강력한 코드 완성 기능의 도움을 거의 받지 못한다. 다음 코드처럼 할 수 있다면 훨씬 나을 것이다.</p><pre><code class='code-block _highlighted lang_java'><span class='c1'>// Java</span>
<span class='n'>list</span><span class='o'>.</span><span class='na'>swap</span><span class='o'>(</span><span class='n'>list</span><span class='o'>.</span><span class='na'>binarySearch</span><span class='o'>(</span><span class='n'>otherList</span><span class='o'>.</span><span class='na'>max</span><span class='o'>()),</span> <span class='n'>list</span><span class='o'>.</span><span class='na'>max</span><span class='o'>())</span></code></pre><p>하지만 <code>List</code> 클래스에 모든 가능한 메서드를 구현하는 것을 원치 않는다, 그렇지 않나? 이것이 확장이 우리를 돕는 지점이다.</p>
              </article>
          
              <article id="data-classes.html" class="page-content">
                <h2 id='data-classes.html_section'>데이터 클래스<a class='anchor' href='#%23section'> </a></h2><p>종종 데이터만 갖고 다른 건 하지 않는 클래스를 만든다. 보통 그런 클래스의 표준 기능은 데이터에서 기계적으로 만든다. 코틀린에서는 이를 _데이터 클래스_라 부르며
<code>data</code>로 데이터 클래스를 지정한다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>data</span> <span class='k'>class</span> <span class='nc'>User</span><span class='p'>(</span><span class='k'>val</span> <span class='py'>name</span><span class='p'>:</span> <span class='n'>String</span><span class='p'>,</span> <span class='k'>val</span> <span class='py'>age</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>)</span></code></pre><p>컴파일러는 주요 생성자에 정의한 모든 프로퍼티로부터 다음의 멤버를 자동으로 생성한다:</p><ul>
  <li><code>equals()</code>/<code>hashCode()</code> 쌍,</li>
  <li><code>"User(name=John, age=42)"</code> 형식의 <code>toString()</code>,</li>
  <li>프로퍼티 선언 순서에 따라 프로퍼티별로 대응하는 <a href='#multi-declarations.html'><code>componentN()</code> 함수</a>,</li>
  <li><code>copy()</code> 함수 (아래 참고).</li>
</ul><p>이 함수를 클래스 몸체에 정의하거나 베이스 타입에서 상속받을 경우 생성하지 않는다.</p><p>생성한 코드가 일관되고 의미있는 기능을 갖도록 하기 위해 데이터 클래스는 다음을 충족해야 한다:</p><ul>
  <li>주요 생성자는 최소 한 개 파라미터가 필요하다;</li>
  <li>모든 주요 생성자 파라미터는 <code>val</code>이나 <code>var</code>로 지정해야 한다;</li>
  <li>데이터 클래스는 추상, open, 실드 또는 내부(inner)일 수 없다;</li>
  <li>데이터 클래스는 다른 클래스를 확장할 수 없다(인터페이스 구현은 된다).</li>
</ul><blockquote>
  <p>JVM의 경우, 생성한 클래스가 파라미터 없는 생성자를 필요로 하면 모든 프로퍼티에 대해 기본 값을 지정해야 한다(<a href='#classes.html%23constructors'>생성자</a> 참고).</p>

  <pre><code class='code-block _highlighted lang_kotlin'><span class='n'>data</span> <span class='k'>class</span> <span class='nc'>User</span><span class='p'>(</span><span class='k'>val</span> <span class='py'>name</span><span class='p'>:</span> <span class='n'>String</span> <span class='p'>=</span> <span class='s'>&quot;&quot;</span><span class='p'>,</span> <span class='k'>val</span> <span class='py'>age</span><span class='p'>:</span> <span class='n'>Int</span> <span class='p'>=</span> <span class='m'>0</span><span class='p'>)</span></code></pre>
</blockquote><h3 id='data-classes.html_section-1'>복사<a class='anchor' href='#%23section-1'> </a></h3><p>객체를 복사할 때 종종 <em>일부</em> 프로퍼티만 변경하고 나머지는 그대로 유지하고 싶을 때가 있다. 이를 위해 <code>copy()</code> 함수를 생성한다.
앞서 <code>User</code> 클래스의 복사 구현은 다음과 같다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>copy</span><span class='p'>(</span><span class='n'>name</span><span class='p'>:</span> <span class='n'>String</span> <span class='p'>=</span> <span class='k'>this</span><span class='p'>.</span><span class='n'>name</span><span class='p'>,</span> <span class='n'>age</span><span class='p'>:</span> <span class='n'>Int</span> <span class='p'>=</span> <span class='k'>this</span><span class='p'>.</span><span class='n'>age</span><span class='p'>)</span> <span class='p'>=</span> <span class='n'>User</span><span class='p'>(</span><span class='n'>name</span><span class='p'>,</span> <span class='n'>age</span><span class='p'>)</span></code></pre><p>다음과 같이 코드를 작성할 수 있다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>jack</span> <span class='p'>=</span> <span class='n'>User</span><span class='p'>(</span><span class='n'>name</span> <span class='p'>=</span> <span class='s'>&quot;Jack&quot;</span><span class='p'>,</span> <span class='n'>age</span> <span class='p'>=</span> <span class='m'>1</span><span class='p'>)</span>
<span class='k'>val</span> <span class='py'>olderJack</span> <span class='p'>=</span> <span class='n'>jack</span><span class='p'>.</span><span class='n'>copy</span><span class='p'>(</span><span class='n'>age</span> <span class='p'>=</span> <span class='m'>2</span><span class='p'>)</span></code></pre><h3 id='data-classes.html_destructuring-declarations'>데이터 클래스와 분해 선언(Destructuring declarations)<a class='anchor' href='#%23destructuring-declarations'> </a></h3><p>데이터 클래스를 위해 생성한 _컴포넌트 함수_는 <a href='#multi-declarations.html'>분해 선언</a>에 데이터를 사용할 수 있도록 한다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>jane</span> <span class='p'>=</span> <span class='n'>User</span><span class='p'>(</span><span class='s'>&quot;Jane&quot;</span><span class='p'>,</span> <span class='m'>35</span><span class='p'>)</span>
<span class='k'>val</span> <span class='err'>(</span><span class='py'>name</span><span class='p'>,</span> <span class='n'>age</span><span class='p'>)</span> <span class='p'>=</span> <span class='n'>jane</span>
<span class='n'>println</span><span class='p'>(</span><span class='s'>&quot;$name, $age years of age&quot;</span><span class='p'>)</span> <span class='c1'>// &quot;Jane, 35 years of age&quot; 출력</span></code></pre><h3 id='data-classes.html_section-2'>표준 데이터 클래스<a class='anchor' href='#%23section-2'> </a></h3><p>표준 라이브러리는 <code>Pair</code>와 <code>Triple</code>을 제공한다. 많은 경우 이름을 갖는 데이터 클래스를 사용하는 것이 더 좋은 설계가 된다.
왜냐면, 프로퍼티를 위한 의미있는 이름을 제공함으로써 코드 가독성이 높아지기 때문이다.</p>
              </article>
          
              <article id="generics.html" class="page-content">
                <h2 id='generics.html_section'>지네릭<a class='anchor' href='#%23section'> </a></h2><p>자바처럼 코틀린 클래스도 타입 파라미터를 가질 수 있다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>class</span> <span class='nc'>Box</span><span class='p'>&lt;</span><span class='n'>T</span><span class='p'>&gt;(</span><span class='n'>t</span><span class='p'>:</span> <span class='n'>T</span><span class='p'>)</span> <span class='p'>{</span>
  <span class='k'>var</span> <span class='py'>value</span> <span class='p'>=</span> <span class='n'>t</span>
<span class='p'>}</span></code></pre><p>이 클래스의 인스턴스를 생성하려면 타입 인자를 제공해야 한다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>box</span><span class='p'>:</span> <span class='n'>Box</span><span class='p'>&lt;</span><span class='n'>Int</span><span class='p'>&gt;</span> <span class='p'>=</span> <span class='n'>Box</span><span class='p'>&lt;</span><span class='n'>Int</span><span class='p'>&gt;(</span><span class='m'>1</span><span class='p'>)</span></code></pre><p>생성자 인자나 다른 방법으로 파라미터를 유추할 수 있으면 타입 인자를 생략할 수 있다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>box</span> <span class='p'>=</span> <span class='n'>Box</span><span class='p'>(</span><span class='m'>1</span><span class='p'>)</span> <span class='c1'>// 1은 Int 타입을 가지므로 컴파일러는 Box&lt;Int&gt;라고 알아낸다</span></code></pre><h3 id='generics.html_variance'>가변(Variance)<a class='anchor' href='#%23variance'> </a></h3><p>자바 타입 시스템에서 가장 복잡한 부분 중 하나가 와일드카드 타입이다(<a href='#http%3A%2F%2Fwww.angelikalanger.com%2FGenericsFAQ%2FJavaGenericsFAQ.html'>자바 지네릭 FAQ</a> 참고).
코틀린은 어떤 것도 갖지 않는다 대신, 선언-위치 가변(declaration-site variance)과 타입 프로젝션(type projection)의 두 가지를 갖는다.</p><p>먼저 자바에서 미스테리한 와일드카드가 필요한 이유를 생각해보자. 이 문제를 <a href='#http%3A%2F%2Fwww.oracle.com%2Ftechnetwork%2Fjava%2Feffectivejava-136174.html'>Effective Java</a>,
Item 28: <em>Use bounded wildcards to increase API flexibility</em>에서 설명하고 있다.
첫째, 자바의 지네릭 타입은 <strong>무공변(invariant)</strong>이다. 이는 <code>List&lt;String&gt;</code>은 <code>List&lt;Object&gt;</code>의 하위타입이 <strong>아님</strong>을 의미한다.
왜 그랬을까? 만약 리스트가 <strong>무공변(invariant)</strong>이 아니면 자바 배열보다 나을 게 없다. 왜냐면 다음 코드가 컴파일은 되지만
런타임에 익셉션이 발생하기 때문이다:</p><pre><code class='code-block _highlighted lang_java'><span class='c1'>// Java</span>
<span class='n'>List</span><span class='o'>&lt;</span><span class='n'>String</span><span class='o'>&gt;</span> <span class='n'>strs</span> <span class='o'>=</span> <span class='k'>new</span> <span class='n'>ArrayList</span><span class='o'>&lt;</span><span class='n'>String</span><span class='o'>&gt;();</span>
<span class='n'>List</span><span class='o'>&lt;</span><span class='n'>Object</span><span class='o'>&gt;</span> <span class='n'>objs</span> <span class='o'>=</span> <span class='n'>strs</span><span class='o'>;</span> <span class='c1'>// !!! 앞에서 언급한 문제 원인이 여기 있다. 자바는 이를 금지한다!</span>
<span class='n'>objs</span><span class='o'>.</span><span class='na'>add</span><span class='o'>(</span><span class='mi'>1</span><span class='o'>);</span> <span class='c1'>// 여기서 String의 리스트에 Integer를 넣는다</span>
<span class='n'>String</span> <span class='n'>s</span> <span class='o'>=</span> <span class='n'>strs</span><span class='o'>.</span><span class='na'>get</span><span class='o'>(</span><span class='mi'>0</span><span class='o'>);</span> <span class='c1'>// !!! ClassCastException: Integer를 String으로 변환할 수 없다</span></code></pre><p>그래서 자바는 런타임 안정성을 보장하기 위해 이런 것을 금지했다. 하지만 이는 몇 가지 영향을 준다. 예를 들어 <code>Collection</code> 인터페이스의 <code>addAll()</code> 메서드를 생각해보자.
이 메서드의 시그너처는 무엇인가? 직관적으로 다음과 같이 작성할 수 있다:</p><pre><code class='code-block _highlighted lang_java'><span class='c1'>// Java</span>
<span class='kd'>interface</span> <span class='nc'>Collection</span><span class='o'>&lt;</span><span class='n'>E</span><span class='o'>&gt;</span> <span class='o'>...</span> <span class='o'>{</span>
  <span class='kt'>void</span> <span class='nf'>addAll</span><span class='o'>(</span><span class='n'>Collection</span><span class='o'>&lt;</span><span class='n'>E</span><span class='o'>&gt;</span> <span class='n'>items</span><span class='o'>);</span>
<span class='o'>}</span></code></pre><p>하지만 (완벽하게 안전한 코드임에도) 다음의 간단한 코드를 만들 수 없다:</p><pre><code class='code-block _highlighted lang_java'><span class='c1'>// Java</span>
<span class='kt'>void</span> <span class='nf'>copyAll</span><span class='o'>(</span><span class='n'>Collection</span><span class='o'>&lt;</span><span class='n'>Object</span><span class='o'>&gt;</span> <span class='n'>to</span><span class='o'>,</span> <span class='n'>Collection</span><span class='o'>&lt;</span><span class='n'>String</span><span class='o'>&gt;</span> <span class='n'>from</span><span class='o'>)</span> <span class='o'>{</span>
  <span class='n'>to</span><span class='o'>.</span><span class='na'>addAll</span><span class='o'>(</span><span class='n'>from</span><span class='o'>);</span> <span class='c1'>// !!! addAll의 단순한 선언으로는 컴파일되지 않는다:</span>
                   <span class='c1'>//       Collection&lt;String&gt;은 Collection&lt;Object&gt;의 하위 타입이 아니다</span>
<span class='o'>}</span></code></pre><p>(우리는 이를 힘들게 배웠다. <a href='#http%3A%2F%2Fwww.oracle.com%2Ftechnetwork%2Fjava%2Feffectivejava-136174.html'>Effective Java</a>, Item 25:
<em>Prefer lists to arrays</em>를 참고하자.)</p><p>이런 이유로 실제 <code>addAll()</code> 시그너처는 다음과 같다:</p><pre><code class='code-block _highlighted lang_java'><span class='c1'>// Java</span>
<span class='kd'>interface</span> <span class='nc'>Collection</span><span class='o'>&lt;</span><span class='n'>E</span><span class='o'>&gt;</span> <span class='o'>...</span> <span class='o'>{</span>
  <span class='kt'>void</span> <span class='nf'>addAll</span><span class='o'>(</span><span class='n'>Collection</span><span class='o'>&lt;?</span> <span class='kd'>extends</span> <span class='n'>E</span><span class='o'>&gt;</span> <span class='n'>items</span><span class='o'>);</span>
<span class='o'>}</span></code></pre><p><strong>와일드카드 타입 인자</strong> <code>? extends E</code>는 이 메서드가 <code>E</code> 자체가 아닌 <code>E</code>의 <em>하위타입</em>의 객체 콜렉션을 허용한다는 것을 말한다.
이는 items에서 안전하게 <code>E</code>로 <strong>읽을</strong> 수 있지만(이 콜렉션의 요소는 E의 하위클래스의 인스턴스이다),
<code>E</code>의 어떤 하위타입인지 모르기 때문에 items에 <strong>쓸 수 없다</strong>는 것을 의미한다.
이런 제한을 해소하기 위해 <code>Collection&lt;String&gt;</code>이 <code>Collection&lt;? extends Object&gt;</code>의 하위타입이 되도록 기능을 추가했다.
“전문 용어”로 <strong>extends</strong>-bound(<strong>upper</strong> bound)를 갖는 와일드카드를 사용해서 타입을 <strong>공변(convariant)</strong>으로 만들었다.</p><p>이 트릭이 왜 작동하는지 이해하는데 있어 핵심은 다소 단순하다: 만약 콜렉션에서 아이템을 <strong>가져올</strong> 수만 있다면 <code>String</code> 콜렉션에서 <code>Object</code>를 읽는 것은 괜찮다.
역으로 콜렉션에 항목을 <em>넣을</em> 수만 있다면 <code>Object</code> 콜렉션에 <code>String</code>을 넣는 건 괜찮다.
자바에서 <code>List&lt;? super String&gt;</code>가 <code>List&lt;Object&gt;</code>의 <strong>상위타입</strong>이 된다.</p><p>후자를 <strong>반공변(contravariance)</strong>이라 부르며, <code>List&lt;? super String&gt;</code>에 인자로 String을 받는 메서드만 호출할 수 있다(예를 들어,
  <code>add(String)</code>이나 <code>set(int, String)</code>을 호출할 수 있다).
반면에, <code>List&lt;T&gt;</code>에서 <code>T</code>를 리턴하는 어떤 것을 호출하면 <code>String</code>이 아닌 <code>Object</code>를 얻게 된다.</p><p>Joshua Blochs는 이 객체는 <strong>Producer</strong>에서만 <strong>읽을</strong> 수 있고, <strong>Consumer</strong>로만 <strong>쓸</strong> 수 있다고 했다.
Joshua Blochs는 “<em>유연함을 최대한 얻으려면 producer나 consumer를 표현하는 입력 파라미터에 와일드카드 타입을 사용하라</em>“고 권하고 있으며,
다음과 같이 기억을 쉽게 할 수 있는 약자를 제시했다.</p><p><em>PECS는 Producer-Extends, Consumer-Super를 의미한다.</em></p><p><em>주의</em>: producer 객체를 사용한다면, 예를 들어 <code>List&lt;? extends Foo&gt;</code>, 이 객체에 대해 <code>add()</code>나 <code>set()</code>을 호출하는 것을 허용하지 않지만,
이것이 이 객체가 <strong>불변(immutable)</strong>인 것을 의미하는 것은 아니다. 예를 들어, 리스트의 모든 항목을 삭제하기 위해 <code>clear()</code>를 호출하는 것은 가능하다.
왜냐면, <code>clear()</code>는 어떤 파라미터도 갖지 않기 때문이다. 와일드카드(또는 다른 종류의 가변variance)가 보장하는 것은 <strong>타입 안정성</strong>이다. 불변은 완전히 다른 얘기다.</p><h4 id='generics.html_declaration-site-variance'>선언-위치 가변(Declaration-site variance)<a class='anchor' href='#%23declaration-site-variance'> </a></h4><p><code>Source&lt;T&gt;</code> 지네릭 인터페이스에 <code>T</code>를 파라미터로 갖는 메서드는 없고 단지 <code>T</code>를 리턴하는 메서드만 있다고 하자:</p><pre><code class='code-block _highlighted lang_java'><span class='c1'>// Java</span>
<span class='kd'>interface</span> <span class='nc'>Source</span><span class='o'>&lt;</span><span class='n'>T</span><span class='o'>&gt;</span> <span class='o'>{</span>
  <span class='n'>T</span> <span class='nf'>nextT</span><span class='o'>();</span>
<span class='o'>}</span></code></pre><p>이때 <code>Source&lt;Object&gt;</code> 타입 변수에 <code>Source&lt;String&gt;</code> 인스턴스를 할당하는 것은 완전히 안전한 것이다. 여기엔 어떤 consumer 메서드도 호출하지 않는다.
하지만 자바는 이를 알지 못하기 때문에 이를 금지한다.</p><pre><code class='code-block _highlighted lang_java'><span class='c1'>// Java</span>
<span class='kt'>void</span> <span class='nf'>demo</span><span class='o'>(</span><span class='n'>Source</span><span class='o'>&lt;</span><span class='n'>String</span><span class='o'>&gt;</span> <span class='n'>strs</span><span class='o'>)</span> <span class='o'>{</span>
  <span class='n'>Source</span><span class='o'>&lt;</span><span class='n'>Object</span><span class='o'>&gt;</span> <span class='n'>objects</span> <span class='o'>=</span> <span class='n'>strs</span><span class='o'>;</span> <span class='c1'>// !!! 자바는 허용하지 않음</span>
  <span class='c1'>// ...</span>
<span class='o'>}</span></code></pre><p>이 문제를 고치려면 <code>Source&lt;? extends Object&gt;</code> 타입 객체를 선언해야 하는데, 이는 다소 의미가 없다. 왜냐면, 전과 같이 그런 변수에 동일하게 메서드를 호출할 수 있기 때문에, 더 복잡한 타입에 값을 추가하지 않기 때문이다. 하지만, 컴파일러는 이를 알지 못한다.
To fix this, we have to declare objects of type <code>Source&lt;? extends Object&gt;</code>, which is sort of meaningless, because we can call all the same methods on such a variable as before, so there’s no value added by the more complex type. But the compiler does not know that.</p><p>코틀린은 컴파일러에 이런 류의 내용을 설명하는 방법이 존재한다. 이를 <strong>선언-위치 가변(declaration-site variance)</strong>이라고 부른다. 소스 코드의 <strong>타입 파라미터</strong> <code>T</code>에 애노테이션을 붙여서 <code>Source&lt;T&gt;</code>의 멤버가 <strong>리턴</strong>(생성)만 하고 소비(consume)하지 않는다고 할 수 있다.
이를 위해 <strong>out</strong> 제한자를 제공한다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>abstract</span> <span class='k'>class</span> <span class='nc'>Source</span><span class='p'>&lt;</span><span class='k'>out</span> <span class='n'>T</span><span class='p'>&gt;</span> <span class='p'>{</span>
  <span class='k'>abstract</span> <span class='k'>fun</span> <span class='nf'>nextT</span><span class='p'>():</span> <span class='n'>T</span>
<span class='p'>}</span>

<span class='k'>fun</span> <span class='nf'>demo</span><span class='p'>(</span><span class='n'>strs</span><span class='p'>:</span> <span class='n'>Source</span><span class='p'>&lt;</span><span class='n'>String</span><span class='p'>&gt;)</span> <span class='p'>{</span>
  <span class='k'>val</span> <span class='py'>objects</span><span class='p'>:</span> <span class='n'>Source</span><span class='p'>&lt;</span><span class='n'>Any</span><span class='p'>&gt;</span> <span class='p'>=</span> <span class='n'>strs</span> <span class='c1'>// T는 out 파라미터이므로 OK</span>
  <span class='c1'>// ...</span>
<span class='p'>}</span></code></pre><p>일반 규칙: 클래스 <code>C</code>의 타입 파라미터 <code>T</code>를 <strong>out</strong>으로 선언하면 타입 파라미터는 오직 <code>C</code> 멤버의 <strong>out</strong>-위치에만 올 수 있다. 하지만 리턴에서 <code>C&lt;Base&gt;</code>는 안전하게 <code>C&lt;Derived&gt;</code>의 상위타입이 될 수 있다.</p><p>“전문 용어”로 클래스 <code>C</code>는 파라미터 <code>T</code>에 <strong>공변(covariant)</strong> 하다 또는 <code>T</code>는 <strong>공변(covariant)</strong> 타입 파라미터라고 말한다.
<code>C</code>를 <code>T</code>의 <strong>consumer</strong>가 아닌 T`의 <strong>producer</strong>로 생각할 수 있다.</p><p><strong>out</strong> 제한자는 <strong>가변(variance) 애노테이션</strong>이라 부르며, 타입 파라미터 선언 위치에 제공하기 때문에 <strong>선언-위치 가변(declaration-site variance)</strong>에 대한 것이다.
이는 자바가 타입을 사용할 때 와일드카드로 타입을 공변(covariant)하게 만드는 <strong>사용-위치 가변(use-site variance)</strong>인 것과 다르다.</p><p><strong>out</strong>과 더불어 코틀린은 대체 가변(variance) 애노테이션인 <strong>in</strong>을 제공한다. <strong>in</strong>은 타입 파라미터를 <strong>반공변(contravariant)</strong>으로 만들어 준다. 이는 오직 consume만 될 수 있으며
produce 할 수 없다. 반공변(contravariant) 클래스의 좋은 예가 <code>Comparable</code>이다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>abstract</span> <span class='k'>class</span> <span class='nc'>Comparable</span><span class='p'>&lt;</span><span class='k'>in</span> <span class='n'>T</span><span class='p'>&gt;</span> <span class='p'>{</span>
  <span class='k'>abstract</span> <span class='k'>fun</span> <span class='nf'>compareTo</span><span class='p'>(</span><span class='n'>other</span><span class='p'>:</span> <span class='n'>T</span><span class='p'>):</span> <span class='n'>Int</span>
<span class='p'>}</span>

<span class='k'>fun</span> <span class='nf'>demo</span><span class='p'>(</span><span class='n'>x</span><span class='p'>:</span> <span class='n'>Comparable</span><span class='p'>&lt;</span><span class='n'>Number</span><span class='p'>&gt;)</span> <span class='p'>{</span>
  <span class='n'>x</span><span class='p'>.</span><span class='n'>compareTo</span><span class='p'>(</span><span class='m'>1.0</span><span class='p'>)</span> <span class='c1'>// 1.0은 Number의 상위 타입은 Double 타입을 갖는다</span>
  <span class='c1'>// 그래서, Comparable&lt;Double&gt; 타입 변수를 x에 할당할 수 있다</span>
  <span class='k'>val</span> <span class='py'>y</span><span class='p'>:</span> <span class='n'>Comparable</span><span class='p'>&lt;</span><span class='n'>Double</span><span class='p'>&gt;</span> <span class='p'>=</span> <span class='n'>x</span> <span class='c1'>// OK!</span>
<span class='p'>}</span></code></pre><p>단어 <strong>in</strong>과 <strong>out</strong>이 자명하므로(이미 꽤 오랜 시간 C#에서 성공적으로 사용하고 있다)
위에서 언급한 기억하기 위한 PECS가 실제로 필요 없고 더 상위 목표를 위해 바깔 수 있다고 생각한다:</p><p><strong><a href='#http%3A%2F%2Fen.wikipedia.org%2Fwiki%2FExistentialism'>실존주의</a> 변환: Consumer in, Producer out!</strong> :-)</p><h3 id='generics.html_type-projections'>타입 프로젝션(Type projections)<a class='anchor' href='#%23type-projections'> </a></h3><h4 id='generics.html_use-site-variance--'>사용-위치 가변(Use-site variance): 타입 프로젝션<a class='anchor' href='#%23use-site-variance--'> </a></h4><p>타입 파라미터 T를 <em>out</em>으로 선언하는 것은 매우 편리하며, 사용 위치에서 하위타입 관련 문제가 없다.
좋다. 그런데 문제의 클래스를 <code>T</code>만 리턴하도록 실제로 제약할 수 있을 때, 그것으로 못하는 건 무얼까?
Array가 좋은 예이다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>class</span> <span class='nc'>Array</span><span class='p'>&lt;</span><span class='n'>T</span><span class='p'>&gt;(</span><span class='k'>val</span> <span class='py'>size</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>)</span> <span class='p'>{</span>
  <span class='k'>fun</span> <span class='nf'>get</span><span class='p'>(</span><span class='n'>index</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>):</span> <span class='n'>T</span> <span class='p'>{</span> <span class='cm'>/* ... */</span> <span class='p'>}</span>
  <span class='k'>fun</span> <span class='nf'>set</span><span class='p'>(</span><span class='n'>index</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>,</span> <span class='n'>value</span><span class='p'>:</span> <span class='n'>T</span><span class='p'>)</span> <span class='p'>{</span> <span class='cm'>/* ... */</span> <span class='p'>}</span>
<span class='p'>}</span></code></pre><p>이 클래스는 <code>T</code>에 대해 공변(covariant)도 반공변(contravariant)도 될 수 없다. 게다가 유연하지 않는 부분을 강제한다. 다음 함수를 보자:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>copy</span><span class='p'>(</span><span class='n'>from</span><span class='p'>:</span> <span class='n'>Array</span><span class='p'>&lt;</span><span class='n'>Any</span><span class='p'>&gt;,</span> <span class='n'>to</span><span class='p'>:</span> <span class='n'>Array</span><span class='p'>&lt;</span><span class='n'>Any</span><span class='p'>&gt;)</span> <span class='p'>{</span>
  <span class='n'>assert</span><span class='p'>(</span><span class='n'>from</span><span class='p'>.</span><span class='n'>size</span> <span class='p'>==</span> <span class='n'>to</span><span class='p'>.</span><span class='n'>size</span><span class='p'>)</span>
  <span class='k'>for</span> <span class='p'>(</span><span class='n'>i</span> <span class='k'>in</span> <span class='n'>from</span><span class='p'>.</span><span class='n'>indices</span><span class='p'>)</span>
    <span class='n'>to</span><span class='p'>[</span><span class='n'>i</span><span class='p'>]</span> <span class='p'>=</span> <span class='n'>from</span><span class='p'>[</span><span class='n'>i</span><span class='p'>]</span>
<span class='p'>}</span></code></pre><p>이 함수는 한 배열에서 다른 배열로 항목을 복사한다. 실제로 함수 실행을 시도해보자:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>ints</span><span class='p'>:</span> <span class='n'>Array</span><span class='p'>&lt;</span><span class='n'>Int</span><span class='p'>&gt;</span> <span class='p'>=</span> <span class='n'>arrayOf</span><span class='p'>(</span><span class='m'>1</span><span class='p'>,</span> <span class='m'>2</span><span class='p'>,</span> <span class='m'>3</span><span class='p'>)</span>
<span class='k'>val</span> <span class='py'>any</span> <span class='p'>=</span> <span class='n'>Array</span><span class='p'>&lt;</span><span class='n'>Any</span><span class='p'>&gt;(</span><span class='m'>3</span><span class='p'>)</span>
<span class='n'>copy</span><span class='p'>(</span><span class='n'>ints</span><span class='p'>,</span> <span class='n'>any</span><span class='p'>)</span> <span class='c1'>// 에러: expects (Array&lt;Any&gt;, Array&lt;Any&gt;)</span></code></pre><p>여기서 익숙한 문제가 발생한다. <code>Array&lt;T&gt;</code>는 <code>T</code>에 대해 <strong>무공변(invariant)</strong>하므로 <code>Array&lt;Int&gt;</code>와 <code>Array&lt;Any&gt;</code>는 서로 상대방의 하위타입이 아니다.
왜 그럴까? copy는 나쁜 짓을 <strong>할지 모르기</strong> 때문이다. 예를 들어, String을 <code>from</code>에 <strong>쓰려고</strong> 시도하는데 실제로 <code>from</code>에 <code>Int</code> 배열을 전달했다면,
나중에 <code>ClassCastException</code>이 발생할 수 있다.</p><p>여기서 우리가 원하는 것은 <code>copy()</code>가 그런 나쁜 짓을 하지 않는 것을 보장하는 것이다. 우리는 이 메서드가 <code>from</code>에 <strong>쓰지</strong> 못하도록 막길 원하며, 다음과 같이 이를 할 수 있다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>copy</span><span class='p'>(</span><span class='n'>from</span><span class='p'>:</span> <span class='n'>Array</span><span class='p'>&lt;</span><span class='k'>out</span> <span class='n'>Any</span><span class='p'>&gt;,</span> <span class='n'>to</span><span class='p'>:</span> <span class='n'>Array</span><span class='p'>&lt;</span><span class='n'>Any</span><span class='p'>&gt;)</span> <span class='p'>{</span>
 <span class='c1'>// ...</span>
<span class='p'>}</span></code></pre><p>여기서 발생한 것을 <strong>타임 프로젝션(type projection)</strong>이라고 한다. 이 코드에서 <code>from</code>은 단순 배열이 아닌 <strong>제한된(projected)</strong> 배열이다. 오직 타입 파라미터 <code>T</code>를 리턴하는 메서드만 호출할 수 있다.
이 예의 경우 <code>get()</code>만 호출할 수 있다. 이것이 코틀린의 <strong>사용-위치 가변(use-site variance)</strong> 접근 방식이다. 자바의 <code>Array&lt;? extends Object&gt;</code>에 해당하지만 더 간단한 방법이다.</p><p><strong>in</strong>을 이용해서 타입을 프로젝션할 수 있다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>fill</span><span class='p'>(</span><span class='n'>dest</span><span class='p'>:</span> <span class='n'>Array</span><span class='p'>&lt;</span><span class='k'>in</span> <span class='n'>String</span><span class='p'>&gt;,</span> <span class='n'>value</span><span class='p'>:</span> <span class='n'>String</span><span class='p'>)</span> <span class='p'>{</span>
  <span class='c1'>// ...</span>
<span class='p'>}</span></code></pre><p><code>Array&lt;in String&gt;</code>은 자바의 <code>Array&lt;? super String&gt;</code>에 해당하며 <code>CharSequence</code>의 배열이나 <code>Object</code>의 배열을 <code>fill()</code> 함수에 전달할 수 있다.</p><h4 id='generics.html_section-1'>스타-프로젝션<a class='anchor' href='#%23section-1'> </a></h4><p>때때로 타입 인자에 대해 알지 못하지만 안전한 방법으로 인자를 사용하고 싶을 때가 있다.
여기서 안전한 방법은 지네릭 타입에 그런 프로젝션을 정의해서, 지네릭 타입의 모든 컨크리트 인스턴스가 그 프로젝션의 하위 타입이 되도록 하는 것이다.</p><p>코틀린은 이를 위해 <strong>스타-프로젝션(star-projection)</strong>이라 불리는 구문을 제공한다:</p><ul>
  <li><code>Foo&lt;out T&gt;</code>에 대해, <code>T</code>가 uppber bound <code>TUpper</code>를 갖는 공변(covariant) 타입 파라미터라면 <code>Foo&lt;*&gt;</code>은 <code>Foo&lt;out TUpper&gt;</code>와 같다. 이는 <code>T</code>를 몰라도 안전하게 <code>Foo&lt;*&gt;</code>에서 <code>TUpper</code> 값을 <em>읽을</em> 수 있다는 것을 의미한다.</li>
  <li><code>Foo&lt;in T&gt;</code>에 대해, <code>T</code>가 반공변(contravariant) 타입 파라미터라면 <code>Foo&lt;*&gt;</code>는 <code>Foo&lt;in Nothing&gt;</code>와 같다. 이는 <code>T</code>를 모를 때 안전하게 <code>Foo&lt;*&gt;</code>에 <em>쓸 수 없다는</em> 것을 의미한다.</li>
  <li><code>Foo&lt;T&gt;</code>에 대해, <code>T</code>가 uppber bound <code>TUpper</code>를 갖는 무공변(invariant) 타입 파라미터라면, <code>Foo&lt;*&gt;</code>는 값을 읽을 때는 <code>Foo&lt;out TUpper&gt;</code>와 동일하고 값을 쓸 때는 <code>Foo&lt;in Nothing&gt;</code>와 동일하다.</li>
</ul><p>지네릭 타입이 여러 타입 파라미터를 가질 경우 각각 독립적으로 프로젝션할 수 있다.
예를 들어, <code>interface Function&lt;in T, out U&gt;</code> 타입을 정의하면, 다음의 스타-프로젝션을 생각할 수 있다:</p><ul>
  <li><code>Function&lt;*, String&gt;</code>은 <code>Function&lt;in Nothing, String&gt;</code>을 의미한다;</li>
  <li><code>Function&lt;Int, *&gt;</code>은 <code>Function&lt;Int, out Any?&gt;</code>를 의미한다;</li>
  <li><code>Function&lt;*, *&gt;</code>은 <code>Function&lt;in Nothing, out Any?&gt;</code>을 의미한다.</li>
</ul><p><em>주의</em>: 스타-프로젝션은 자바의 raw 타입과 매우 유사하지만 안전하다.</p><h2 id='generics.html_section-2'>지네릭 함수<a class='anchor' href='#%23section-2'> </a></h2><p>클래스만 타입 파라미터를 가질 수 있는 건 아니다. 함수도 가질 수 있다. 함수 이름 앞에 타입 파라미터를 위치시키면 된다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='err'>&lt;</span><span class='nf'>T</span><span class='p'>&gt;</span> <span class='n'>singletonList</span><span class='p'>(</span><span class='n'>item</span><span class='p'>:</span> <span class='n'>T</span><span class='p'>):</span> <span class='n'>List</span><span class='p'>&lt;</span><span class='n'>T</span><span class='p'>&gt;</span> <span class='p'>{</span>
  <span class='c1'>// ...</span>
<span class='p'>}</span>

<span class='k'>fun</span> <span class='err'>&lt;</span><span class='nf'>T</span><span class='p'>&gt;</span> <span class='n'>T</span><span class='p'>.</span><span class='n'>basicToString</span><span class='p'>()</span> <span class='p'>:</span> <span class='n'>String</span> <span class='p'>{</span>  <span class='c1'>// 확장 함수</span>
  <span class='c1'>// ...</span>
<span class='p'>}</span></code></pre><p>타입 파라미터를 호출 위치(call site)에서 명시적으로 전달하려면 함수 이름 <strong>뒤에</strong> 지정한다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>l</span> <span class='p'>=</span> <span class='n'>singletonList</span><span class='p'>&lt;</span><span class='n'>Int</span><span class='p'>&gt;(</span><span class='m'>1</span><span class='p'>)</span></code></pre><h2 id='generics.html_section-3'>지네릭 제약<a class='anchor' href='#%23section-3'> </a></h2><p>주어진 타입 파라미터를 교체하는 모든 가능한 타입은 <strong>지네릭 제약</strong>에 따라 제한된다.</p><h3 id='generics.html_upper-bounds'>Upper bounds<a class='anchor' href='#%23upper-bounds'> </a></h3><p>가장 일반적인 제약은 자바의 <em>extends</em> 키워드에 해당하는 <strong>upper bound</strong>이다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='err'>&lt;</span><span class='nf'>T</span> <span class='p'>:</span> <span class='n'>Comparable</span><span class='p'>&lt;</span><span class='n'>T</span><span class='p'>&gt;&gt;</span> <span class='n'>sort</span><span class='p'>(</span><span class='n'>list</span><span class='p'>:</span> <span class='n'>List</span><span class='p'>&lt;</span><span class='n'>T</span><span class='p'>&gt;)</span> <span class='p'>{</span>
  <span class='c1'>// ...</span>
<span class='p'>}</span></code></pre><p>콜론 뒤에 지정한 타입이 <strong>upper bound</strong>이다. <code>Comparable&lt;T&gt;</code>의 하위타입만 <code>T</code>를 대체할 수 있다. 다음 예를 보자.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>sort</span><span class='p'>(</span><span class='n'>listOf</span><span class='p'>(</span><span class='m'>1</span><span class='p'>,</span> <span class='m'>2</span><span class='p'>,</span> <span class='m'>3</span><span class='p'>))</span> <span class='c1'>// OK. Int는 Comparable&lt;Int&gt;의 하위타입이다.</span>
<span class='n'>sort</span><span class='p'>(</span><span class='n'>listOf</span><span class='p'>(</span><span class='n'>HashMap</span><span class='p'>&lt;</span><span class='n'>Int</span><span class='p'>,</span> <span class='n'>String</span><span class='p'>&gt;()))</span> <span class='c1'>// 에러: HashMap&lt;Int, String&gt;은 Comparable&lt;HashMap&lt;Int, String&gt;&gt;의 하위타입이 아니다.</span></code></pre><p>지정하지 않을 경우 기본 upper bound는 <code>Any?</code>이다. 화살괄호 안에 오직 한 개의 upper bound만 지정할 수 있다.
동일 타입 파라미터에 대해 한 개 이상의 upper bound가 필요하면, 별도의 <strong>where</strong>-절을 사용해야 한다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='err'>&lt;</span><span class='nf'>T</span><span class='p'>&gt;</span> <span class='n'>cloneWhenGreater</span><span class='p'>(</span><span class='n'>list</span><span class='p'>:</span> <span class='n'>List</span><span class='p'>&lt;</span><span class='n'>T</span><span class='p'>&gt;,</span> <span class='n'>threshold</span><span class='p'>:</span> <span class='n'>T</span><span class='p'>):</span> <span class='n'>List</span><span class='p'>&lt;</span><span class='n'>T</span><span class='p'>&gt;</span>
    <span class='k'>where</span> <span class='n'>T</span> <span class='p'>:</span> <span class='n'>Comparable</span><span class='p'>,</span>
          <span class='n'>T</span> <span class='p'>:</span> <span class='n'>Cloneable</span> <span class='p'>{</span>
  <span class='k'>return</span> <span class='n'>list</span><span class='p'>.</span><span class='n'>filter</span> <span class='p'>{</span> <span class='n'>it</span> <span class='p'>&gt;</span> <span class='n'>threshold</span> <span class='p'>}.</span><span class='n'>map</span> <span class='p'>{</span> <span class='n'>it</span><span class='p'>.</span><span class='n'>clone</span><span class='p'>()</span> <span class='p'>}</span>
<span class='p'>}</span></code></pre>
              </article>
          
              <article id="nested-classes.html" class="page-content">
                <h2 id='nested-classes.html_nested-'>중첩(Nested) 클래스<a class='anchor' href='#%23nested-'> </a></h2><p>다른 클래스에 클래스를 중첩할 수 있다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>class</span> <span class='nc'>Outer</span> <span class='p'>{</span>
  <span class='k'>private</span> <span class='k'>val</span> <span class='py'>bar</span><span class='p'>:</span> <span class='n'>Int</span> <span class='p'>=</span> <span class='m'>1</span>
  <span class='k'>class</span> <span class='nc'>Nested</span> <span class='p'>{</span>
    <span class='k'>fun</span> <span class='nf'>foo</span><span class='p'>()</span> <span class='p'>=</span> <span class='m'>2</span>
  <span class='p'>}</span>
<span class='p'>}</span>

<span class='k'>val</span> <span class='py'>demo</span> <span class='p'>=</span> <span class='n'>Outer</span><span class='p'>.</span><span class='n'>Nested</span><span class='p'>().</span><span class='n'>foo</span><span class='p'>()</span> <span class='c1'>// == 2</span></code></pre><h3 id='nested-classes.html_inner-'>내부(Inner) 클래스<a class='anchor' href='#%23inner-'> </a></h3><p><em class='keyword'>inner</em>로 지정하면 외부(outer) 클래스의 멤버로 클래스에 접근할 수 있다. 내부 클래스는 외부 클래스 객체에 대한 레퍼런스를 갖는다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>class</span> <span class='nc'>Outer</span> <span class='p'>{</span>
  <span class='k'>private</span> <span class='k'>val</span> <span class='py'>bar</span><span class='p'>:</span> <span class='n'>Int</span> <span class='p'>=</span> <span class='m'>1</span>
  <span class='k'>inner</span> <span class='k'>class</span> <span class='nc'>Inner</span> <span class='p'>{</span>
    <span class='k'>fun</span> <span class='nf'>foo</span><span class='p'>()</span> <span class='p'>=</span> <span class='n'>bar</span>
  <span class='p'>}</span>
<span class='p'>}</span>

<span class='k'>val</span> <span class='py'>demo</span> <span class='p'>=</span> <span class='n'>Outer</span><span class='p'>().</span><span class='n'>Inner</span><span class='p'>().</span><span class='n'>foo</span><span class='p'>()</span> <span class='c1'>// == 1</span></code></pre><p>내부 클래스에서 <em class='keyword'>this</em> 사용시 모호함에 대한 내용은 <a href='#this-expressions.html'>한정된 <em class='keyword'>this</em> 식</a>을 참고한다.</p>
              </article>
          
              <article id="enum-classes.html" class="page-content">
                <h2 id='enum-classes.html_enum-'>Enum 클래스<a class='anchor' href='#%23enum-'> </a></h2><p>enum 클래스의 기본 용법은 타입에 안전한 열거형을 구현하는 것이다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>enum</span> <span class='k'>class</span> <span class='nc'>Direction</span> <span class='p'>{</span>
  <span class='n'>NORTH</span><span class='p'>,</span> <span class='n'>SOUTH</span><span class='p'>,</span> <span class='n'>WEST</span><span class='p'>,</span> <span class='n'>EAST</span>
<span class='p'>}</span></code></pre><p>각 열거 상수는 객체이다. 열거 상수는 콤마로 구분한다.</p><h3 id='enum-classes.html_section'>초기화<a class='anchor' href='#%23section'> </a></h3><p>각 열거 상수는 enum 클래스의 인스턴스이므로 초기화할 수 있다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>enum</span> <span class='k'>class</span> <span class='nc'>Color</span><span class='p'>(</span><span class='k'>val</span> <span class='py'>rgb</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>)</span> <span class='p'>{</span>
    <span class='n'>RED</span><span class='p'>(</span><span class='m'>0</span><span class='n'>xFF0000</span><span class='p'>),</span>
    <span class='n'>GREEN</span><span class='p'>(</span><span class='m'>0</span><span class='n'>x00FF00</span><span class='p'>),</span>
    <span class='n'>BLUE</span><span class='p'>(</span><span class='m'>0</span><span class='n'>x0000FF</span><span class='p'>)</span>
<span class='p'>}</span></code></pre><h3 id='enum-classes.html_section-1'>임의 클래스<a class='anchor' href='#%23section-1'> </a></h3><p>열거 상수는 임의 클래스를 이용해서 개별 선언할 수 있다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>enum</span> <span class='k'>class</span> <span class='nc'>ProtocolState</span> <span class='p'>{</span>
  <span class='n'>WAITING</span> <span class='p'>{</span>
    <span class='k'>override</span> <span class='k'>fun</span> <span class='nf'>signal</span><span class='p'>()</span> <span class='p'>=</span> <span class='n'>TALKING</span>
  <span class='p'>},</span>

  <span class='n'>TALKING</span> <span class='p'>{</span>
    <span class='k'>override</span> <span class='k'>fun</span> <span class='nf'>signal</span><span class='p'>()</span> <span class='p'>=</span> <span class='n'>WAITING</span>
  <span class='p'>};</span>

  <span class='k'>abstract</span> <span class='k'>fun</span> <span class='nf'>signal</span><span class='p'>():</span> <span class='n'>ProtocolState</span>
<span class='p'>}</span></code></pre><p>베이스 메서드를 오버라이딩하는 것 외에 상응하는 메서드를 가질 수 있다.
enum 클래스가 멤버를 정의하면 자바처럼 세미콜론을 이용해서 멤버 정의와 enum 상수 정의를 구분해야 한다.</p><h3 id='enum-classes.html_enum--'>enum 상수로 작업하기<a class='anchor' href='#%23enum--'> </a></h3><p>자바와 마찬가지로 enum 클래스는 정의한 enum 상수 목록을 구하고 이름으로 enum 상수에 접근할 수 있는
메서드를 제공하고 있다. 이 메서드의 시그너처는 다음과 같다(enum 클래스의 이름이 <code>EnumClass</code>라고 가정):</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>EnumClass</span><span class='p'>.</span><span class='n'>valueOf</span><span class='p'>(</span><span class='n'>value</span><span class='p'>:</span> <span class='n'>String</span><span class='p'>):</span> <span class='n'>EnumClass</span>
<span class='n'>EnumClass</span><span class='p'>.</span><span class='n'>values</span><span class='p'>():</span> <span class='n'>Array</span><span class='p'>&lt;</span><span class='n'>EnumClass</span><span class='p'>&gt;</span></code></pre><p><code>valueOf()</code> 메서드는 지정한 이름에 해당하는 enum 상수가 없으면 <code>IllegalArgumentException</code>을 발생한다.</p><p>모든 enum 상수는 상수의 이름과 enum 클래스에 정의된 순서를 구할 수 있는 프로퍼티를 갖는다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>name</span><span class='p'>:</span> <span class='n'>String</span>
<span class='k'>val</span> <span class='py'>ordinal</span><span class='p'>:</span> <span class='n'>Int</span></code></pre><p>enum 상수는 또한 <a href='#%2Fapi%2Flatest%2Fjvm%2Fstdlib%2Fkotlin%2F-comparable%2Findex.html'>Comparable</a> 인터페이스를 구현하고 있다.
enum 클래스에 정의된 순서를 자연 정렬 순서로 사용한다.</p>
              </article>
          
              <article id="object-declarations.html" class="page-content">
                <h2 id='object-declarations.html_section'>오브젝트 식과 선언<a class='anchor' href='#%23section'> </a></h2><p>때때로 상속한 클래스를 만들지 않고 어떤 클래스를 아주 약간 변경한 객체를 만들고 싶을 때가 있다.
자바에서는 이때 <em>임의 내부(inner) 클래스</em>를 사용한다.
코틀린은 이 개념을 <em>오브젝트 식</em>과 <em>오브젝트 선언</em>으로 약간 일반화했다.</p><h3 id='object-declarations.html_section-1'>오브젝트 식<a class='anchor' href='#%23section-1'> </a></h3><p>특정 타입을 상속받은 임의 클래스의 객체를 생성할 때 다음과 같이 코드를 작성한다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>window</span><span class='p'>.</span><span class='n'>addMouseListener</span><span class='p'>(</span><span class='k'>object</span> <span class='err'>: </span><span class='nc'>MouseAdapter</span><span class='p'>()</span> <span class='p'>{</span>
  <span class='k'>override</span> <span class='k'>fun</span> <span class='nf'>mouseClicked</span><span class='p'>(</span><span class='n'>e</span><span class='p'>:</span> <span class='n'>MouseEvent</span><span class='p'>)</span> <span class='p'>{</span>
    <span class='c1'>// ...</span>
  <span class='p'>}</span>

  <span class='k'>override</span> <span class='k'>fun</span> <span class='nf'>mouseEntered</span><span class='p'>(</span><span class='n'>e</span><span class='p'>:</span> <span class='n'>MouseEvent</span><span class='p'>)</span> <span class='p'>{</span>
    <span class='c1'>// ...</span>
  <span class='p'>}</span>
<span class='p'>})</span></code></pre><p>상위타입이 생성자를 가지면 알맞은 생성자 파라미터를 전달해야 한다.
상위 타입이 여러 개면 콜론 뒤에 콤마로 구분해서 지정한다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>open</span> <span class='k'>class</span> <span class='nc'>A</span><span class='p'>(</span><span class='n'>x</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>)</span> <span class='p'>{</span>
  <span class='k'>public</span> <span class='k'>open</span> <span class='k'>val</span> <span class='py'>y</span><span class='p'>:</span> <span class='n'>Int</span> <span class='p'>=</span> <span class='n'>x</span>
<span class='p'>}</span>

<span class='n'>interface</span> <span class='n'>B</span> <span class='p'>{...}</span>

<span class='k'>val</span> <span class='py'>ab</span> <span class='p'>=</span> <span class='k'>object</span> <span class='err'>: </span><span class='nc'>A</span><span class='p'>(</span><span class='m'>1</span><span class='p'>),</span> <span class='n'>B</span> <span class='p'>{</span>
  <span class='k'>override</span> <span class='k'>val</span> <span class='py'>y</span> <span class='p'>=</span> <span class='m'>15</span>
<span class='p'>}</span></code></pre><p>만약 별도 상위타입이 없는 “단순히 객체”가 필요하다면 다음 코드를 사용할 수 있다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>adHoc</span> <span class='p'>=</span> <span class='k'>object</span> <span class='err'>{</span>
  <span class='k'>var</span> <span class='py'>x</span><span class='p'>:</span> <span class='n'>Int</span> <span class='p'>=</span> <span class='m'>0</span>
  <span class='k'>var</span> <span class='py'>y</span><span class='p'>:</span> <span class='n'>Int</span> <span class='p'>=</span> <span class='m'>0</span>
<span class='p'>}</span>
<span class='n'>print</span><span class='p'>(</span><span class='n'>adHoc</span><span class='p'>.</span><span class='n'>x</span> <span class='p'>+</span> <span class='n'>adHoc</span><span class='p'>.</span><span class='n'>y</span><span class='p'>)</span></code></pre><p>자바의 임의 내부(inner) 클래스와 비슷하게 오브젝트 식의 코드는 외부 스코프의 변수에 접근할 수 있다(자바와 달리 final 변수로 제한되지 않는다).</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>countClicks</span><span class='p'>(</span><span class='n'>window</span><span class='p'>:</span> <span class='n'>JComponent</span><span class='p'>)</span> <span class='p'>{</span>
  <span class='k'>var</span> <span class='py'>clickCount</span> <span class='p'>=</span> <span class='m'>0</span>
  <span class='k'>var</span> <span class='py'>enterCount</span> <span class='p'>=</span> <span class='m'>0</span>

  <span class='n'>window</span><span class='p'>.</span><span class='n'>addMouseListener</span><span class='p'>(</span><span class='k'>object</span> <span class='err'>: </span><span class='nc'>MouseAdapter</span><span class='p'>()</span> <span class='p'>{</span>
    <span class='k'>override</span> <span class='k'>fun</span> <span class='nf'>mouseClicked</span><span class='p'>(</span><span class='n'>e</span><span class='p'>:</span> <span class='n'>MouseEvent</span><span class='p'>)</span> <span class='p'>{</span>
      <span class='n'>clickCount</span><span class='p'>++</span>
    <span class='p'>}</span>

    <span class='k'>override</span> <span class='k'>fun</span> <span class='nf'>mouseEntered</span><span class='p'>(</span><span class='n'>e</span><span class='p'>:</span> <span class='n'>MouseEvent</span><span class='p'>)</span> <span class='p'>{</span>
      <span class='n'>enterCount</span><span class='p'>++</span>
    <span class='p'>}</span>
  <span class='p'>})</span>
  <span class='c1'>// ...</span>
<span class='p'>}</span></code></pre><h3 id='object-declarations.html_section-2'>오브젝트 선언<a class='anchor' href='#%23section-2'> </a></h3><p><a href='#http%3A%2F%2Fen.wikipedia.org%2Fwiki%2FSingleton_pattern'>싱글톤</a>은 매우 유용한 패턴이다. 코틀린은 (스캍라를 따라해서) 쉽게 싱글톤을 선언할 수 있도록 했다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>object</span> <span class='nc'>DataProviderManager</span> <span class='p'>{</span>
  <span class='k'>fun</span> <span class='nf'>registerDataProvider</span><span class='p'>(</span><span class='n'>provider</span><span class='p'>:</span> <span class='n'>DataProvider</span><span class='p'>)</span> <span class='p'>{</span>
    <span class='c1'>// ...</span>
  <span class='p'>}</span>

  <span class='k'>val</span> <span class='py'>allDataProviders</span><span class='p'>:</span> <span class='n'>Collection</span><span class='p'>&lt;</span><span class='n'>DataProvider</span><span class='p'>&gt;</span>
    <span class='k'>get</span><span class='p'>()</span> <span class='p'>=</span> <span class='c1'>// ...</span>
<span class='p'>}</span></code></pre><p>이를 <em>오브젝트 선언</em>이라고 한다. <em class='keyword'>object</em> 키워드 뒤에 이름이 있으면 이는 _식_을 말하는 것이 아니다.
오브젝트는 변수에 할당할 수 없으며 이름으로 참조할 수 있다. 오브젝트는 상위타입을 가질 수 있다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>object</span> <span class='nc'>DefaultListener</span> <span class='p'>:</span> <span class='n'>MouseAdapter</span><span class='p'>()</span> <span class='p'>{</span>
  <span class='k'>override</span> <span class='k'>fun</span> <span class='nf'>mouseClicked</span><span class='p'>(</span><span class='n'>e</span><span class='p'>:</span> <span class='n'>MouseEvent</span><span class='p'>)</span> <span class='p'>{</span>
    <span class='c1'>// ...</span>
  <span class='p'>}</span>

  <span class='k'>override</span> <span class='k'>fun</span> <span class='nf'>mouseEntered</span><span class='p'>(</span><span class='n'>e</span><span class='p'>:</span> <span class='n'>MouseEvent</span><span class='p'>)</span> <span class='p'>{</span>
    <span class='c1'>// ...</span>
  <span class='p'>}</span>
<span class='p'>}</span></code></pre><p><strong>주의</strong>: 오브젝트는 로컬일 수 없다(예를 들어 함수 안에 바로 중첩하는 것). 하지만, 내부(inner)가 아닌 클래스나 다른 오브젝트 선언에 중첩할 수는 있다.</p><h4 id='object-declarations.html_section-3'>컴페니언 오브젝트<a class='anchor' href='#%23section-3'> </a></h4><p>클래스 안의 오브젝트 선언은 <em class='keyword'>companion</em> 키워드를 붙일 수 있다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>class</span> <span class='nc'>MyClass</span> <span class='p'>{</span>
  <span class='n'>companion</span> <span class='k'>object</span> <span class='nc'>Factory</span> <span class='p'>{</span>
    <span class='k'>fun</span> <span class='nf'>create</span><span class='p'>():</span> <span class='n'>MyClass</span> <span class='p'>=</span> <span class='n'>MyClass</span><span class='p'>()</span>
  <span class='p'>}</span>
<span class='p'>}</span></code></pre><p>컴페니언 오브젝트의 멤버는 클래스 이름을 한정자로 사용해서 간단히 호출할 수 있다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>instance</span> <span class='p'>=</span> <span class='n'>MyClass</span><span class='p'>.</span><span class='n'>create</span><span class='p'>()</span></code></pre><p>컴페니언 오브젝트의 이름을 생략하면 <code>Companion</code>을 이름으로 사용한다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>class</span> <span class='nc'>MyClass</span> <span class='p'>{</span>
  <span class='n'>companion</span> <span class='k'>object</span> <span class='err'>{</span>
  <span class='p'>}</span>
<span class='p'>}</span>

<span class='k'>val</span> <span class='py'>x</span> <span class='p'>=</span> <span class='n'>MyClass</span><span class='p'>.</span><span class='n'>Companion</span></code></pre><p>컴페니언 오브젝트의 멤버가 다른 언어의 정적 멤버처럼 보이긴 하지만 런타임에는 실제 객체의 인스턴스 멤버이다.
예를 들어 다음과 같이 인터페이스를 구현할 수 있다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>interface</span> <span class='n'>Factory</span><span class='p'>&lt;</span><span class='n'>T</span><span class='p'>&gt;</span> <span class='p'>{</span>
  <span class='k'>fun</span> <span class='nf'>create</span><span class='p'>():</span> <span class='n'>T</span>
<span class='p'>}</span>


<span class='k'>class</span> <span class='nc'>MyClass</span> <span class='p'>{</span>
  <span class='n'>companion</span> <span class='k'>object</span> <span class='err'>: </span><span class='nc'>Factory</span><span class='p'>&lt;</span><span class='n'>MyClass</span><span class='p'>&gt;</span> <span class='p'>{</span>
    <span class='k'>override</span> <span class='k'>fun</span> <span class='nf'>create</span><span class='p'>():</span> <span class='n'>MyClass</span> <span class='p'>=</span> <span class='n'>MyClass</span><span class='p'>()</span>
  <span class='p'>}</span>
<span class='p'>}</span></code></pre><p>하지만, JVM에서 <code>@JvmStatic</code> 애노테이션을 사용하면 실제 정적 메서드와 필드로 생성된 컴페니언 오브젝트의 멤버를 가질 수 있다.
이에 대한 내용은 <a href='#java-interop.html%23static-methods-and-fields'>자바 상호운용</a>을 참고한다.</p><h4 id='object-declarations.html_section-4'>오브젝트 식과 오브젝트 선언의 세만틱 차이<a class='anchor' href='#%23section-4'> </a></h4><p>오브젝트 식과 오브젝트 선언은 한 가지 중요한 의미 차이가 있다:</p><ul>
  <li>오브젝트 선언은 최초에 접근할 때까지 초기화를 (<strong>lazily</strong>) 미룬다.</li>
  <li>오브젝트 식은 사용할 때 <strong>즉시</strong> 실행(초기화)된다.</li>
</ul>
              </article>
          
              <article id="delegation.html" class="page-content">
                <h2 id='delegation.html_section'>위임<a class='anchor' href='#%23section'> </a></h2><h3 id='delegation.html_section-1'>클래스 위임<a class='anchor' href='#%23section-1'> </a></h3><p><a href='#https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FDelegation_pattern'>위임 패턴</a>은 상속의 좋은 대안임이 증명되었다.
코틀린은 장식 코드(boilerplate code) 없이 언어 자체에서 위임 패턴을 지원한다.
아래에서 <code>Derived</code> 클래스는 <code>Base</code> 인터페이스에서 상속받은 모든 public 메서드를 지정한 객체로 위임할 수 있다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>interface</span> <span class='n'>Base</span> <span class='p'>{</span>
  <span class='k'>fun</span> <span class='nf'>print</span><span class='p'>()</span>
<span class='p'>}</span>

<span class='k'>class</span> <span class='nc'>BaseImpl</span><span class='p'>(</span><span class='k'>val</span> <span class='py'>x</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>)</span> <span class='p'>:</span> <span class='n'>Base</span> <span class='p'>{</span>
  <span class='k'>override</span> <span class='k'>fun</span> <span class='nf'>print</span><span class='p'>()</span> <span class='p'>{</span> <span class='n'>print</span><span class='p'>(</span><span class='n'>x</span><span class='p'>)</span> <span class='p'>}</span>
<span class='p'>}</span>

<span class='k'>class</span> <span class='nc'>Derived</span><span class='p'>(</span><span class='n'>b</span><span class='p'>:</span> <span class='n'>Base</span><span class='p'>)</span> <span class='p'>:</span> <span class='n'>Base</span> <span class='k'>by</span> <span class='n'>b</span>

<span class='k'>fun</span> <span class='nf'>main</span><span class='p'>()</span> <span class='p'>{</span>
  <span class='k'>val</span> <span class='py'>b</span> <span class='p'>=</span> <span class='n'>BaseImpl</span><span class='p'>(</span><span class='m'>10</span><span class='p'>)</span>
  <span class='n'>Derived</span><span class='p'>(</span><span class='n'>b</span><span class='p'>).</span><span class='n'>print</span><span class='p'>()</span> <span class='c1'>// 10 출력</span>
<span class='p'>}</span></code></pre><p><code>Derived</code>의 상위타입 목록의 <em class='keyword'>by</em>-절은 <code>Derived</code> 객체 내부에 <code>b</code>를 저장하고
컴파일이러가 <code>Base</code>의 모든 메서드에 대해 <code>b</code>로 위임하는 메서드를 <code>Derived</code>에 생성한다는 것을 나타낸다.</p>
              </article>
          
              <article id="delegated-properties.html" class="page-content">
                <h2 id='delegated-properties.html_delegated-properties'>위임 프로퍼티(Delegated Properties)<a class='anchor' href='#%23delegated-properties'> </a></h2><p>필요할 때 수동으로 기능을 구현할 수 있지만, 한번에 다 구현하고 라이브러리에 넣는 것이 매우 좋은 그런 종류의 프로퍼티가 존재한다.
다음 프로퍼티가 이런 종류에 속한다.</p><ul>
  <li>lazy 프로퍼티: 최초에 접근할 때 값을 계산,</li>
  <li>observable 프로퍼티: 이 프로퍼티가 바뀔 때 리스너에 통지,</li>
  <li>별도 필드가 아닌 맵에 저장한 프로퍼티.</li>
</ul><p>이런 경우를 포함한 여러 경우를 처리하기 위해 코틀린은 _위임 프로퍼티_를 지원한다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>class</span> <span class='nc'>Example</span> <span class='p'>{</span>
  <span class='k'>var</span> <span class='py'>p</span><span class='p'>:</span> <span class='n'>String</span> <span class='k'>by</span> <span class='n'>Delegate</span><span class='p'>()</span>
<span class='p'>}</span></code></pre><p>위임 프로퍼티 구문은 <code>val/var &lt;property name&gt;: &lt;Type&gt; by &lt;expression&gt;</code>이다. <em class='keyword'>by</em> 뒤에 식이 _대리 객체(delegate)_이며,
프로퍼티에 대한 <code>get()</code>과 <code>set()</code>을 대리 객체의 <code>getValue()</code>와 <code>setValue()</code> 메서드로 위임한다.
프로퍼티 대리 객체는 인터페이스를 아무렇게나 구현하면 안 되고, <code>getValue()</code> 함수를 (그리고 <em class='keyword'>var</em>의 경우 <code>setValue()</code> 함수를) 제공해야 한다.
다음 예를 보자:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>class</span> <span class='nc'>Delegate</span> <span class='p'>{</span>
  <span class='n'>operator</span> <span class='k'>fun</span> <span class='nf'>getValue</span><span class='p'>(</span><span class='n'>thisRef</span><span class='p'>:</span> <span class='n'>Any</span><span class='p'>?,</span> <span class='n'>property</span><span class='p'>:</span> <span class='n'>KProperty</span><span class='p'>&lt;*&gt;):</span> <span class='n'>String</span> <span class='p'>{</span>
    <span class='k'>return</span> <span class='s'>&quot;$thisRef, thank you for delegating &#39;${property.name}&#39; to me!&quot;</span>
  <span class='p'>}</span>

  <span class='n'>operator</span> <span class='k'>fun</span> <span class='nf'>setValue</span><span class='p'>(</span><span class='n'>thisRef</span><span class='p'>:</span> <span class='n'>Any</span><span class='p'>?,</span> <span class='n'>property</span><span class='p'>:</span> <span class='n'>KProperty</span><span class='p'>&lt;*&gt;,</span> <span class='n'>value</span><span class='p'>:</span> <span class='n'>String</span><span class='p'>)</span> <span class='p'>{</span>
    <span class='n'>println</span><span class='p'>(</span><span class='s'>&quot;$value has been assigned to &#39;${property.name} in $thisRef.&#39;&quot;</span><span class='p'>)</span>
  <span class='p'>}</span>
<span class='p'>}</span></code></pre><p><code>Delegate</code> 인스턴스에 위임하는 프로퍼티 <code>p</code>에서 값을 읽으면 <code>Delegate</code>의 <code>getValue()</code> 함수를 실행한다.
이 메서드의 첫 번째 파라미터는 <code>p</code>를 포함한 객체이고 두 번째 파라미터는 <code>p</code> 자체에 대한 설명을 포함한다(예를 들어, 프로퍼티의 이름을 구할 수 있다).
다음은 예이다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>e</span> <span class='p'>=</span> <span class='n'>Example</span><span class='p'>()</span>
<span class='n'>println</span><span class='p'>(</span><span class='n'>e</span><span class='p'>.</span><span class='n'>p</span><span class='p'>)</span></code></pre><p>이 코드는 다음을 출력한다.</p><pre>Example@33a17727, thank you for delegating ‘p’ to me!
</pre><p>비슷하게 <code>p</code>에 할당하면 <code>setValue()</code> 함수를 호출한다. 처음 두 파라미터는 동일하고 세 번째 파라미터는 할당할 값을 갖는다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>e</span><span class='p'>.</span><span class='n'>p</span> <span class='p'>=</span> <span class='s'>&quot;NEW&quot;</span></code></pre><p>이 코드는 다음을 출력한다.</p><pre>NEW has been assigned to ‘p’ in Example@33a17727.
</pre><h3 id='delegated-properties.html_section'>프로퍼티 위임 객체 조건<a class='anchor' href='#%23section'> </a></h3><p>위임 객체의 조건을 아래 요약했다.</p><p><strong>읽기 전용</strong> 프로퍼티(예, <em class='keyword'>val</em>)에 대해 위임 객체는 다음 파라미터를 갖는 이름이 <code>getValue</code>인 함수를 제공해야 한다:</p><ul>
  <li>리시버 —  _프로퍼티 소유자_와 같거나 상위타입(확장 프로퍼티의 경우 — 확장한 타입),</li>
  <li>메타데이터 — <code>KProperty&lt;*&gt;</code> 타입이거나 그 상위타입,</li>
</ul><p>이 함수는 프로퍼티와 같은 타입을 (또는 그 하위타입을) 리턴해야 한다.</p><p><strong>수정 가능</strong> 프로퍼티(<em class='keyword'>var</em>)에 대해 위임 객체는 <em>추가로</em> 다음 파라미터를 갖는 이름이 <code>setValue</code>인 함수를 제공해야 한다.</p><ul>
  <li>receiver — <code>getValue()</code>와 동일,</li>
  <li>metadata — <code>getValue()</code>와 동일,</li>
  <li>new value — 프로퍼티와 같거나 상위타입이어야 한다.</li>
</ul><p><code>getValue()</code>와 <code>setValue()</code> 함수는 위임 클래스의 멤버 함수나 확장 함수로 제공할 수 있다.
확장 함수의 경우 원래 이 함수를 제공하지 않는 객체에 프로퍼티를 위임해야 할 때 유용한다.
두 함수 모두 <code>operator</code> 키워드로 지정해야 한다.</p><h3 id='delegated-properties.html_section-1'>표준 위임<a class='anchor' href='#%23section-1'> </a></h3><p>코틀린 표준 라이브러리는 몇 가지 유용한 종류의 위임 객체를 위한 팩토리 메서드를 제공한다.</p><h4 id='delegated-properties.html_lazy'>Lazy<a class='anchor' href='#%23lazy'> </a></h4><p><code>lazy()</code>는 람다를 파라미터로 받고 <code>Lazy&lt;T&gt;</code> 인스턴스를 리턴하는 함수이다. Lazy는 lazy 프로퍼티를 구현하기 위한 위임 객체이다.
처음 <code>get()</code>을 호출하면 <code>lazy()</code>에 전달한 람다를 실행하고 그 결과를 저장하며,
이후 <code>get()</code> 호출에 대해선 저장한 결과를 리턴한다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>lazyValue</span><span class='p'>:</span> <span class='n'>String</span> <span class='k'>by</span> <span class='n'>lazy</span> <span class='p'>{</span>
    <span class='n'>println</span><span class='p'>(</span><span class='s'>&quot;computed!&quot;</span><span class='p'>)</span>
    <span class='s'>&quot;Hello&quot;</span>
<span class='p'>}</span>

<span class='k'>fun</span> <span class='nf'>main</span><span class='p'>(</span><span class='n'>args</span><span class='p'>:</span> <span class='n'>Array</span><span class='p'>&lt;</span><span class='n'>String</span><span class='p'>&gt;)</span> <span class='p'>{</span>
    <span class='n'>println</span><span class='p'>(</span><span class='n'>lazyValue</span><span class='p'>)</span>
    <span class='n'>println</span><span class='p'>(</span><span class='n'>lazyValue</span><span class='p'>)</span>
<span class='p'>}</span></code></pre><p>lazy 프로퍼티 연산은 기본적으로 <strong>동기화</strong>된다. 한 스레드만 값을 계산할 수 있으며 모든 스레드는 같은 값을 보게 된다. 만약 초기화 과정을 동기화할 필요가 없다면,
<code>lazy()</code> 함수의 파라미터에 <code>LazyThreadSafetyMode.PUBLICATION</code>을 전달해서 여러 스레드가 동시에 실행할 수 있도록 할 수 있다.
그리고 항상 한 스레드에서만 초기화하는 것을 보장하려면 <code>LazyThreadSafetyMode.NONE</code> 모드를 사용하면 된다.
이 모드는 스레드 안정성을 보장하기 위한 오버헤드를 발생하지 않는다.</p><h4 id='delegated-properties.html_observable'>Observable<a class='anchor' href='#%23observable'> </a></h4><p><code>Delegates.observable()</code>은 초깃값과 수정에 대한 핸들러를 인자로 갖는다.
프로퍼티에 값을 할당할 때마다 (할당 완료 후에) 핸들러를 호출한다.
핸들러는 할당 대상 프로퍼티, 이전 값, 새로운 값을 파라미터로 갖는다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>import</span> <span class='nn'>kotlin.properties.Delegates</span>

<span class='k'>class</span> <span class='nc'>User</span> <span class='p'>{</span>
    <span class='k'>var</span> <span class='py'>name</span><span class='p'>:</span> <span class='n'>String</span> <span class='k'>by</span> <span class='n'>Delegates</span><span class='p'>.</span><span class='n'>observable</span><span class='p'>(</span><span class='s'>&quot;&lt;no name&gt;&quot;</span><span class='p'>)</span> <span class='p'>{</span>
        <span class='n'>prop</span><span class='p'>,</span> <span class='n'>old</span><span class='p'>,</span> <span class='n'>new</span> <span class='p'>-&gt;</span>
        <span class='n'>println</span><span class='p'>(</span><span class='s'>&quot;$old -&gt; $new&quot;</span><span class='p'>)</span>
    <span class='p'>}</span>
<span class='p'>}</span>

<span class='k'>fun</span> <span class='nf'>main</span><span class='p'>(</span><span class='n'>args</span><span class='p'>:</span> <span class='n'>Array</span><span class='p'>&lt;</span><span class='n'>String</span><span class='p'>&gt;)</span> <span class='p'>{</span>
    <span class='k'>val</span> <span class='py'>user</span> <span class='p'>=</span> <span class='n'>User</span><span class='p'>()</span>
    <span class='n'>user</span><span class='p'>.</span><span class='n'>name</span> <span class='p'>=</span> <span class='s'>&quot;first&quot;</span>
    <span class='n'>user</span><span class='p'>.</span><span class='n'>name</span> <span class='p'>=</span> <span class='s'>&quot;second&quot;</span>
<span class='p'>}</span></code></pre><p>이 예는 다음을 출력한다.</p><pre>&lt;no name&gt; -&gt; first
first -&gt; second
</pre><p>만약 할당 과정 중간에 끼어들어 할당을 “거부(veto)”하고 싶다면, <code>observable()</code> 대신에 <code>vetoable()</code>을 사용하면 된다.
프로퍼티에 새 값을 할당하기 전에 <code>vetoable</code>에 전달한 핸들러를 호출한다.</p><h3 id='delegated-properties.html_section-2'>맵에 프로퍼티 저장하기<a class='anchor' href='#%23section-2'> </a></h3><p>프로퍼티의 값을 맵에 저장하는 것은 일반적이다.
이는 JSON 파싱이나 다른 “동적” 작업을 할 때 흔한 일이다.
이 경우 위임 프로퍼티로 위임 객체 대신 맵 인스턴스 자체를 사용할 수 있다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>class</span> <span class='nc'>User</span><span class='p'>(</span><span class='k'>val</span> <span class='py'>map</span><span class='p'>:</span> <span class='n'>Map</span><span class='p'>&lt;</span><span class='n'>String</span><span class='p'>,</span> <span class='n'>Any</span><span class='p'>?&gt;)</span> <span class='p'>{</span>
    <span class='k'>val</span> <span class='py'>name</span><span class='p'>:</span> <span class='n'>String</span> <span class='k'>by</span> <span class='n'>map</span>
    <span class='k'>val</span> <span class='py'>age</span><span class='p'>:</span> <span class='n'>Int</span>     <span class='k'>by</span> <span class='n'>map</span>
<span class='p'>}</span></code></pre><p>이 예제에서 생성자는 맵을 받는다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>user</span> <span class='p'>=</span> <span class='n'>User</span><span class='p'>(</span><span class='n'>mapOf</span><span class='p'>(</span>
    <span class='s'>&quot;name&quot;</span> <span class='n'>to</span> <span class='s'>&quot;John Doe&quot;</span><span class='p'>,</span>
    <span class='s'>&quot;age&quot;</span>  <span class='n'>to</span> <span class='m'>25</span>
<span class='p'>))</span></code></pre><p>위임 프로퍼티는 이 맵에서 값을 읽어온다(문자열 키 — 프로퍼티의 이름):</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>println</span><span class='p'>(</span><span class='n'>user</span><span class='p'>.</span><span class='n'>name</span><span class='p'>)</span> <span class='c1'>// &quot;John Doe&quot; 출력</span>
<span class='n'>println</span><span class='p'>(</span><span class='n'>user</span><span class='p'>.</span><span class='n'>age</span><span class='p'>)</span>  <span class='c1'>// 25 출력</span></code></pre><p>읽기 전용 <code>Map</code> 대신에 <code>MutableMap</code>을 사용하면 <em class='keyword'>var</em> 프로퍼티에도 동작한다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>class</span> <span class='nc'>MutableUser</span><span class='p'>(</span><span class='k'>val</span> <span class='py'>map</span><span class='p'>:</span> <span class='n'>MutableMap</span><span class='p'>&lt;</span><span class='n'>String</span><span class='p'>,</span> <span class='n'>Any</span><span class='p'>?&gt;)</span> <span class='p'>{</span>
    <span class='k'>var</span> <span class='py'>name</span><span class='p'>:</span> <span class='n'>String</span> <span class='k'>by</span> <span class='n'>map</span>
    <span class='k'>var</span> <span class='py'>age</span><span class='p'>:</span> <span class='n'>Int</span>     <span class='k'>by</span> <span class='n'>map</span>
<span class='p'>}</span></code></pre>
              </article>
          

        </section>
    

    
        <section>
          <h1 id="%ED%95%A8%EC%88%98%EC%99%80_%EB%9E%8C%EB%8B%A4"
              class="section-title">
            함수와 람다
          </h1>

          
              <article id="functions.html" class="page-content">
                <h2 id='functions.html_section'>함수<a class='anchor' href='#%23section'> </a></h2><h3 id='functions.html_section-1'>함수 선언<a class='anchor' href='#%23section-1'> </a></h3><p><em class='keyword'>fun</em>을 사용해서 함수를 선언한다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>double</span><span class='p'>(</span><span class='n'>x</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>):</span> <span class='n'>Int</span> <span class='p'>{</span>
<span class='p'>}</span></code></pre><h3 id='functions.html_section-2'>함수 사용<a class='anchor' href='#%23section-2'> </a></h3><p>전통적인 방식으로 함수를 호출한다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>result</span> <span class='p'>=</span> <span class='n'>double</span><span class='p'>(</span><span class='m'>2</span><span class='p'>)</span></code></pre><p>멤버 함수를 호출할 때에는 점 부호를 사용한다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>Sample</span><span class='p'>().</span><span class='n'>foo</span><span class='p'>()</span> <span class='c1'>// Sample 클래스의 인스턴스를 생성하고 foo 호출</span></code></pre><h4 id='functions.html_section-3'>중위 표현<a class='anchor' href='#%23section-3'> </a></h4><p>다음의 경우 중위 표현(Infix notation)을 사용해서 함수를 호출할 수도 있다.</p><ul>
  <li>멤버 함수이거나 <a href='#extensions.html'>확장 함수</a>일 때</li>
  <li>파라미터를 한 개 가질 때</li>
  <li><code>infix</code> 키워드로 지정했을 때</li>
</ul><pre><code class='code-block _highlighted lang_kotlin'><span class='c1'>// Int에 대한 확장 함수</span>
<span class='n'>infix</span> <span class='k'>fun</span> <span class='nf'>Int</span><span class='p'>.</span><span class='n'>shl</span><span class='p'>(</span><span class='n'>x</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>):</span> <span class='n'>Int</span> <span class='p'>{</span>
<span class='p'>...</span>
<span class='p'>}</span>

<span class='c1'>// 중위 표현을 사용해서 확장 함수 호출</span>

<span class='m'>1</span> <span class='n'>shl</span> <span class='m'>2</span>

<span class='c1'>// 다음 코드와 같음</span>

<span class='m'>1.</span><span class='n'>shl</span><span class='p'>(</span><span class='m'>2</span><span class='p'>)</span></code></pre><h4 id='functions.html_section-4'>파라미터<a class='anchor' href='#%23section-4'> </a></h4><p>함수 파라미터는 <em>name</em>: <em>type</em>와 같은 파스칼 표기법을 사용해서 정의한다. 파라미터는 콤마로 구분한다. 각 파라미터는 반드시 타입을 지정해야 한다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>powerOf</span><span class='p'>(</span><span class='n'>number</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>,</span> <span class='n'>exponent</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>)</span> <span class='p'>{</span>
<span class='p'>...</span>
<span class='p'>}</span></code></pre><h4 id='functions.html_section-5'>기본 인자<a class='anchor' href='#%23section-5'> </a></h4><p>함수 파라미터는 기본 값을 가질 수 있다. 해당 인자를 생략하면 이 기본 값을 사용한다.
이는 다른 언어 대비 오버로딩을 줄일 수 있도록 해 준다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>read</span><span class='p'>(</span><span class='n'>b</span><span class='p'>:</span> <span class='n'>Array</span><span class='p'>&lt;</span><span class='n'>Byte</span><span class='p'>&gt;,</span> <span class='n'>off</span><span class='p'>:</span> <span class='n'>Int</span> <span class='p'>=</span> <span class='m'>0</span><span class='p'>,</span> <span class='n'>len</span><span class='p'>:</span> <span class='n'>Int</span> <span class='p'>=</span> <span class='n'>b</span><span class='p'>.</span><span class='n'>size</span><span class='p'>())</span> <span class='p'>{</span>
<span class='p'>...</span>
<span class='p'>}</span></code></pre><p>기본 값은 타입 뒤에 <strong>=</strong>와 값을 사용해서 지정한다.</p><h4 id='functions.html_section-6'>네임드 인자<a class='anchor' href='#%23section-6'> </a></h4><p>함수 파라미터는 함수를 호출할 때 이름을 가질 수 있다. 파라미터 개수가 많거나 기본 값을 가진 경우 이름을 사용하면 매우 편리하다.</p><p>다음 함수를 보자.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>reformat</span><span class='p'>(</span><span class='n'>str</span><span class='p'>:</span> <span class='n'>String</span><span class='p'>,</span>
             <span class='n'>normalizeCase</span><span class='p'>:</span> <span class='n'>Boolean</span> <span class='p'>=</span> <span class='k'>true</span><span class='p'>,</span>
             <span class='n'>upperCaseFirstLetter</span><span class='p'>:</span> <span class='n'>Boolean</span> <span class='p'>=</span> <span class='k'>true</span><span class='p'>,</span>
             <span class='n'>divideByCamelHumps</span><span class='p'>:</span> <span class='n'>Boolean</span> <span class='p'>=</span> <span class='k'>false</span><span class='p'>,</span>
             <span class='n'>wordSeparator</span><span class='p'>:</span> <span class='n'>Char</span> <span class='p'>=</span> <span class='sc'>&#39; &#39;</span><span class='p'>)</span> <span class='p'>{</span>
<span class='p'>...</span>
<span class='p'>}</span></code></pre><p>기본 인자를 사용하면 이 함수를 다음과 같이 호출할 수 있다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>reformat</span><span class='p'>(</span><span class='n'>str</span><span class='p'>)</span></code></pre><p>하지만 기본 값을 사용하지 않고 호출하면 다음과 같은 코드가 된다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>reformat</span><span class='p'>(</span><span class='n'>str</span><span class='p'>,</span> <span class='k'>true</span><span class='p'>,</span> <span class='k'>true</span><span class='p'>,</span> <span class='k'>false</span><span class='p'>,</span> <span class='sc'>&#39;_&#39;</span><span class='p'>)</span></code></pre><p>이름 인자를 사용하면 코드 가독성을 높일 수 있다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>reformat</span><span class='p'>(</span><span class='n'>str</span><span class='p'>,</span>
    <span class='n'>normalizeCase</span> <span class='p'>=</span> <span class='k'>true</span><span class='p'>,</span>
    <span class='n'>upperCaseFirstLetter</span> <span class='p'>=</span> <span class='k'>true</span><span class='p'>,</span>
    <span class='n'>divideByCamelHumps</span> <span class='p'>=</span> <span class='k'>false</span><span class='p'>,</span>
    <span class='n'>wordSeparator</span> <span class='p'>=</span> <span class='sc'>&#39;_&#39;</span>
  <span class='p'>)</span></code></pre><p>모든 인자가 필요하지 않으면 더 간결해진다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>reformat</span><span class='p'>(</span><span class='n'>str</span><span class='p'>,</span> <span class='n'>wordSeparator</span> <span class='p'>=</span> <span class='sc'>&#39;_&#39;</span><span class='p'>)</span></code></pre><p>이름 인자 구문은 자바 함수를 호출할 때는 사용할 수 없다는 점에 유의하자. 왜냐면 자바 바이트코드는 함수 파라미터의 이름을 유지하지 않기 때문이다.</p><h4 id='functions.html_unit--'>Unit 리턴 함수<a class='anchor' href='#%23unit--'> </a></h4><p>어떤 값도 리턴하지 않는 함수의 리턴 타입은 <code>Unit</code>이다. <code>Unit</code> 타입의 값은 <code>Unit</code> 한 개만 존재한다.
이 값을 명시적으로 리턴할 필요는 없다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>printHello</span><span class='p'>(</span><span class='n'>name</span><span class='p'>:</span> <span class='n'>String</span><span class='p'>?):</span> <span class='n'>Unit</span> <span class='p'>{</span>
    <span class='k'>if</span> <span class='p'>(</span><span class='n'>name</span> <span class='p'>!=</span> <span class='k'>null</span><span class='p'>)</span>
        <span class='n'>println</span><span class='p'>(</span><span class='s'>&quot;Hello ${name}&quot;</span><span class='p'>)</span>
    <span class='k'>else</span>
        <span class='n'>println</span><span class='p'>(</span><span class='s'>&quot;Hi there!&quot;</span><span class='p'>)</span>
    <span class='c1'>// `return Unit` 또는 `return` 생략 가능</span>
<span class='p'>}</span></code></pre><p><code>Unit</code> 리턴 타입 선언도 생략할 수 있다. 위 코드는 다음과 동일하다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>printHello</span><span class='p'>(</span><span class='n'>name</span><span class='p'>:</span> <span class='n'>String</span><span class='p'>?)</span> <span class='p'>{</span>
    <span class='p'>...</span>
<span class='p'>}</span></code></pre><h4 id='functions.html_section-7'>단일 식 함수<a class='anchor' href='#%23section-7'> </a></h4><p>함수가 단일 식을 리턴하면, 중괄호를 생략할 수 있고 <strong>=</strong> 부호 뒤에 몸체를 지정할 수 있다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>double</span><span class='p'>(</span><span class='n'>x</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>):</span> <span class='n'>Int</span> <span class='p'>=</span> <span class='n'>x</span> <span class='p'>*</span> <span class='m'>2</span></code></pre><p>이 경우 컴파일러가 리턴 타입을 유추할 수 있으므로 리턴 타입 지정을 <a href='#%23explicit-return-types'>생략</a>할 수 있다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>double</span><span class='p'>(</span><span class='n'>x</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>)</span> <span class='p'>=</span> <span class='n'>x</span> <span class='p'>*</span> <span class='m'>2</span></code></pre><h4 id='functions.html_section-8'>리턴 타입 지정<a class='anchor' href='#%23section-8'> </a></h4><p>블록 몸체를 갖는 함수는 <code>Unit</code>을 리턴하는 것이 아니라면 반드시 리턴 타입을 지정해야 한다.
(<a href='#%23unit-returning-functions'>생략할 수 있는 경우</a> 참고)
블록 몸체를 가진 함수는 몸체에 제어 흐름이 복잡할 수 있고 코드를 읽는 사람 입장에서 (또는 컴파일러 입장에서도) 리턴 타입이 명확하지 않을 수 있기 때문에
리턴 타입을 유추하지 않는다.</p><h4 id='functions.html_varargs'>가변 인자 (Varargs)<a class='anchor' href='#%23varargs'> </a></h4><p>함수 파라미터를 (보통 마지막 파라미터를) <code>vararg</code> 제한자로 지정할 수 있다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='err'>&lt;</span><span class='nf'>T</span><span class='p'>&gt;</span> <span class='n'>asList</span><span class='p'>(</span><span class='k'>vararg</span> <span class='n'>ts</span><span class='p'>:</span> <span class='n'>T</span><span class='p'>):</span> <span class='n'>List</span><span class='p'>&lt;</span><span class='n'>T</span><span class='p'>&gt;</span> <span class='p'>{</span>
  <span class='k'>val</span> <span class='py'>result</span> <span class='p'>=</span> <span class='n'>ArrayList</span><span class='p'>&lt;</span><span class='n'>T</span><span class='p'>&gt;()</span>
  <span class='k'>for</span> <span class='p'>(</span><span class='n'>t</span> <span class='k'>in</span> <span class='n'>ts</span><span class='p'>)</span> <span class='c1'>// ts는 Array</span>
    <span class='n'>result</span><span class='p'>.</span><span class='n'>add</span><span class='p'>(</span><span class='n'>t</span><span class='p'>)</span>
  <span class='k'>return</span> <span class='n'>result</span>
<span class='p'>}</span></code></pre><p>가변 인자를 사용하면 함수에 인자 개수를 가변적으로 전달할 수 있다.</p><pre><code class='code-block _highlighted lang_kotlin'>  <span class='k'>val</span> <span class='py'>list</span> <span class='p'>=</span> <span class='n'>asList</span><span class='p'>(</span><span class='m'>1</span><span class='p'>,</span> <span class='m'>2</span><span class='p'>,</span> <span class='m'>3</span><span class='p'>)</span></code></pre><p><code>T</code> 타입의 <code>vararg</code> 파라미터는 함수 안에서 <code>T</code> 배열로 접근할 수 있다. 예의 경우 <code>ts</code> 변수는 <code>Array&lt;out T&gt;</code> 타입을 갖는다.</p><p>오직 한 개 파라미터만 <code>vararg</code>로 지정할 수 있다. 만약 <code>vararg</code> 파라미터가 마지막 파라미터가 아니면 그 뒤 값은 이름 인자 구문을 이용해서 전달한다. 파라미터가 함수 타입이면 괄호 밖에 람다를 전달하는 방식을 사용할 수 있다.</p><p><code>vararg</code> 함수를 호출할 때 <code>asList(1, 2, 3)</code>처럼 인자를 한 개씩 전달할 수 있다.
만약 배열을 함수에 가변 인자로 전달하고 싶다면 <strong>펼침</strong> 연산자(배열 앞에 붙이는 <code>*</code>)를 사용하면 된다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>a</span> <span class='p'>=</span> <span class='n'>arrayOf</span><span class='p'>(</span><span class='m'>1</span><span class='p'>,</span> <span class='m'>2</span><span class='p'>,</span> <span class='m'>3</span><span class='p'>)</span>
<span class='k'>val</span> <span class='py'>list</span> <span class='p'>=</span> <span class='n'>asList</span><span class='p'>(-</span><span class='m'>1</span><span class='p'>,</span> <span class='m'>0</span><span class='p'>,</span> <span class='p'>*</span><span class='n'>a</span><span class='p'>,</span> <span class='m'>4</span><span class='p'>)</span></code></pre><h3 id='functions.html_section-9'>함수 범위<a class='anchor' href='#%23section-9'> </a></h3><p>코틀린은 파일에서 함수를 최상위 레벨로 선언할 수 있다. 즉, 자바, C#이나 스칼라와 같은 언어처럼 함수를 갖는 클래스를 만들 필요가 없다.
최상위 레벨 함수뿐만 이나라 로컬 함수, 멤버 함수, 확장 함수로도 선언할 수 있다.</p><h4 id='functions.html_section-10'>로컬 함수<a class='anchor' href='#%23section-10'> </a></h4><p>코틀린은 로컬 함수를 지원한다. 다음과 같이 다른 함수 안에 함수를 선언할 수 있다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>dfs</span><span class='p'>(</span><span class='n'>graph</span><span class='p'>:</span> <span class='n'>Graph</span><span class='p'>)</span> <span class='p'>{</span>
  <span class='k'>fun</span> <span class='nf'>dfs</span><span class='p'>(</span><span class='n'>current</span><span class='p'>:</span> <span class='n'>Vertex</span><span class='p'>,</span> <span class='n'>visited</span><span class='p'>:</span> <span class='n'>Set</span><span class='p'>&lt;</span><span class='n'>Vertex</span><span class='p'>&gt;)</span> <span class='p'>{</span>
    <span class='k'>if</span> <span class='p'>(!</span><span class='n'>visited</span><span class='p'>.</span><span class='n'>add</span><span class='p'>(</span><span class='n'>current</span><span class='p'>))</span> <span class='k'>return</span>
    <span class='k'>for</span> <span class='p'>(</span><span class='n'>v</span> <span class='k'>in</span> <span class='n'>current</span><span class='p'>.</span><span class='n'>neighbors</span><span class='p'>)</span>
      <span class='n'>dfs</span><span class='p'>(</span><span class='n'>v</span><span class='p'>,</span> <span class='n'>visited</span><span class='p'>)</span>
  <span class='p'>}</span>

  <span class='n'>dfs</span><span class='p'>(</span><span class='n'>graph</span><span class='p'>.</span><span class='n'>vertices</span><span class='p'>[</span><span class='m'>0</span><span class='p'>],</span> <span class='n'>HashSet</span><span class='p'>())</span>
<span class='p'>}</span></code></pre><p>로컬 함수는 다른 함수의 로별 변수에 접근 가능하므로(클로저) 위 코드에서 <em>visited</em>를 로컬 변수로 바꿀 수 있다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>dfs</span><span class='p'>(</span><span class='n'>graph</span><span class='p'>:</span> <span class='n'>Graph</span><span class='p'>)</span> <span class='p'>{</span>
  <span class='k'>val</span> <span class='py'>visited</span> <span class='p'>=</span> <span class='n'>HashSet</span><span class='p'>&lt;</span><span class='n'>Vertex</span><span class='p'>&gt;()</span>
  <span class='k'>fun</span> <span class='nf'>dfs</span><span class='p'>(</span><span class='n'>current</span><span class='p'>:</span> <span class='n'>Vertex</span><span class='p'>)</span> <span class='p'>{</span>
    <span class='k'>if</span> <span class='p'>(!</span><span class='n'>visited</span><span class='p'>.</span><span class='n'>add</span><span class='p'>(</span><span class='n'>current</span><span class='p'>))</span> <span class='k'>return</span>
    <span class='k'>for</span> <span class='p'>(</span><span class='n'>v</span> <span class='k'>in</span> <span class='n'>current</span><span class='p'>.</span><span class='n'>neighbors</span><span class='p'>)</span>
      <span class='n'>dfs</span><span class='p'>(</span><span class='n'>v</span><span class='p'>)</span>
  <span class='p'>}</span>

  <span class='n'>dfs</span><span class='p'>(</span><span class='n'>graph</span><span class='p'>.</span><span class='n'>vertices</span><span class='p'>[</span><span class='m'>0</span><span class='p'>])</span>
<span class='p'>}</span></code></pre><h4 id='functions.html_section-11'>멤버 함수<a class='anchor' href='#%23section-11'> </a></h4><p>멤버 함수는 클래스나 오브젝트 안에 정의한 함수이다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>class</span> <span class='nc'>Sample</span><span class='p'>()</span> <span class='p'>{</span>
  <span class='k'>fun</span> <span class='nf'>foo</span><span class='p'>()</span> <span class='p'>{</span> <span class='n'>print</span><span class='p'>(</span><span class='s'>&quot;Foo&quot;</span><span class='p'>)</span> <span class='p'>}</span>
<span class='p'>}</span></code></pre><p>멤버 함수를 호출할 때는 점 부호를 사용한다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>Sample</span><span class='p'>().</span><span class='n'>foo</span><span class='p'>()</span> <span class='c1'>// Sample 클래스의 인스턴스를 생성하고 foo 호출</span></code></pre><p>클래스와 멤버 오버라이딩에 대한 내용은 <a href='#classes.html'>클래스</a>와 <a href='#classes.html%23inheritance'>상속</a>을 참고한다.</p><h3 id='functions.html_section-12'>지네릭 함수<a class='anchor' href='#%23section-12'> </a></h3><p>함수는 함수 이름 앞에 화살괄호를 사용해서 지네릭 파라미터를 지정할 수 있다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='err'>&lt;</span><span class='nf'>T</span><span class='p'>&gt;</span> <span class='n'>singletonList</span><span class='p'>(</span><span class='n'>item</span><span class='p'>:</span> <span class='n'>T</span><span class='p'>):</span> <span class='n'>List</span><span class='p'>&lt;</span><span class='n'>T</span><span class='p'>&gt;</span> <span class='p'>{</span>
  <span class='c1'>// ...</span>
<span class='p'>}</span></code></pre><p>지네릭 함수에 대한 내용은 <a href='#generics.html'>지네릭</a>을 참고한다.</p><h3 id='functions.html_section-13'>인라인 함수<a class='anchor' href='#%23section-13'> </a></h3><p>인라인 함수는 <a href='#inline-functions.html'>여기</a>에서 설명한다.</p><h3 id='functions.html_section-14'>확장 함수<a class='anchor' href='#%23section-14'> </a></h3><p>확장 함수는 <a href='#extensions.html'>여기</a>에서 설명한다.</p><h3 id='functions.html_section-15'>고차 함수와 람다<a class='anchor' href='#%23section-15'> </a></h3><p>고차 함수와 람다는 <a href='#lambdas.html'>여기</a>에서 설명한다.</p><h3 id='functions.html_section-16'>꼬리 재귀 함수<a class='anchor' href='#%23section-16'> </a></h3><p>코틀린은 <a href='#https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FTail_call'>꼬리 재귀</a>로 알려진 함수형 프로그래밍 스타일을 지원한다.
꼬리 재귀는 재귀 함수를 스택오버플로우 걱정이 없는 루프로 바꾸는 알고리즘을 허용한다.
함수에 <code>tailrec</code> 제한자를 붙이고 컴파일러가 재귀를 최적화할 수 있는 요건을 충족하면 빠르고 효율적인 루프 기반 버전으로 바꾼다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>tailrec</span> <span class='k'>fun</span> <span class='nf'>findFixPoint</span><span class='p'>(</span><span class='n'>x</span><span class='p'>:</span> <span class='n'>Double</span> <span class='p'>=</span> <span class='m'>1.0</span><span class='p'>):</span> <span class='n'>Double</span>
        <span class='p'>=</span> <span class='k'>if</span> <span class='p'>(</span><span class='n'>x</span> <span class='p'>==</span> <span class='n'>Math</span><span class='p'>.</span><span class='n'>cos</span><span class='p'>(</span><span class='n'>x</span><span class='p'>))</span> <span class='n'>x</span> <span class='k'>else</span> <span class='n'>findFixPoint</span><span class='p'>(</span><span class='n'>Math</span><span class='p'>.</span><span class='n'>cos</span><span class='p'>(</span><span class='n'>x</span><span class='p'>))</span></code></pre><p>이 코드는 수학의 상수값인 코사인의 고정소수점을 계산한다. 이 코드는 1.0에서 시작해서 더 이상 값이 바뀌지 않을 때까지 Math.cos를 반복해서 호출한다. 결과는 0.7390851332151607이다. 이 코드는 다음의 전통적인 방식과 같다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>private</span> <span class='k'>fun</span> <span class='nf'>findFixPoint</span><span class='p'>():</span> <span class='n'>Double</span> <span class='p'>{</span>
    <span class='k'>var</span> <span class='py'>x</span> <span class='p'>=</span> <span class='m'>1.0</span>
    <span class='k'>while</span> <span class='p'>(</span><span class='k'>true</span><span class='p'>)</span> <span class='p'>{</span>
        <span class='k'>val</span> <span class='py'>y</span> <span class='p'>=</span> <span class='n'>Math</span><span class='p'>.</span><span class='n'>cos</span><span class='p'>(</span><span class='n'>x</span><span class='p'>)</span>
        <span class='k'>if</span> <span class='p'>(</span><span class='n'>x</span> <span class='p'>==</span> <span class='n'>y</span><span class='p'>)</span> <span class='k'>return</span> <span class='n'>y</span>
        <span class='n'>x</span> <span class='p'>=</span> <span class='n'>y</span>
    <span class='p'>}</span>
<span class='p'>}</span></code></pre><p><code>tailrec</code> 제한자가 가능하려면 함수는 반드시 마지막에 자신을 호출해야 한다. 재귀 호출 뒤에 다른 코드가 있다면 꼬리 재귀를 사용할 수 없다. try/catch/finally 블록에서는 사용할 수 없다. 현재 재귀 호출은 JVM 기반에서만 지원한다.</p>
              </article>
          
              <article id="lambdas.html" class="page-content">
                <h2 id='lambdas.html_section'>고차 함수와 람다<a class='anchor' href='#%23section'> </a></h2><h3 id='lambdas.html_section-1'>고차 함수<a class='anchor' href='#%23section-1'> </a></h3><p>고차 함수는 파라미터로 함수를 받거나 함수를 리턴하는 함수이다.
좋은 예가 <code>lock()</code>이다. 이 함수는 락 오브젝트와 함수를 받아 락을 구하고 함수를 실행하고 락을 해제한다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='err'>&lt;</span><span class='nf'>T</span><span class='p'>&gt;</span> <span class='n'>lock</span><span class='p'>(</span><span class='n'>lock</span><span class='p'>:</span> <span class='n'>Lock</span><span class='p'>,</span> <span class='n'>body</span><span class='p'>:</span> <span class='p'>()</span> <span class='p'>-&gt;</span> <span class='n'>T</span><span class='p'>):</span> <span class='n'>T</span> <span class='p'>{</span>
  <span class='n'>lock</span><span class='p'>.</span><span class='n'>lock</span><span class='p'>()</span>
  <span class='k'>try</span> <span class='p'>{</span>
    <span class='k'>return</span> <span class='n'>body</span><span class='p'>()</span>
  <span class='p'>}</span>
  <span class='k'>finally</span> <span class='p'>{</span>
    <span class='n'>lock</span><span class='p'>.</span><span class='n'>unlock</span><span class='p'>()</span>
  <span class='p'>}</span>
<span class='p'>}</span></code></pre><p>위 코드를 살펴보자. <code>body</code>는 <a href='#%23function-types'>함수 타입</a>인 <code>() -&gt; T</code>를 갖는다. body에는 파라미터가 없고 <code>T</code> 타입 값을 리턴하는 함수를 전달해야 한다.
<code>lock</code>으로 보호하는 동안 <em class='keyword'>try</em> 블록에서 body 함수를 실행하고 그 결과를 <code>lock()</code> 함수의 결과로 리턴한다.</p><p><code>lock()</code> 함수를 호출하려면 인자로 다른 함수를 전달하면 된다(<a href='#reflection.html%23function-references'>함수 레퍼런스</a> 참고).</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>toBeSynchronized</span><span class='p'>()</span> <span class='p'>=</span> <span class='n'>sharedResource</span><span class='p'>.</span><span class='n'>operation</span><span class='p'>()</span>

<span class='k'>val</span> <span class='py'>result</span> <span class='p'>=</span> <span class='n'>lock</span><span class='p'>(</span><span class='n'>lock</span><span class='p'>,</span> <span class='o'>::</span><span class='n'>toBeSynchronized</span><span class='p'>)</span></code></pre><p>다른 간편한 방법은 <a href='#%23lambda-expressions-and-anonymous-functions'>람다 식</a>을 전달하는 것이다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>result</span> <span class='p'>=</span> <span class='n'>lock</span><span class='p'>(</span><span class='n'>lock</span><span class='p'>,</span> <span class='p'>{</span> <span class='n'>sharedResource</span><span class='p'>.</span><span class='n'>operation</span><span class='p'>()</span> <span class='p'>})</span></code></pre><p>람다 식은 <a href='#%23lambda-expressions-and-anonymous-functions'>뒤에서</a> 설명하지만, 이 절을 이해하는데 필요한 람다 식에 대한 내용을 아래 요약했다.</p><ul>
  <li>람다 식은 항상 중괄호로 둘러 싼다.</li>
  <li><code>-&gt;</code> 전에 파라미터를(존재하면) 선언하고(파라미터 타입은 생략 가능),</li>
  <li><code>-&gt;</code> 뒤에 몸체가 온다(존재하면).</li>
</ul><p>코틀린에서 함수에 마지막 파라미터로 함수를 전달하면 괄호 밖에 파라미터를 지정할 수 있다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>lock</span> <span class='p'>(</span><span class='n'>lock</span><span class='p'>)</span> <span class='p'>{</span>
  <span class='n'>sharedResource</span><span class='p'>.</span><span class='n'>operation</span><span class='p'>()</span>
<span class='p'>}</span></code></pre><p>고차 함수의 다른 예는 <code>map()</code>이다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='err'>&lt;</span><span class='nf'>T</span><span class='p'>,</span> <span class='n'>R</span><span class='p'>&gt;</span> <span class='n'>List</span><span class='p'>&lt;</span><span class='n'>T</span><span class='p'>&gt;.</span><span class='n'>map</span><span class='p'>(</span><span class='n'>transform</span><span class='p'>:</span> <span class='p'>(</span><span class='n'>T</span><span class='p'>)</span> <span class='p'>-&gt;</span> <span class='n'>R</span><span class='p'>):</span> <span class='n'>List</span><span class='p'>&lt;</span><span class='n'>R</span><span class='p'>&gt;</span> <span class='p'>{</span>
  <span class='k'>val</span> <span class='py'>result</span> <span class='p'>=</span> <span class='n'>arrayListOf</span><span class='p'>&lt;</span><span class='n'>R</span><span class='p'>&gt;()</span>
  <span class='k'>for</span> <span class='p'>(</span><span class='n'>item</span> <span class='k'>in</span> <span class='k'>this</span><span class='p'>)</span>
    <span class='n'>result</span><span class='p'>.</span><span class='n'>add</span><span class='p'>(</span><span class='n'>transform</span><span class='p'>(</span><span class='n'>item</span><span class='p'>))</span>
  <span class='k'>return</span> <span class='n'>result</span>
<span class='p'>}</span></code></pre><p>이 함수는 다음과 같이 호출할 수 있다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>doubled</span> <span class='p'>=</span> <span class='n'>ints</span><span class='p'>.</span><span class='n'>map</span> <span class='p'>{</span> <span class='n'>it</span> <span class='p'>-&gt;</span> <span class='n'>it</span> <span class='p'>*</span> <span class='m'>2</span> <span class='p'>}</span></code></pre><p>함수를 호출할 때 람다가 유일한 인자일 경우 함수 호출시 사용하는 괄호를 완전히 생략할 수 있다.</p><p>다른 유용한 규칙으로, 함수 리터럴의 파라미터가 한 개면 파라미터 선언을 (<code>-&gt;</code> 포함해서) 생략할 수 있고 파라미터 이름은 <code>it</code>이 된다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>ints</span><span class='p'>.</span><span class='n'>map</span> <span class='p'>{</span> <span class='n'>it</span> <span class='p'>*</span> <span class='m'>2</span> <span class='p'>}</span></code></pre><p>이 규칙은 <a href='#http%3A%2F%2Fmsdn.microsoft.com%2Fen-us%2Flibrary%2Fbb308959.aspx'>LINQ-스타일</a>로 코드를 작성할 수 있도록 해 준다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>strings</span><span class='p'>.</span><span class='n'>filter</span> <span class='p'>{</span> <span class='n'>it</span><span class='p'>.</span><span class='n'>length</span> <span class='p'>==</span> <span class='m'>5</span> <span class='p'>}.</span><span class='n'>sortBy</span> <span class='p'>{</span> <span class='n'>it</span> <span class='p'>}.</span><span class='n'>map</span> <span class='p'>{</span> <span class='n'>it</span><span class='p'>.</span><span class='n'>toUpperCase</span><span class='p'>()</span> <span class='p'>}</span></code></pre><h3 id='lambdas.html_section-2'>인라인 함수<a class='anchor' href='#%23section-2'> </a></h3><p>때로는 <a href='#inline-functions.html'>인라인 함수</a>를 사용하면 고차 함수의 성능을 향상할 수 있는 이점이 있다.</p><h3 id='lambdas.html_section-3'>람다 식과 임의 함수<a class='anchor' href='#%23section-3'> </a></h3><p>람다 식 또는 임의 함수는 “함수 리터럴”로 함수 선언 없이 식으로 바로 전달할 수 있다. 다음 예를 보자:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>max</span><span class='p'>(</span><span class='n'>strings</span><span class='p'>,</span> <span class='p'>{</span> <span class='n'>a</span><span class='p'>,</span> <span class='n'>b</span> <span class='p'>-&gt;</span> <span class='n'>a</span><span class='p'>.</span><span class='n'>length</span><span class='p'>()</span> <span class='p'>&lt;</span> <span class='n'>b</span><span class='p'>.</span><span class='n'>length</span><span class='p'>()</span> <span class='p'>})</span></code></pre><p><code>max</code> 함수는 두 번째 인자로 함수 값을 받는 고차 함수이다.
두 번째 인자는 그 자체가 함수인 함수 리터럴 식이다. 함수로서 이 식은 다음과 동일하다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>compare</span><span class='p'>(</span><span class='n'>a</span><span class='p'>:</span> <span class='n'>String</span><span class='p'>,</span> <span class='n'>b</span><span class='p'>:</span> <span class='n'>String</span><span class='p'>):</span> <span class='n'>Boolean</span> <span class='p'>=</span> <span class='n'>a</span><span class='p'>.</span><span class='n'>length</span><span class='p'>()</span> <span class='p'>&lt;</span> <span class='n'>b</span><span class='p'>.</span><span class='n'>length</span><span class='p'>()</span></code></pre><h4 id='lambdas.html_section-4'>함수 타입<a class='anchor' href='#%23section-4'> </a></h4><p>함수가 다른 함수를 파라미터로 받으려면 그 파라미터를 함수로 지정해야 한다.
예를 들어 위에서 보여준 <code>max</code> 함수는 다음과 같이 정의한다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='err'>&lt;</span><span class='nf'>T</span><span class='p'>&gt;</span> <span class='n'>max</span><span class='p'>(</span><span class='n'>collection</span><span class='p'>:</span> <span class='n'>Collection</span><span class='p'>&lt;</span><span class='n'>T</span><span class='p'>&gt;,</span> <span class='n'>less</span><span class='p'>:</span> <span class='p'>(</span><span class='n'>T</span><span class='p'>,</span> <span class='n'>T</span><span class='p'>)</span> <span class='p'>-&gt;</span> <span class='n'>Boolean</span><span class='p'>):</span> <span class='n'>T</span><span class='p'>?</span> <span class='p'>{</span>
  <span class='k'>var</span> <span class='py'>max</span><span class='p'>:</span> <span class='n'>T</span><span class='p'>?</span> <span class='p'>=</span> <span class='k'>null</span>
  <span class='k'>for</span> <span class='p'>(</span><span class='n'>it</span> <span class='k'>in</span> <span class='n'>collection</span><span class='p'>)</span>
    <span class='k'>if</span> <span class='p'>(</span><span class='n'>max</span> <span class='p'>==</span> <span class='k'>null</span> <span class='p'>||</span> <span class='n'>less</span><span class='p'>(</span><span class='n'>max</span><span class='p'>,</span> <span class='n'>it</span><span class='p'>))</span>
      <span class='n'>max</span> <span class='p'>=</span> <span class='n'>it</span>
  <span class='k'>return</span> <span class='n'>max</span>
<span class='p'>}</span></code></pre><p><code>less</code> 파라미터 타입은 <code>(T, T) -&gt; Boolean</code> 함수 타입이다. 이 함수는 두 개의 <code>T</code> 타입 파라미터를 갖고 <code>Boolean</code> 타입을 리턴하며 첫 번째 파라미터가 두 번째 파라미터보다 작으면 true를 리턴한다.</p><p>코드에서 네 번째 줄을 보면 <code>less</code>를 함수로 사용한다. 함수를 호출할 때 두 개의 <code>T</code> 타입 인자를 전달하고 있다.</p><p>함수 타입은 위와 같이 작성하거나, 각 파라미터에 의미를 문서화하고 싶다면 네임드 파라미터를 사용해서 작성한다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>compare</span><span class='p'>:</span> <span class='p'>(</span><span class='n'>x</span><span class='p'>:</span> <span class='n'>T</span><span class='p'>,</span> <span class='n'>y</span><span class='p'>:</span> <span class='n'>T</span><span class='p'>)</span> <span class='p'>-&gt;</span> <span class='n'>Int</span> <span class='p'>=</span> <span class='p'>...</span></code></pre><h4 id='lambdas.html_section-5'>람다 식 구문<a class='anchor' href='#%23section-5'> </a></h4><p>람다 식(함수 타입 리터럴)의 완전한 구문은 다음과 같다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>sum</span> <span class='p'>=</span> <span class='p'>{</span> <span class='n'>x</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>,</span> <span class='n'>y</span><span class='p'>:</span> <span class='n'>Int</span> <span class='p'>-&gt;</span> <span class='n'>x</span> <span class='p'>+</span> <span class='n'>y</span> <span class='p'>}</span></code></pre><p>람다 식은 항상 괄호로 둘러 싼다,
완전한 구문 형식에서는 괄혼 안에 파라미터 선언이 위치하며 타입 지정을 생략할 수 있다,
<code>-&gt;</code> 부호 다음에 몸체가 위치한다.
생략 가능한 것을 모두 생략하면 다음과 같이 작성할 수 있다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>sum</span><span class='p'>:</span> <span class='p'>(</span><span class='n'>Int</span><span class='p'>,</span> <span class='n'>Int</span><span class='p'>)</span> <span class='p'>-&gt;</span> <span class='n'>Int</span> <span class='p'>=</span> <span class='p'>{</span> <span class='n'>x</span><span class='p'>,</span> <span class='n'>y</span> <span class='p'>-&gt;</span> <span class='n'>x</span> <span class='p'>+</span> <span class='n'>y</span> <span class='p'>}</span></code></pre><p>람다 식은 파라미터를 한 개만 갖는 경우가 빈번하다.
코틀린이 그 시그너처를 알아낼 수 있으면 파라미터 선언을 생략할 수 있으며,
코틀린이 자동으로 <code>it</code> 이름의 파라미터를 선언한다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>ints</span><span class='p'>.</span><span class='n'>filter</span> <span class='p'>{</span> <span class='n'>it</span> <span class='p'>&gt;</span> <span class='m'>0</span> <span class='p'>}</span> <span class='c1'>// 이 리터럴의 타입은 &#39;(it: Int) -&gt; Boolean&#39;이다.</span></code></pre><p>함수의 마지막 파라미터가 함수면 인자 목록을 갖는 괄호 밖에 람다 식을 전달할 수 있다.
<a href='#grammar.html%23call-suffix'>callSuffix</a> 문법을 참고한다.</p><h4 id='lambdas.html_section-6'>임의 함수<a class='anchor' href='#%23section-6'> </a></h4><p>위 람다 식 구문에서 빠진 게 하나 있는데 그것은 바로 함수 리턴 타입으로 지정하는 방법이다.
많은 경우 리턴 타입을 자동으로 유추하기 때문에 지정하지 않아도 된다.
하지만 명시적으로 지정하고 싶다면 <em>임의 함수</em> 구문을 사용할 수 있다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span><span class='p'>(</span><span class='n'>x</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>,</span> <span class='n'>y</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>):</span> <span class='n'>Int</span> <span class='p'>=</span> <span class='n'>x</span> <span class='p'>+</span> <span class='n'>y</span></code></pre><p>임의 함수는 이름이 없다는 것을 제외하면 일반 함수 선언과 비슷하다.
몸체는 (위 코드처럼) 식이거나 블록일 수 있다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span><span class='p'>(</span><span class='n'>x</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>,</span> <span class='n'>y</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>):</span> <span class='n'>Int</span> <span class='p'>{</span>
  <span class='k'>return</span> <span class='n'>x</span> <span class='p'>+</span> <span class='n'>y</span>
<span class='p'>}</span></code></pre><p>일반 함수와 동일한 방법으로 파라미터와 리턴 타입을 지정한다. 문맥에서 파라미터 타입을 유추할 수 있으면 타입을 생략할 수 있다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>ints</span><span class='p'>.</span><span class='n'>filter</span><span class='p'>(</span><span class='k'>fun</span><span class='p'>(</span><span class='n'>item</span><span class='p'>)</span> <span class='p'>=</span> <span class='n'>item</span> <span class='p'>&gt;</span> <span class='m'>0</span><span class='p'>)</span></code></pre><p>임의 함수에 대한 리턴 타입 유추는 일반 함수와 동일하게 동작한다.
식 몸체를 가진 임의 함수는 리턴 타입을 자동으로 유추한다. 블록 몸체를 가진 임의 함수는 명시적으로 리턴 타입을 지정해야 한다(아니면 <code>Unit</code>으로 가정한다).</p><p>임의 함수 파라미터는 항상 괄호 안에 전달해야 한다. 괄호 밖에 함수를 위치시킬 수 있는 약식 구문은 람다 식만 가능하다.</p><p>람다 식과 임의 함수의 또 다른 차이점은 <a href='#inline-functions.html%23non-local-returns'>비-로컬 리턴</a>의 동작에 있다.
라벨 없는 <em class='keyword'>return</em> 문은 항상 <em class='keyword'>fun</em> 키워드로 선언한 함수에서 리턴한다.
이는 람다 식 안에서 <em class='keyword'>return</em>을 사용하면 둘러 싼 함수에서 리턴하는 반면에
임의 함수 안에서 <em class='keyword'>return</em>을 사용하면 임의 함수 자체에서 리턴하는 것을 의미한다.</p><h4 id='lambdas.html_section-7'>클로저<a class='anchor' href='#%23section-7'> </a></h4><p>람다 식 또는 임의 함수 (또는 <a href='#functions.html%23local-functions'>로컬 함수</a>) 그리고 <a href='#object-declarations.html%23object-expressions'>오브젝트 식</a>)은
그것의 _클로저(즉 외부 범위에 선언한 변수)_에 접근할 수 있다.
자바와 달리 클로저로 캡처한 변수를 수정할 수 있다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>var</span> <span class='py'>sum</span> <span class='p'>=</span> <span class='m'>0</span>
<span class='n'>ints</span><span class='p'>.</span><span class='n'>filter</span> <span class='p'>{</span> <span class='n'>it</span> <span class='p'>&gt;</span> <span class='m'>0</span> <span class='p'>}.</span><span class='n'>forEach</span> <span class='p'>{</span>
  <span class='n'>sum</span> <span class='p'>+=</span> <span class='n'>it</span>
<span class='p'>}</span>
<span class='n'>print</span><span class='p'>(</span><span class='n'>sum</span><span class='p'>)</span></code></pre><h4 id='lambdas.html_section-8'>리시버를 갖는 함수 리터럴<a class='anchor' href='#%23section-8'> </a></h4><p>코틀린은 함수 리터럴을 실행할 때 _리서버 객체_를 지정할 수 있다.
함수 리터럴 몸체 안에서 추가 한정자 없이 리시버 객체의 메서드를 호출할 수 있다.
함수 몸체 안에서 리시버 객체의 멤버에 접근할 수 있는 것은 확장 함수와 유사하다.
이를 사용하는 가장 중요한 한 가지 예가 <a href='#type-safe-builders.html'>Type-safe Groovy-style builders</a>이다.</p><p>이런 함수 리터럴 타입은 리서버를 갖는 함수 타입이다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>sum</span> <span class='p'>:</span> <span class='n'>Int</span><span class='p'>.(</span><span class='n'>other</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>)</span> <span class='p'>-&gt;</span> <span class='n'>Int</span></code></pre><p>이제 리시버 객체의 함수처럼 함수 리터럴을 호출할 수 있다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='m'>1.</span><span class='n'>sum</span><span class='p'>(</span><span class='m'>2</span><span class='p'>)</span></code></pre><p>임의 함수 구문을 사용하면 함수 리터럴에 직접 리시버 타입을 지정할 수 있다.
이는 리시버를 갖는 함수 타입 변수를 선언하고 이를 나중에 사용해야 할 때 유용하다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>sum</span> <span class='p'>=</span> <span class='k'>fun</span> <span class='nf'>Int</span><span class='p'>.(</span><span class='n'>other</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>):</span> <span class='n'>Int</span> <span class='p'>=</span> <span class='k'>this</span> <span class='p'>+</span> <span class='n'>other</span></code></pre><p>문맥에서 리시버 타입을 유추할 수 있다면 람다 식을 리시버를 가진 함수 리터럴로 사용할 수 있다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>class</span> <span class='nc'>HTML</span> <span class='p'>{</span>
    <span class='k'>fun</span> <span class='nf'>body</span><span class='p'>()</span> <span class='p'>{</span> <span class='p'>...</span> <span class='p'>}</span>
<span class='p'>}</span>

<span class='k'>fun</span> <span class='nf'>html</span><span class='p'>(</span><span class='n'>init</span><span class='p'>:</span> <span class='n'>HTML</span><span class='p'>.()</span> <span class='p'>-&gt;</span> <span class='n'>Unit</span><span class='p'>):</span> <span class='n'>HTML</span> <span class='p'>{</span>
  <span class='k'>val</span> <span class='py'>html</span> <span class='p'>=</span> <span class='n'>HTML</span><span class='p'>()</span>  <span class='c1'>// 리시버 객체 생성</span>
  <span class='n'>html</span><span class='p'>.</span><span class='n'>init</span><span class='p'>()</span>        <span class='c1'>// 람다에 리시버 객체를 전달</span>
  <span class='k'>return</span> <span class='n'>html</span>
<span class='p'>}</span>


<span class='n'>html</span> <span class='p'>{</span>       <span class='c1'>// 리시버를 가진 람다 시작</span>
    <span class='n'>body</span><span class='p'>()</span>   <span class='c1'>// 리시버 객체의 메서드 호출</span>
<span class='p'>}</span></code></pre>
              </article>
          
              <article id="inline-functions.html" class="page-content">
                <h2 id='inline-functions.html_section'>인라인 함수<a class='anchor' href='#%23section'> </a></h2><p><a href='#lambdas.html'>고차 함수</a>를 사용하면 런타임에 어느 정도 불이익이 발생한다. 각 함수는 객체이고 함수 몸체에서 접근하는 변수를 캡처한다.
(함수 객체와 클래스를 위한)메모리 할당과 버추얼 호출로 런타임에 부하가 발생한다.</p><p>하지만 많은 경우 람다식을 인라인해서 이런 부하를 제거할 수 있다.
위의 <code>lock()</code> 함수가 이런 상황의 좋은 예이다. <code>lock()</code> 함수는 호출 위치에 쉽게 인라인할 수 있다.
다음을 보자.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>lock</span><span class='p'>(</span><span class='n'>l</span><span class='p'>)</span> <span class='p'>{</span> <span class='n'>foo</span><span class='p'>()</span> <span class='p'>}</span></code></pre><p>파라미터를 위한 함수 객체를 생성하고 호출을 생성하는 대신 컴파일러는 다음 코드를 만들어낼 수 있다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>l</span><span class='p'>.</span><span class='n'>lock</span><span class='p'>()</span>
<span class='k'>try</span> <span class='p'>{</span>
  <span class='n'>foo</span><span class='p'>()</span>
<span class='p'>}</span>
<span class='k'>finally</span> <span class='p'>{</span>
  <span class='n'>l</span><span class='p'>.</span><span class='n'>unlock</span><span class='p'>()</span>
<span class='p'>}</span></code></pre><p>이게 우리가 애초에 원한 것이다. 그렇지 않나?</p><p>컴파일러가 이렇게 할 수 있으려면 <code>lock()</code> 함수에 <code>inline</code> 제한자를 붙이면 된다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>inline</span> <span class='k'>fun</span> <span class='nf'>lock</span><span class='p'>&lt;</span><span class='n'>T</span><span class='p'>&gt;(</span><span class='n'>lock</span><span class='p'>:</span> <span class='n'>Lock</span><span class='p'>,</span> <span class='n'>body</span><span class='p'>:</span> <span class='p'>()</span> <span class='p'>-&gt;</span> <span class='n'>T</span><span class='p'>):</span> <span class='n'>T</span> <span class='p'>{</span>
  <span class='c1'>// ...</span>
<span class='p'>}</span></code></pre><p><code>inline</code> 제한자는 함수 자체와 함수에 전달하는 람다에 영향을 준다. 이것 모두 호출 위치에 인라인 된다.</p><p>인라인을 하면 생성된 코드가 증가할 수 있다. 하지만 합리적으로 잘 활용하면(큰 함수는 인라인하지 않는 식으로) 성능에서 (특히 루프의 “megamorphic” 호출 위치는 더 많은) 보상을 받게 된다.</p><h3 id='inline-functions.html_noinline'>noinline<a class='anchor' href='#%23noinline'> </a></h3><p>인라인 함수에 전달된 람다 중 일부만 인라인 되길 원하면 <code>noinline</code> 제한자로 함수 파라미터를 지정하면 된다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>inline</span> <span class='k'>fun</span> <span class='nf'>foo</span><span class='p'>(</span><span class='n'>inlined</span><span class='p'>:</span> <span class='p'>()</span> <span class='p'>-&gt;</span> <span class='n'>Unit</span><span class='p'>,</span> <span class='n'>noinline</span> <span class='n'>notInlined</span><span class='p'>:</span> <span class='p'>()</span> <span class='p'>-&gt;</span> <span class='n'>Unit</span><span class='p'>)</span> <span class='p'>{</span>
  <span class='c1'>// ...</span>
<span class='p'>}</span></code></pre><p>인라인 가능 람다는 인라인 함수 안에서만 호출할 수 있고 인라인 가능 인자로만 전달할 수 있다.
하지만, <code>noinline</code>에 전달한 람다는 필드에 저장하거나 인자로 전달하는 등 원하는 방식으로 처리할 수 있다.</p><p>인라인 함수에 인라인 가능한 함수 파라미터가 없고 <a href='#%23reified-type-parameters'>reified 타입 파라미터</a>가 없으면,
컴파일러는 그 인라인 함수가 이점이 없다는 경고를 발생한다(인라인이 필요하다고 확신하면 이 경고를 무시해도 된다).</p><h3 id='inline-functions.html_section-1'>비-로컬 리턴<a class='anchor' href='#%23section-1'> </a></h3><p>코틀린에서는 이름을 가진 함수나 임의 함수에서 나가려면 한정하지 않은 일반 <code>return</code>만 사용할 수 있다.
이는 람다에서 나가려면 <a href='#returns.html%23return-at-labels'>라벨</a>을 사용해야 한다는 것을 의미한다.
람다 안에서는 단순 <code>return</code>은 허용하지 않는데 그 이유는 람다는 둘러싼 함수를 리턴할 수 없기 때문이다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>foo</span><span class='p'>()</span> <span class='p'>{</span>
  <span class='n'>ordinaryFunction</span> <span class='p'>{</span>
     <span class='k'>return</span> <span class='c1'>// 에러: `foo`를 여기서 리턴할 수 없다</span>
  <span class='p'>}</span>
<span class='p'>}</span></code></pre><p>만약 람다를 전달한 함수가 인라인되면 리턴도 같이 인라인된다. 그래서 다음을 허용한다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>foo</span><span class='p'>()</span> <span class='p'>{</span>
  <span class='n'>inlineFunction</span> <span class='p'>{</span>
    <span class='k'>return</span> <span class='c1'>// OK: 람다를 인라인한다</span>
  <span class='p'>}</span>
<span class='p'>}</span></code></pre><p>이 리턴(람다에 위치하지만 둘러싼 함수를 나가는)을 <em>비-로컬</em> 리턴이라 부른다.
이런 종류의 리턴을 인라인 함수가 둘러싼 루프에서 사용하곤 한다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>hasZeros</span><span class='p'>(</span><span class='n'>ints</span><span class='p'>:</span> <span class='n'>List</span><span class='p'>&lt;</span><span class='n'>Int</span><span class='p'>&gt;):</span> <span class='n'>Boolean</span> <span class='p'>{</span>
  <span class='n'>ints</span><span class='p'>.</span><span class='n'>forEach</span> <span class='p'>{</span>
    <span class='k'>if</span> <span class='p'>(</span><span class='n'>it</span> <span class='p'>==</span> <span class='m'>0</span><span class='p'>)</span> <span class='k'>return</span> <span class='k'>true</span> <span class='c1'>// hasZeros에서 리턴</span>
  <span class='p'>}</span>
  <span class='k'>return</span> <span class='k'>false</span>
<span class='p'>}</span></code></pre><p>일부 인라인 함수는 파라미터로 전달받은 람다를 호출할 때 함수 몸체에서 직접 호출하지 않고 다른 실행 컨텍스트를 통해(예, 로컬 객체나 중첩 함수) 호출해야 할 때가 있다.
이 경우 람다 안에서 비-로컬 흐름을 제어할 수 없다.
이를 지정하려면 람다 파라미터에 <code>crossinline</code> 제한자를 붙이면 된다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>inline</span> <span class='k'>fun</span> <span class='nf'>f</span><span class='p'>(</span><span class='n'>crossinline</span> <span class='n'>body</span><span class='p'>:</span> <span class='p'>()</span> <span class='p'>-&gt;</span> <span class='n'>Unit</span><span class='p'>)</span> <span class='p'>{</span>
    <span class='k'>val</span> <span class='py'>f</span> <span class='p'>=</span> <span class='k'>object</span><span class='p'>:</span> <span class='n'>Runnable</span> <span class='p'>{</span>
        <span class='k'>override</span> <span class='k'>fun</span> <span class='nf'>run</span><span class='p'>()</span> <span class='p'>=</span> <span class='n'>body</span><span class='p'>()</span>
    <span class='p'>}</span>
    <span class='c1'>// ...</span>
<span class='p'>}</span></code></pre><blockquote>
  <p>인라인된 람다에서 <code>break</code>와 <code>continue</code>는 아직 사용할 수 없는데, 앞으로 지원할 계횏이다.</p>
</blockquote><h3 id='inline-functions.html_reified--'>Reified 타입 파라미터<a class='anchor' href='#%23reified--'> </a></h3><p>때때로 파라미터로 전달한 타입에 접근해야 할 때가 있다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='err'>&lt;</span><span class='nf'>T</span><span class='p'>&gt;</span> <span class='n'>TreeNode</span><span class='p'>.</span><span class='n'>findParentOfType</span><span class='p'>(</span><span class='n'>clazz</span><span class='p'>:</span> <span class='n'>Class</span><span class='p'>&lt;</span><span class='n'>T</span><span class='p'>&gt;):</span> <span class='n'>T</span><span class='p'>?</span> <span class='p'>{</span>
    <span class='k'>var</span> <span class='py'>p</span> <span class='p'>=</span> <span class='n'>parent</span>
    <span class='k'>while</span> <span class='p'>(</span><span class='n'>p</span> <span class='p'>!=</span> <span class='k'>null</span> <span class='p'>&amp;&amp;</span> <span class='p'>!</span><span class='n'>clazz</span><span class='p'>.</span><span class='n'>isInstance</span><span class='p'>(</span><span class='n'>p</span><span class='p'>))</span> <span class='p'>{</span>
        <span class='n'>p</span> <span class='p'>=</span> <span class='n'>p</span><span class='o'>?.</span><span class='n'>parent</span>
    <span class='p'>}</span>
    <span class='n'>@Suppress</span><span class='p'>(</span><span class='s'>&quot;UNCHECKED_CAST&quot;</span><span class='p'>)</span>
    <span class='k'>return</span> <span class='n'>p</span> <span class='k'>as</span> <span class='n'>T</span>
<span class='p'>}</span></code></pre><p>이 코드는 노드가 특정 타입을 가졌는지 확인하기 위해 트리를 탐색하고 리플렉션을 사용한다.
모두 좋은데, 호출하는 코드가 이쁘지(pretty ^^) 않다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>myTree</span><span class='p'>.</span><span class='n'>findParentOfType</span><span class='p'>(</span><span class='n'>MyTreeNodeType</span><span class='o'>::</span><span class='k'>class</span><span class='p'>.</span><span class='n'>java</span><span class='p'>)</span></code></pre><p>실제로는 이 함수에 단순히 타입을 전달해서 다음과 같이 호출하길 원하는 것이다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>myTree</span><span class='p'>.</span><span class='n'>findParentOfType</span><span class='p'>&lt;</span><span class='n'>MyTreeNodeType</span><span class='p'>&gt;()</span></code></pre><p>이렇게 할 수 있도록 인라인 함수는 <em>reified 타입 파라미터</em>를 지원한다. 이를 사용한 코드는 다음과 같다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>inline</span> <span class='k'>fun</span> <span class='err'>&lt;</span><span class='nf'>reified</span> <span class='n'>T</span><span class='p'>&gt;</span> <span class='n'>TreeNode</span><span class='p'>.</span><span class='n'>findParentOfType</span><span class='p'>():</span> <span class='n'>T</span><span class='p'>?</span> <span class='p'>{</span>
    <span class='k'>var</span> <span class='py'>p</span> <span class='p'>=</span> <span class='n'>parent</span>
    <span class='k'>while</span> <span class='p'>(</span><span class='n'>p</span> <span class='p'>!=</span> <span class='k'>null</span> <span class='p'>&amp;&amp;</span> <span class='n'>p</span> <span class='p'>!</span><span class='k'>is</span> <span class='n'>T</span><span class='p'>)</span> <span class='p'>{</span>
        <span class='n'>p</span> <span class='p'>=</span> <span class='n'>p</span><span class='o'>?.</span><span class='n'>parent</span>
    <span class='p'>}</span>
    <span class='k'>return</span> <span class='n'>p</span> <span class='k'>as</span> <span class='n'>T</span>
<span class='p'>}</span></code></pre><p>타입 파라미터에 <code>reified</code> 제한자를 적용하면, 마치 클래스처럼 타입 파라미터에 접근할 수 있다.
인라인 함수이므로 리플렉션이 필요 없고 <code>!is</code>나<code>as</code>와 같은 일반 연산자가 동작한다.
또한 앞서 언급한 <code>myTree.findParentOfType&lt;MyTreeNodeType&gt;()</code>처럼 호출할 수 있댜:</p><p>reified 타입 파라미터에 리플렉션을 사용할 수 있다. 많은 경우 리플렉션이 필요 없긴 하지만 말이다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>inline</span> <span class='k'>fun</span> <span class='err'>&lt;</span><span class='nf'>reified</span> <span class='n'>T</span><span class='p'>&gt;</span> <span class='n'>membersOf</span><span class='p'>()</span> <span class='p'>=</span> <span class='n'>T</span><span class='o'>::</span><span class='k'>class</span><span class='p'>.</span><span class='n'>members</span>

<span class='k'>fun</span> <span class='nf'>main</span><span class='p'>(</span><span class='n'>s</span><span class='p'>:</span> <span class='n'>Array</span><span class='p'>&lt;</span><span class='n'>String</span><span class='p'>&gt;)</span> <span class='p'>{</span>
  <span class='n'>println</span><span class='p'>(</span><span class='n'>membersOf</span><span class='p'>&lt;</span><span class='n'>StringBuilder</span><span class='p'>&gt;().</span><span class='n'>joinToString</span><span class='p'>(</span><span class='s'>&quot;\n&quot;</span><span class='p'>))</span>
<span class='p'>}</span></code></pre><p>(인라인이 아닌) 일반 함수는 reified 파라미터를 가질 수 없다.
런타임 표현을 갖지 않는 타입(reified 타입 파라미터가 아니거나 <code>Nothing</code>과 같은 가공 타입)은
reified 타입 파라미터를 위한 인자로 사용할 수 없다.</p><p>저수준 설명은 <a href='#https%3A%2F%2Fgithub.com%2FJetBrains%2Fkotlin%2Fblob%2Fmaster%2Fspec-docs%2Freified-type-parameters.md'>스펙 문서</a> 참고한다.</p>
              </article>
          

        </section>
    

    
        <section>
          <h1 id="%EA%B8%B0%ED%83%80"
              class="section-title">
            기타
          </h1>

          
              <article id="multi-declarations.html" class="page-content">
                <h2 id='multi-declarations.html_section'>분리 선언<a class='anchor' href='#%23section'> </a></h2><p>다음 코드처럼 객체의 값을 여러 변수로 분리하면 편리할 때가 있다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='err'>(</span><span class='py'>name</span><span class='p'>,</span> <span class='n'>age</span><span class='p'>)</span> <span class='p'>=</span> <span class='n'>person</span></code></pre><p>이 구문을 _분리 선언(destructuring declaration)_이라고 부른다. 분리 선언은 한 번에 여러 변수를 생성한다.
위 코드는 <code>name</code>과 <code>age</code> 두 변수를 선언하고 각 변수를 독립적으로 사용할 수 있다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>println</span><span class='p'>(</span><span class='n'>name</span><span class='p'>)</span>
<span class='n'>println</span><span class='p'>(</span><span class='n'>age</span><span class='p'>)</span></code></pre><p>분리 선언은 다음 코드로 컴파일된다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>name</span> <span class='p'>=</span> <span class='n'>person</span><span class='p'>.</span><span class='n'>component1</span><span class='p'>()</span>
<span class='k'>val</span> <span class='py'>age</span> <span class='p'>=</span> <span class='n'>person</span><span class='p'>.</span><span class='n'>component2</span><span class='p'>()</span></code></pre><p><code>component1()</code>과 <code>component2()</code> 함수는 코틀린에서 폭넓게 사용하는 _원칙(principle of conventions)_을 적용한 다른 예이다(<code>+</code>와 <code>*</code> 같은 연산자, <em class='keyword'>for</em>-루프 등을 참고).
분리 선언의 우측에 위치한 것은 필요한 개수의 component 함수를 갖고 있으면 된다.
물론 <code>component3()</code>과 <code>component4()</code> 등 두 개 이상도 가능하다.</p><p>분린 선언에서 사용하려면 <code>componentN()</code> 함수에 <code>operator</code> 키워드를 적용해야 한다.</p><p><em class='keyword'>for</em>-루프에도 분리 선언이 가능하다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>for</span> <span class='p'>((</span><span class='n'>a</span><span class='p'>,</span> <span class='n'>b</span><span class='p'>)</span> <span class='k'>in</span> <span class='n'>collection</span><span class='p'>)</span> <span class='p'>{</span> <span class='p'>...</span> <span class='p'>}</span></code></pre><p>변수 <code>a</code>와 <code>b</code>는 콜렉션의 <code>component1()</code>와 <code>component2()</code>를 호출한 결과를 값으로 갖는다.</p><h3 id='multi-declarations.html_section-1'>예제: 함수에서 두 값 리턴하기<a class='anchor' href='#%23section-1'> </a></h3><p>함수에서 두 값을 리턴해야 한다고 가정해보자. 예를 들어, 결과 객체와 어떤 종류의 상태 값을 리턴해야 한다.
이를 하는 간단한 방법은 <a href='#data-classes.html'><em>데이터 클래스</em></a>를 만들고 그 인스턴스를 리턴하는 것이다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>data</span> <span class='k'>class</span> <span class='nc'>Result</span><span class='p'>(</span><span class='k'>val</span> <span class='py'>result</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>,</span> <span class='k'>val</span> <span class='py'>status</span><span class='p'>:</span> <span class='n'>Status</span><span class='p'>)</span>
<span class='k'>fun</span> <span class='nf'>function</span><span class='p'>(...):</span> <span class='n'>Result</span> <span class='p'>{</span>
    <span class='c1'>// 계산</span>

    <span class='k'>return</span> <span class='n'>Result</span><span class='p'>(</span><span class='n'>result</span><span class='p'>,</span> <span class='n'>status</span><span class='p'>)</span>
<span class='p'>}</span>

<span class='c1'>// 이제, 이 함수 사용하기:</span>
<span class='k'>val</span> <span class='err'>(</span><span class='py'>result</span><span class='p'>,</span> <span class='n'>status</span><span class='p'>)</span> <span class='p'>=</span> <span class='n'>function</span><span class='p'>(...)</span></code></pre><p>데이터 클래스는 <code>componentN()</code> 함수를 자동으로 선언하므로 분리 선언이 가능하다.</p><p><strong>주의</strong>: 위 코드에서 표준 클래스 <code>Pair</code>와 <code>Pair&lt;Int, Status&gt;</code>를 리턴하는 <code>function()</code>을 사용할 수도 있다.
하지만, 데이터에 알맞은 이름을 붙이는게 보통 더 좋다.</p><h3 id='multi-declarations.html_section-2'>예제: 분리 선언과 맵<a class='anchor' href='#%23section-2'> </a></h3><p>다음은 아마도 맵을 탐색하는 가장 좋은 방법일 것이다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>for</span> <span class='p'>((</span><span class='n'>key</span><span class='p'>,</span> <span class='n'>value</span><span class='p'>)</span> <span class='k'>in</span> <span class='n'>map</span><span class='p'>)</span> <span class='p'>{</span>
   <span class='c1'>// 키와 값으로 무언가를 한다</span>
<span class='p'>}</span></code></pre><p>이게 되려면 다음을 충족해야 한다.</p><ul>
  <li><code>iterator()</code> 함수를 제공해서 맵을 값 시퀀스로 제공해야 한다,</li>
  <li>각 요소를 <code>component1()</code>과 <code>component2()</code> 함수를 제공하는 페어로 제공해야 한다.</li>
</ul><p>사실 표준 라이브러리가 이 확장을 제공한다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>operator</span> <span class='k'>fun</span> <span class='err'>&lt;</span><span class='nf'>K</span><span class='p'>,</span> <span class='n'>V</span><span class='p'>&gt;</span> <span class='n'>Map</span><span class='p'>&lt;</span><span class='n'>K</span><span class='p'>,</span> <span class='n'>V</span><span class='p'>&gt;.</span><span class='n'>iterator</span><span class='p'>():</span> <span class='n'>Iterator</span><span class='p'>&lt;</span><span class='n'>Map</span><span class='p'>.</span><span class='n'>Entry</span><span class='p'>&lt;</span><span class='n'>K</span><span class='p'>,</span> <span class='n'>V</span><span class='p'>&gt;&gt;</span> <span class='p'>=</span> <span class='n'>entrySet</span><span class='p'>().</span><span class='n'>iterator</span><span class='p'>()</span>
<span class='n'>operator</span> <span class='k'>fun</span> <span class='err'>&lt;</span><span class='nf'>K</span><span class='p'>,</span> <span class='n'>V</span><span class='p'>&gt;</span> <span class='n'>Map</span><span class='p'>.</span><span class='n'>Entry</span><span class='p'>&lt;</span><span class='n'>K</span><span class='p'>,</span> <span class='n'>V</span><span class='p'>&gt;.</span><span class='n'>component1</span><span class='p'>()</span> <span class='p'>=</span> <span class='n'>getKey</span><span class='p'>()</span>
<span class='n'>operator</span> <span class='k'>fun</span> <span class='err'>&lt;</span><span class='nf'>K</span><span class='p'>,</span> <span class='n'>V</span><span class='p'>&gt;</span> <span class='n'>Map</span><span class='p'>.</span><span class='n'>Entry</span><span class='p'>&lt;</span><span class='n'>K</span><span class='p'>,</span> <span class='n'>V</span><span class='p'>&gt;.</span><span class='n'>component2</span><span class='p'>()</span> <span class='p'>=</span> <span class='n'>getValue</span><span class='p'>()</span></code></pre><p>따라서 맵을(또한 데이터 클래스의 인스턴스 콜렉션을) 사용하는 <em class='keyword'>for</em>-루프에서 자유롭게 분리 선언을 사용할 수 있다.</p>
              </article>
          
              <article id="collections.html" class="page-content">
                <h2 id='collections.html_section'>콜렉션<a class='anchor' href='#%23section'> </a></h2><p>많은 다른 언어와 달리 코틀린은 (리스트, 집합, 맵 등 콜렉션에 대해) 변경가능 콜렉션과 변경불가 컬렉션을을 구분한다. 언제 콜렉션을 수정할 수 있는지 정확하게 제어하는 것은 버그를 제거하고 좋은 API를 설계하는데 도움이 된다.</p><p>처음부터 변경 가능 콜렉션의 읽기 전용 _뷰_와 실제 변경 불가 콜렉션의 차이점을 이해하는 것이 중요하다. 둘 다 만들기는 쉽지만, 타입 시스템은 둘의 차이를 표현하지 않으므로 (차이가 중요하다면) 콜렉션이 둘 중 무엇인지 추적하는 것은 당신 몫이다.</p><p>코틀린의 <code>List&lt;out T&gt;</code> 타입은 <code>size</code>나 <code>get</code>과 같은 읽기 전용 연산을 제공하는 인터페이스이다. 자바와 비슷하게 <code>Iterable&lt;T&gt;</code>의 하위타입인 <code>Collection&lt;T&gt;</code>를 상속한다. 리스트를 변경할 수 있는 메서드는 <code>MutableList&lt;T&gt;</code> 리스트에 정의되어 있다. 집합과 맵도 동일한 방식으로 <code>Set&lt;out T&gt;/MutableSet&lt;T&gt;</code>와 <code>Map&lt;K, out V&gt;/MutableMap&lt;K, V&gt;</code>로 구분되어 있다.</p><p>리스트와 집합의 기본적인 사용법은 아래와 같다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>numbers</span><span class='p'>:</span> <span class='n'>MutableList</span><span class='p'>&lt;</span><span class='n'>Int</span><span class='p'>&gt;</span> <span class='p'>=</span> <span class='n'>mutableListOf</span><span class='p'>(</span><span class='m'>1</span><span class='p'>,</span> <span class='m'>2</span><span class='p'>,</span> <span class='m'>3</span><span class='p'>)</span>
<span class='k'>val</span> <span class='py'>readOnlyView</span><span class='p'>:</span> <span class='n'>List</span><span class='p'>&lt;</span><span class='n'>Int</span><span class='p'>&gt;</span> <span class='p'>=</span> <span class='n'>numbers</span>
<span class='n'>println</span><span class='p'>(</span><span class='n'>numbers</span><span class='p'>)</span>        <span class='c1'>// &quot;[1, 2, 3]&quot; 출력</span>
<span class='n'>numbers</span><span class='p'>.</span><span class='n'>add</span><span class='p'>(</span><span class='m'>4</span><span class='p'>)</span>
<span class='n'>println</span><span class='p'>(</span><span class='n'>readOnlyView</span><span class='p'>)</span>   <span class='c1'>// &quot;[1, 2, 3, 4]&quot; 출력</span>
<span class='n'>readOnlyView</span><span class='p'>.</span><span class='n'>clear</span><span class='p'>()</span>    <span class='c1'>// -&gt; 컴파일되지 않음</span>

<span class='k'>val</span> <span class='py'>strings</span> <span class='p'>=</span> <span class='n'>hashSetOf</span><span class='p'>(</span><span class='s'>&quot;a&quot;</span><span class='p'>,</span> <span class='s'>&quot;b&quot;</span><span class='p'>,</span> <span class='s'>&quot;c&quot;</span><span class='p'>,</span> <span class='s'>&quot;c&quot;</span><span class='p'>)</span>
<span class='n'>assert</span><span class='p'>(</span><span class='n'>strings</span><span class='p'>.</span><span class='n'>size</span> <span class='p'>==</span> <span class='m'>3</span><span class='p'>)</span></code></pre><p>코틀린은 리스트나 집합을 만들기 위한 구문 요소가 없다. <code>listOf()</code>, <code>mutableListOf()</code>, <code>setOf()</code>, <code>mutableSetOf()</code>와 같은 표준 라이브러리의 메서드를 사용해서 생성한다.</p><p>성능이 중요하지 않은 코드는 맵을 생성할 때 <code>mapOf(a to b, c to d)</code> <a href='#idioms.html%23read-only-map'>이디엄</a>을 사용할 수 있다.</p><p>앞서 <code>readOnlyView</code> 변수는 numbers와 같은 리스트를 참조하고, 참조한 리스트가 바뀌면 함께 바뀐다는 점에 유의하자. 리스트에 대한 유일한 참조가 읽기 전용 변수라면, 완전한 불변 콜렉션을 사용할 것을 고려해보자. 불변 콜렉션을 만드는 간단한 방법은 다음과 같다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>items</span> <span class='p'>=</span> <span class='n'>listOf</span><span class='p'>(</span><span class='m'>1</span><span class='p'>,</span> <span class='m'>2</span><span class='p'>,</span> <span class='m'>3</span><span class='p'>)</span></code></pre><p>현재 <code>listOf</code> 메서드는 배열 리스트를 이용해서 구현했다. 이 메서드는 불변 리스트를 생성하므로 이 점을 활용해서 활용해서 향후에 메모리를 더 효율적으로 사용하는 완전한 불변 콜렉션 타입을 리턴하도록 구현할 것이다.</p><p>읽기 전용 타입은 <a href='#generics.html%23variance'>공변(covariant)</a>이다. 이는 Rectangle가 Shapre를 상속받은 경우, <code>List&lt;Rectangle&gt;</code>를 <code>List&lt;Shape&gt;</code>에 할당할 수 있다는 것을 뜻한다. 변경가능 콜렉션은 런타임에 실패가 발생할 수 있기 때문에 이를 허용하지 않는다.</p><p>특정 시점에 콜렉션의 스냅샷을 호출자에 리턴하는데 (원본 콜렉션을 변경해도) 리턴한 콜렉션은 바뀌지 않는 것을 원할 때가 있다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>class</span> <span class='nc'>Controller</span> <span class='p'>{</span>
    <span class='k'>private</span> <span class='k'>val</span> <span class='py'>_items</span> <span class='p'>=</span> <span class='n'>mutableListOf</span><span class='p'>&lt;</span><span class='n'>String</span><span class='p'>&gt;()</span>
    <span class='k'>val</span> <span class='py'>items</span><span class='p'>:</span> <span class='n'>List</span><span class='p'>&lt;</span><span class='n'>String</span><span class='p'>&gt;</span> <span class='k'>get</span><span class='p'>()</span> <span class='p'>=</span> <span class='n'>_items</span><span class='p'>.</span><span class='n'>toList</span><span class='p'>()</span>
<span class='p'>}</span></code></pre><p><code>toList</code> 확장 메서드는 리스트 항목을 복사하기 때문에 (원본을 변경해도) 리턴된 리스트가 절대로 바뀌지 않음을 보장한다.</p><p>리스트와 집합에 대해 익숙해지면 좋은 몇 가지 유용한 확장 함수가 있다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>items</span> <span class='p'>=</span> <span class='n'>listOf</span><span class='p'>(</span><span class='m'>1</span><span class='p'>,</span> <span class='m'>2</span><span class='p'>,</span> <span class='m'>3</span><span class='p'>,</span> <span class='m'>4</span><span class='p'>)</span>
<span class='n'>items</span><span class='p'>.</span><span class='n'>first</span> <span class='p'>==</span> <span class='m'>1</span>
<span class='n'>items</span><span class='p'>.</span><span class='n'>last</span> <span class='p'>==</span> <span class='m'>4</span>
<span class='n'>items</span><span class='p'>.</span><span class='n'>filter</span> <span class='p'>{</span> <span class='n'>it</span> <span class='p'>%</span> <span class='m'>2</span> <span class='p'>==</span> <span class='m'>0</span> <span class='p'>}</span>   <span class='c1'>// [2, 4] 리턴</span>
<span class='n'>rwList</span><span class='p'>.</span><span class='n'>requireNoNulls</span><span class='p'>()</span>
<span class='k'>if</span> <span class='p'>(</span><span class='n'>rwList</span><span class='p'>.</span><span class='n'>none</span> <span class='p'>{</span> <span class='n'>it</span> <span class='p'>&gt;</span> <span class='m'>6</span> <span class='p'>})</span> <span class='n'>println</span><span class='p'>(</span><span class='s'>&quot;No items above 6&quot;</span><span class='p'>)</span>
<span class='k'>val</span> <span class='py'>item</span> <span class='p'>=</span> <span class='n'>rwList</span><span class='p'>.</span><span class='n'>firstOrNull</span><span class='p'>()</span></code></pre><p>… 또한, sort, zip, fold, reduce와 같은 유틸리티도 존재한다.</p><p>맵도 동일 패턴을 따른다. 다음과 같이 쉽게 생성하고 사용할 수 있다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>readWriteMap</span> <span class='p'>=</span> <span class='n'>hashMapOf</span><span class='p'>(</span><span class='s'>&quot;foo&quot;</span> <span class='n'>to</span> <span class='m'>1</span><span class='p'>,</span> <span class='s'>&quot;bar&quot;</span> <span class='n'>to</span> <span class='m'>2</span><span class='p'>)</span>
<span class='n'>println</span><span class='p'>(</span><span class='n'>readWriteMap</span><span class='p'>[</span><span class='s'>&quot;foo&quot;</span><span class='p'>])</span>
<span class='k'>val</span> <span class='py'>snapshot</span><span class='p'>:</span> <span class='n'>Map</span><span class='p'>&lt;</span><span class='n'>String</span><span class='p'>,</span> <span class='n'>Int</span><span class='p'>&gt;</span> <span class='p'>=</span> <span class='n'>HashMap</span><span class='p'>(</span><span class='n'>readWriteMap</span><span class='p'>)</span></code></pre>
              </article>
          
              <article id="ranges.html" class="page-content">
                <h2 id='ranges.html_section'>범위<a class='anchor' href='#%23section'> </a></h2><p>범위(Range) 식은 연산자 형식인 “..”를 갖는 <code>rangeTo</code> 함수로 구성된다. 이 식은 <em class='keyword'>in</em>이나 <em class='keyword'>!in</em>과 함께 쓰인다.
모든 Comparable 타입에 대해 범위를 정의할 수 있으며 기본 정수 타입은 최적화한 구현을 제공한다. 다음은 범위 사용 예이다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>if</span> <span class='p'>(</span><span class='n'>i</span> <span class='k'>in</span> <span class='m'>1.</span><span class='p'>.</span><span class='m'>10</span><span class='p'>)</span> <span class='p'>{</span> <span class='c1'>// 1 &lt;= i &amp;&amp; i &lt;= 10와 동일</span>
  <span class='n'>println</span><span class='p'>(</span><span class='n'>i</span><span class='p'>)</span>
<span class='p'>}</span></code></pre><p>정수 타입 범위(<code>IntRange</code>, <code>LongRange</code>, <code>CharRange</code>)는 특수 기능-이터레이션 가능한-을 제공한다.
컴파일러가 이를 자바의 인덱스 기반 <em class='keyword'>for</em>-루프와 동일하게 바꿔서 추가 오버헤드가 없다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>for</span> <span class='p'>(</span><span class='n'>i</span> <span class='k'>in</span> <span class='m'>1.</span><span class='p'>.</span><span class='m'>4</span><span class='p'>)</span> <span class='n'>print</span><span class='p'>(</span><span class='n'>i</span><span class='p'>)</span> <span class='c1'>// &quot;1234&quot; 출력</span>

<span class='k'>for</span> <span class='p'>(</span><span class='n'>i</span> <span class='k'>in</span> <span class='m'>4.</span><span class='p'>.</span><span class='m'>1</span><span class='p'>)</span> <span class='n'>print</span><span class='p'>(</span><span class='n'>i</span><span class='p'>)</span> <span class='c1'>// 아무것도 출력하지 않음</span></code></pre><p>숫자를 역으로 이터레이션하고 싶다면? 간단하다. 표준 라이브러리에 있는 <code>downTo()</code> 함수를 사용하면 된다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>for</span> <span class='p'>(</span><span class='n'>i</span> <span class='k'>in</span> <span class='m'>4</span> <span class='n'>downTo</span> <span class='m'>1</span><span class='p'>)</span> <span class='n'>print</span><span class='p'>(</span><span class='n'>i</span><span class='p'>)</span> <span class='c1'>// &quot;4321&quot; 출력</span></code></pre><p>1씩 증가/감소가 아닌 지정한 단계만큼 숫자를 이터레이션하는 것은? 물론 가능하다. <code>step()</code> 함수를 쓰면 된다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>for</span> <span class='p'>(</span><span class='n'>i</span> <span class='k'>in</span> <span class='m'>1.</span><span class='p'>.</span><span class='m'>4</span> <span class='n'>step</span> <span class='m'>2</span><span class='p'>)</span> <span class='n'>print</span><span class='p'>(</span><span class='n'>i</span><span class='p'>)</span> <span class='c1'>// &quot;13&quot; 출력</span>

<span class='k'>for</span> <span class='p'>(</span><span class='n'>i</span> <span class='k'>in</span> <span class='m'>4</span> <span class='n'>downTo</span> <span class='m'>1</span> <span class='n'>step</span> <span class='m'>2</span><span class='p'>)</span> <span class='n'>print</span><span class='p'>(</span><span class='n'>i</span><span class='p'>)</span> <span class='c1'>// &quot;42&quot; 출력</span></code></pre><h3 id='ranges.html_section-1'>동작 방식<a class='anchor' href='#%23section-1'> </a></h3><p>범위는 라이브러리의 공통 인터페이스인 <code>ClosedRange&lt;T&gt;</code>를 구현한다.</p><p><code>ClosedRange&lt;T&gt;</code>는 Comparable 타입에 대한 수학적 의미의 닫힌 구간을 뜻한다.
이는 범위에 포함되는 <code>start</code>와 <code>endInclusive</code>의 두 끝지점을 갖는다.
주요 오퍼레이션인 `contains’는 보통 <em class='keyword'>in</em>/<em class='keyword'>!in</em> 연산자 형식으로 사용한다.</p><p>정수 타입 프로그레션(<code>IntProgression</code>, <code>LongProgression</code>, <code>CharProgression</code>)은 숫자 진행을 뜻한다.
프로그레션은 <code>first</code> 요소, <code>last</code> 요소, 0이 아닌 <code>increment</code>로 정의한다.
첫 번째 요소는 <code>first</code>이고, 다음 요소는 이전 요소에 <code>increment</code>를 더한 값이다.
<code>last</code> 요소는 프로그레이션이 비어(emptty) 있지 않으면 항상 도달한다.</p><p>프로그레션은 <code>Iterable&lt;N&gt;</code>의 하위 타입으로 <code>N</code>에는 <code>Int</code>, <code>Long</code>, <code>Char</code>가 올 수 있으며,
<em class='keyword'>for</em>-루프나 <code>map</code>, <code>filter</code>와 같은 함수에서 사용할 수 있다.
프로그레션에 대한 이터레이션은 자바/자바스크립에서 다음의 인덱스 기반 <em class='keyword'>for</em>-루프와 동일하다:</p><pre><code class='code-block _highlighted lang_java'><span class='k'>for</span> <span class='o'>(</span><span class='kt'>int</span> <span class='n'>i</span> <span class='o'>=</span> <span class='n'>first</span><span class='o'>;</span> <span class='n'>i</span> <span class='o'>!=</span> <span class='n'>last</span><span class='o'>;</span> <span class='n'>i</span> <span class='o'>+=</span> <span class='n'>increment</span><span class='o'>)</span> <span class='o'>{</span>
  <span class='c1'>// ...</span>
<span class='o'>}</span></code></pre><p>정수 타입에서, <code>..</code> 연산자는 <code>ClosedRange&lt;T&gt;</code>와 <code>*Progression</code>을 모두 구현한 객체를 생성한다.
예를 들어, <code>IntRange</code>는 <code>ClosedRange&lt;Int&gt;</code>를 구현하고 <code>IntProgression</code>를 확장해서, <code>IntProgression</code>에 정의된 모든 오퍼레이션을 <code>IntRange</code>에서 사용 가능하다.
<code>downTo()</code>와 <code>setp()</code> 함수 결과는 항상 <code>*Progression</code>이다.</p><p>프로그레션은 컴페니언 객체에 정의한 <code>fromClosedRange</code> 함수로 생성한다:</p><pre><code class='code-block _highlighted lang_kotlin'>  <span class='n'>IntProgression</span><span class='p'>.</span><span class='n'>fromClosedRange</span><span class='p'>(</span><span class='n'>start</span><span class='p'>,</span> <span class='n'>end</span><span class='p'>,</span> <span class='n'>increment</span><span class='p'>)</span></code></pre><p>양수 <code>increment</code> 기준으로 <code>end</code> 값보다 크지 않은 최댓값을 또는 음수 <code>increment</code>에 대해 <code>end</code> 값보다 작지 않은 최솟값을 찾기 위해 <code>(last - first) % increment == 0</code>와 같은 식을 사용해서 프로그레션의 <code>last</code> 요소를 계산한다.</p><h3 id='ranges.html_section-2'>유틸리티 함수<a class='anchor' href='#%23section-2'> </a></h3><h4 id='ranges.html_rangeto'><code>rangeTo()</code><a class='anchor' href='#%23rangeto'> </a></h4><p>정수 타입 <code>rangeTo()</code> 연산자는 단순히 <code>*Range</code> 클래스의 생성자를 호출한다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>class</span> <span class='nc'>Int</span> <span class='p'>{</span>
  <span class='c1'>//...</span>
  <span class='n'>operator</span> <span class='k'>fun</span> <span class='nf'>rangeTo</span><span class='p'>(</span><span class='n'>other</span><span class='p'>:</span> <span class='n'>Long</span><span class='p'>):</span> <span class='n'>LongRange</span> <span class='p'>=</span> <span class='n'>LongRange</span><span class='p'>(</span><span class='k'>this</span><span class='p'>,</span> <span class='n'>other</span><span class='p'>)</span>
  <span class='c1'>//...</span>
  <span class='n'>operator</span> <span class='k'>fun</span> <span class='nf'>rangeTo</span><span class='p'>(</span><span class='n'>other</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>):</span> <span class='n'>IntRange</span> <span class='p'>=</span> <span class='n'>IntRange</span><span class='p'>(</span><span class='k'>this</span><span class='p'>,</span> <span class='n'>other</span><span class='p'>)</span>
  <span class='c1'>//...</span>
<span class='p'>}</span></code></pre><p>실수형 숫자(<code>Double</code>, <code>Float</code>)는 <code>rangeTo</code> 연산자를 정의하지 않고, 지네릭 <code>Comparable</code> 타입을 위해 표준 라이브러리가 제공하는 연산자를 대신 사용한다:</p><pre><code class='code-block _highlighted lang_kotlin'>  <span class='k'>public</span> <span class='n'>operator</span> <span class='k'>fun</span> <span class='err'>&lt;</span><span class='nf'>T</span><span class='p'>:</span> <span class='n'>Comparable</span><span class='p'>&lt;</span><span class='n'>T</span><span class='p'>&gt;&gt;</span> <span class='n'>T</span><span class='p'>.</span><span class='n'>rangeTo</span><span class='p'>(</span><span class='n'>that</span><span class='p'>:</span> <span class='n'>T</span><span class='p'>):</span> <span class='n'>ClosedRange</span><span class='p'>&lt;</span><span class='n'>T</span><span class='p'>&gt;</span></code></pre><p>이 함수가 리턴하는 범위는 이터레이션할 수 없다.</p><h4 id='ranges.html_downto'><code>downTo()</code><a class='anchor' href='#%23downto'> </a></h4><p><code>downTo()</code>는 정수 타입 쌍을 위한 확장 함수이다. 다음은 두 가지 예이다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>Long</span><span class='p'>.</span><span class='n'>downTo</span><span class='p'>(</span><span class='n'>other</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>):</span> <span class='n'>LongProgression</span> <span class='p'>{</span>
  <span class='k'>return</span> <span class='n'>LongProgression</span><span class='p'>.</span><span class='n'>fromClosedRange</span><span class='p'>(</span><span class='k'>this</span><span class='p'>,</span> <span class='n'>other</span><span class='p'>,</span> <span class='p'>-</span><span class='m'>1.0</span><span class='p'>)</span>
<span class='p'>}</span>

<span class='k'>fun</span> <span class='nf'>Byte</span><span class='p'>.</span><span class='n'>downTo</span><span class='p'>(</span><span class='n'>other</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>):</span> <span class='n'>IntProgression</span> <span class='p'>{</span>
  <span class='k'>return</span> <span class='n'>IntProgression</span><span class='p'>.</span><span class='n'>fromClosedRange</span><span class='p'>(</span><span class='k'>this</span><span class='p'>,</span> <span class='n'>other</span><span class='p'>,</span> <span class='p'>-</span><span class='m'>1</span><span class='p'>)</span>
<span class='p'>}</span></code></pre><h4 id='ranges.html_reversed'><code>reversed()</code><a class='anchor' href='#%23reversed'> </a></h4><p><code>reversed()</code>는 각 <code>*Progression</code> 클래스를 위한 확장 함수이다.
모든 확장 함수는 역순 프로그레션을 리턴한다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>IntProgression</span><span class='p'>.</span><span class='n'>reversed</span><span class='p'>():</span> <span class='n'>IntProgression</span> <span class='p'>{</span>
  <span class='k'>return</span> <span class='n'>IntProgression</span><span class='p'>.</span><span class='n'>fromClosedRange</span><span class='p'>(</span><span class='n'>last</span><span class='p'>,</span> <span class='n'>first</span><span class='p'>,</span> <span class='p'>-</span><span class='n'>increment</span><span class='p'>)</span>
<span class='p'>}</span></code></pre><h4 id='ranges.html_step'><code>step()</code><a class='anchor' href='#%23step'> </a></h4><p><code>step()</code>은 <code>*Progression</code> 클래스를 위한 확장 함수이다.
모든 확장 함수는 수정한 <code>step</code> 값(함수 파라미터)을 가진 프로그레션을 리턴한다.
step 값은 항상 양수여야 한다. 따라서 이 함수는 이터레이션의 방향을 절대 바꾸지 않는다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>IntProgression</span><span class='p'>.</span><span class='n'>step</span><span class='p'>(</span><span class='n'>step</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>):</span> <span class='n'>IntProgression</span> <span class='p'>{</span>
  <span class='k'>if</span> <span class='p'>(</span><span class='n'>step</span> <span class='p'>&lt;=</span> <span class='m'>0</span><span class='p'>)</span> <span class='k'>throw</span> <span class='n'>IllegalArgumentException</span><span class='p'>(</span><span class='s'>&quot;Step must be positive, was: $step&quot;</span><span class='p'>)</span>
  <span class='k'>return</span> <span class='n'>IntProgression</span><span class='p'>.</span><span class='n'>fromClosedRange</span><span class='p'>(</span><span class='n'>first</span><span class='p'>,</span> <span class='n'>last</span><span class='p'>,</span> <span class='k'>if</span> <span class='p'>(</span><span class='n'>increment</span> <span class='p'>&gt;</span> <span class='m'>0</span><span class='p'>)</span> <span class='n'>step</span> <span class='k'>else</span> <span class='p'>-</span><span class='n'>step</span><span class='p'>)</span>
<span class='p'>}</span>

<span class='k'>fun</span> <span class='nf'>CharProgression</span><span class='p'>.</span><span class='n'>step</span><span class='p'>(</span><span class='n'>step</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>):</span> <span class='n'>CharProgression</span> <span class='p'>{</span>
  <span class='k'>if</span> <span class='p'>(</span><span class='n'>step</span> <span class='p'>&lt;=</span> <span class='m'>0</span><span class='p'>)</span> <span class='k'>throw</span> <span class='n'>IllegalArgumentException</span><span class='p'>(</span><span class='s'>&quot;Step must be positive, was: $step&quot;</span><span class='p'>)</span>
  <span class='k'>return</span> <span class='n'>CharProgression</span><span class='p'>.</span><span class='n'>fromClosedRange</span><span class='p'>(</span><span class='n'>first</span><span class='p'>,</span> <span class='n'>last</span><span class='p'>,</span> <span class='n'>step</span><span class='p'>)</span>
<span class='p'>}</span></code></pre><p><code>(last - first) % increment == 0</code> 규칙을 유지하기 위해 리턴한 프로그레션의 <code>last</code> 값은 원래 프로그레션의 <code>last</code>와 다를 수 있다. 다음은 예이다:</p><pre><code class='code-block _highlighted lang_kotlin'>  <span class='p'>(</span><span class='m'>1.</span><span class='p'>.</span><span class='m'>12</span> <span class='n'>step</span> <span class='m'>2</span><span class='p'>).</span><span class='n'>last</span> <span class='p'>==</span> <span class='m'>11</span>  <span class='c1'>// [1, 3, 5, 7, 9, 11] 값을 가진 프로그레션</span>
  <span class='p'>(</span><span class='m'>1.</span><span class='p'>.</span><span class='m'>12</span> <span class='n'>step</span> <span class='m'>3</span><span class='p'>).</span><span class='n'>last</span> <span class='p'>==</span> <span class='m'>10</span>  <span class='c1'>// [1, 4, 7, 10] 값을 가진 프로그레션</span>
  <span class='p'>(</span><span class='m'>1.</span><span class='p'>.</span><span class='m'>12</span> <span class='n'>step</span> <span class='m'>4</span><span class='p'>).</span><span class='n'>last</span> <span class='p'>==</span> <span class='m'>9</span>   <span class='c1'>// [1, 5, 9] 값을 가진 프로그레션</span></code></pre>
              </article>
          
              <article id="typecasts.html" class="page-content">
                <h2 id='typecasts.html_section'>타입 검사와 변환<a class='anchor' href='#%23section'> </a></h2><h3 id='typecasts.html_is-is-'><code>is</code>와 <code>!is</code> 연산자<a class='anchor' href='#%23is-is-'> </a></h3><p><code>is</code>와 <code>!is</code> 연산자를 사용하면 런타임에 객체가 주어진 타입인지 아닌지 검사할 수 있다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>if</span> <span class='p'>(</span><span class='n'>obj</span> <span class='k'>is</span> <span class='n'>String</span><span class='p'>)</span> <span class='p'>{</span>
  <span class='n'>print</span><span class='p'>(</span><span class='n'>obj</span><span class='p'>.</span><span class='n'>length</span><span class='p'>)</span>
<span class='p'>}</span>

<span class='k'>if</span> <span class='p'>(</span><span class='n'>obj</span> <span class='p'>!</span><span class='k'>is</span> <span class='n'>String</span><span class='p'>)</span> <span class='p'>{</span> <span class='c1'>// !(obj is String)와 동일</span>
  <span class='n'>print</span><span class='p'>(</span><span class='s'>&quot;Not a String&quot;</span><span class='p'>)</span>
<span class='p'>}</span>
<span class='k'>else</span> <span class='p'>{</span>
  <span class='n'>print</span><span class='p'>(</span><span class='n'>obj</span><span class='p'>.</span><span class='n'>length</span><span class='p'>)</span>
<span class='p'>}</span></code></pre><h3 id='typecasts.html_section-1'>스마트 변환<a class='anchor' href='#%23section-1'> </a></h3><p>코틀린은 컴파일러가 불변 값에 대해 <code>is</code>-검사를 추적해서 필요하면 자동으로 (안전한) 변환을 추가하기 때문에,
많은 경우 명시적인 변환 연산을 사용할 필요가 없다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>demo</span><span class='p'>(</span><span class='n'>x</span><span class='p'>:</span> <span class='n'>Any</span><span class='p'>)</span> <span class='p'>{</span>
  <span class='k'>if</span> <span class='p'>(</span><span class='n'>x</span> <span class='k'>is</span> <span class='n'>String</span><span class='p'>)</span> <span class='p'>{</span>
    <span class='n'>print</span><span class='p'>(</span><span class='n'>x</span><span class='p'>.</span><span class='n'>length</span><span class='p'>)</span> <span class='c1'>// x를 자동으로 String으로 변환한다</span>
  <span class='p'>}</span>
<span class='p'>}</span></code></pre><p>컴파일러가 똑띠하기 때문에 타입 비일치 검사에서 리턴하면 안전하게 변환할 수 있다는 것을 안다.</p><pre><code class='code-block _highlighted lang_kotlin'>  <span class='k'>if</span> <span class='p'>(</span><span class='n'>x</span> <span class='p'>!</span><span class='k'>is</span> <span class='n'>String</span><span class='p'>)</span> <span class='k'>return</span>
  <span class='n'>print</span><span class='p'>(</span><span class='n'>x</span><span class='p'>.</span><span class='n'>length</span><span class='p'>)</span> <span class='c1'>// x를 자동으로 String으로 변환한다</span></code></pre><p><code>&amp;&amp;</code>와 <code>||</code>의 우측에서도 안전하게 변환한다.:</p><pre><code class='code-block _highlighted lang_kotlin'>  <span class='c1'>// `||`의 우측에 대해 x를 자동으로 문자열로 변환</span>
  <span class='k'>if</span> <span class='p'>(</span><span class='n'>x</span> <span class='p'>!</span><span class='k'>is</span> <span class='n'>String</span> <span class='p'>||</span> <span class='n'>x</span><span class='p'>.</span><span class='n'>length</span> <span class='p'>==</span> <span class='m'>0</span><span class='p'>)</span> <span class='k'>return</span>

  <span class='c1'>// `&amp;&amp;`의 우측에 대해 x를 자동으로 문자열로 변환</span>
  <span class='k'>if</span> <span class='p'>(</span><span class='n'>x</span> <span class='k'>is</span> <span class='n'>String</span> <span class='p'>&amp;&amp;</span> <span class='n'>x</span><span class='p'>.</span><span class='n'>length</span> <span class='p'>&gt;</span> <span class='m'>0</span><span class='p'>)</span>
      <span class='n'>print</span><span class='p'>(</span><span class='n'>x</span><span class='p'>.</span><span class='n'>length</span><span class='p'>)</span> <span class='c1'>// x를 자동으로 String으로 변환한다</span></code></pre><p>_스마트 변환_은 <a href='#control-flow.html%23when-expressions'><em class='keyword'>when</em>-식</a>과
<a href='#control-flow.html%23while-loops'><em class='keyword'>while</em>-루프</a>에도 동작한다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>when</span> <span class='p'>(</span><span class='n'>x</span><span class='p'>)</span> <span class='p'>{</span>
  <span class='k'>is</span> <span class='n'>Int</span> <span class='p'>-&gt;</span> <span class='n'>print</span><span class='p'>(</span><span class='n'>x</span> <span class='p'>+</span> <span class='m'>1</span><span class='p'>)</span>
  <span class='k'>is</span> <span class='n'>String</span> <span class='p'>-&gt;</span> <span class='n'>print</span><span class='p'>(</span><span class='n'>x</span><span class='p'>.</span><span class='n'>length</span> <span class='p'>+</span> <span class='m'>1</span><span class='p'>)</span>
  <span class='k'>is</span> <span class='n'>IntArray</span> <span class='p'>-&gt;</span> <span class='n'>print</span><span class='p'>(</span><span class='n'>x</span><span class='p'>.</span><span class='n'>sum</span><span class='p'>())</span>
<span class='p'>}</span></code></pre><p>컴파일러가 타입 검사와 사용 사이에 변수가 바뀌지 않는다는 것을 보장할 수 없으면 스마트 변환을 할 수 없다.
더 구체적으로 스마트 변환은 다음 규칙에 따라 가능하다.</p><ul>
  <li><em class='keyword'>val</em> 로컬 변수 - 항상;</li>
  <li><em class='keyword'>val</em> 프로퍼티 - 프로퍼티가 private이나 internal이거나 또는 프로퍼티를 선언한 같은 모듈에서 검사를 수행한 경우. open 프로퍼티나 커스텀 getter를 가진 프로퍼티에는 스마트 변환을 적용할 수 없다;</li>
  <li><em class='keyword'>var</em> 로컬 변수  - 검사와 사용 사이에 변수가 바뀌지 않고 그것을 수정하는 람다에 캡처되지 않는 경우;</li>
  <li><em class='keyword'>var</em> 프로퍼티 - 절대 안 됨 (변수를 언제 어디서든 수정할 수 있으므로)</li>
</ul><h3 id='typecasts.html_section-2'>“안전하지 않은” 변환 연산자<a class='anchor' href='#%23section-2'> </a></h3><p>보통 변환 연산자는 변환을 할 수 없으면 익셉션을 발생한다. 그래서 이 변환을 <em>안전하지 않다고</em> 부른다.
안전하지 않은 변환은 <em class='keyword'>as</em> 중위 연산자로 한다(<a href='#grammar.html%23operator-precedence'>연산자 우선순위</a> 참고):</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>x</span><span class='p'>:</span> <span class='n'>String</span> <span class='p'>=</span> <span class='n'>y</span> <span class='k'>as</span> <span class='n'>String</span></code></pre><p>String 타입은 <a href='#null-safety.html'>nullable</a>이 아니므로 <em class='keyword'>null</em>을 <code>String</code>으로 변환할 수 없다. 예를 들어 <code>y</code>가 null이면 이 코드는 익셉션이 발생한다.
자바 변환 세만틱과 맞추기 위해 다음과 같이 변환 피연산자로 nullable 타입을 사용해야 한다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>x</span><span class='p'>:</span> <span class='n'>String</span><span class='p'>?</span> <span class='p'>=</span> <span class='n'>y</span> <span class='k'>as</span> <span class='n'>String</span><span class='p'>?</span></code></pre><h3 id='typecasts.html_nullable--'>“안전한” (nullable) 변환 연산자<a class='anchor' href='#%23nullable--'> </a></h3><p>익셉션 발생을 피하려면 <em>안전하게</em> <em class='keyword'>as?</em> 변환 연산자를 사용할 수 있다. 이 연산자는 실패시  <em class='keyword'>null</em>을 리턴한다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>x</span><span class='p'>:</span> <span class='n'>String</span><span class='p'>?</span> <span class='p'>=</span> <span class='n'>y</span> <span class='k'>as</span><span class='p'>?</span> <span class='n'>String</span></code></pre><p><em class='keyword'>as?</em>의 우측 피연산자가 non-null 타입 <code>String</code>임에도 불구하고 변환 결과가 nullable 임에 주목하자.</p>
              </article>
          
              <article id="this-expressions.html" class="page-content">
                <h2 id='this-expressions.html_this-'>This 식<a class='anchor' href='#%23this-'> </a></h2><p>현재 _리시버_를 표시할 때 <em class='keyword'>this</em> 식을 사용한다:</p><ul>
  <li><a href='#classes.html%23inheritance'>클래스</a>의 멤버에서 <em class='keyword'>this</em>는 그 클래스의 현재 객체를 참조한다</li>
  <li><a href='#extensions.html'>확장 함수</a>나 <a href='#lambdas.html%23function-literals-with-receiver'>리시버를 지정한 함수 리터럴</a>에서 <em class='keyword'>this</em>는 점의 왼쪽 편에 전달한 <em>리시버</em> 파라미터를 나타낸다.</li>
</ul><p><em class='keyword'>this</em>에 한정자가 없으면 _가장 안쪽을 둘러싼 스코프_를 참조한다.
다른 스코프에서 <em class='keyword'>this</em>를 참조하려면 _라벨 한정자_를 사용한다:</p><h3 id='this-expressions.html_qualified'>한정한 <em class='keyword'>this</em><a class='anchor' href='#%23qualified'> </a></h3><p>외부 스코프(<a href='#classes.html'>클래스</a>나 <a href='#extensions.html'>확장 함수</a> 또는
라벨이 붙은 <a href='#lambdas.html%23function-literals-with-receiver'>리시버를 사용하는 함수 리터럴</a>)에서 <em class='keyword'>this</em>에 접근하려면
<code>this@label</code>을 사용한다. <code>@label</code>은 <em class='keyword'>this</em>로 접근하려는 스코프에 대한 <a href='#returns.html'>라벨</a>이다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>class</span> <span class='nc'>A</span> <span class='p'>{</span> <span class='c1'>// implicit label @A</span>
  <span class='k'>inner</span> <span class='k'>class</span> <span class='nc'>B</span> <span class='p'>{</span> <span class='c1'>// implicit label @B</span>
    <span class='k'>fun</span> <span class='nf'>Int</span><span class='p'>.</span><span class='n'>foo</span><span class='p'>()</span> <span class='p'>{</span> <span class='c1'>// implicit label @foo</span>
      <span class='k'>val</span> <span class='py'>a</span> <span class='p'>=</span> <span class='k'>this</span><span class='n'>@A</span> <span class='c1'>// A의 this</span>
      <span class='k'>val</span> <span class='py'>b</span> <span class='p'>=</span> <span class='k'>this</span><span class='n'>@B</span> <span class='c1'>// B의 this</span>

      <span class='k'>val</span> <span class='py'>c</span> <span class='p'>=</span> <span class='k'>this</span> <span class='c1'>// foo()의 리시버인 Int</span>
      <span class='k'>val</span> <span class='py'>c1</span> <span class='p'>=</span> <span class='k'>this</span><span class='n'>@foo</span> <span class='c1'>// foo()의 리시버인 Int</span>

      <span class='k'>val</span> <span class='py'>funLit</span> <span class='p'>=</span> <span class='n'>lambda</span><span class='err'>@</span> <span class='k'>fun</span> <span class='nf'>String</span><span class='p'>.()</span> <span class='p'>{</span>
        <span class='k'>val</span> <span class='py'>d</span> <span class='p'>=</span> <span class='k'>this</span> <span class='c1'>// funLit의 리시버</span>
      <span class='p'>}</span>


      <span class='k'>val</span> <span class='py'>funLit2</span> <span class='p'>=</span> <span class='p'>{</span> <span class='n'>s</span><span class='p'>:</span> <span class='n'>String</span> <span class='p'>-&gt;</span>
        <span class='c1'>// 둘러싼 람다 식이 리시버를 갖지 않으므로</span>
        <span class='c1'>// foo()의 리시버</span>
        <span class='k'>val</span> <span class='py'>d1</span> <span class='p'>=</span> <span class='k'>this</span>
      <span class='p'>}</span>
    <span class='p'>}</span>
  <span class='p'>}</span>
<span class='p'>}</span></code></pre>
              </article>
          
              <article id="equality.html" class="page-content">
                <h2 id='equality.html_equality'>Equality<a class='anchor' href='#%23equality'> </a></h2><p>코틀린에는 두 가지 동등성이 있다:</p><ul>
  <li>참조 동등성(Referential equality) (두 레퍼런스가 같은 객체를 참고)</li>
  <li>구조적 동등성(Structural equality) (<code>equals()</code>로 검사)</li>
</ul><h3 id='equality.html_section'>참조 동등성<a class='anchor' href='#%23section'> </a></h3><p>참조 동등성은 <code>===</code> 오퍼레이션으로 검사한다(역은 <code>!==</code>)
<code>a === b</code>는 <code>a</code>와 <code>b</code>가 같은 객체를 참조하는 경우에만 true이다.</p><h3 id='equality.html_section-1'>구조적 동등성<a class='anchor' href='#%23section-1'> </a></h3><p>구조적 동등성은 <code>==</code> 오퍼레이션으로 검사한다(역은 <code>!=</code>). 규약에 따라 <code>a == b</code>와 같은 식은 다음으로 변환된다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>a</span><span class='o'>?.</span><span class='n'>equals</span><span class='p'>(</span><span class='n'>b</span><span class='p'>)</span> <span class='o'>?:</span> <span class='p'>(</span><span class='n'>b</span> <span class='p'>===</span> <span class='k'>null</span><span class='p'>)</span></code></pre><p>이 코드는 <code>a</code>가 <code>null</code>이 아니면 <code>equals(Any?)</code> 함수를 호출하고 그렇지 않으면(<code>a</code>가 <code>null</code>이면) <code>b</code>가 <code>null</code>을 참조하는지 검사한다.</p><p><code>null</code>을 직접 비교할 때 코드 최적화 포인트는 없다. <code>a == null</code>을 자동으로 <code>a === null</code>로 변환해준다.</p>
              </article>
          
              <article id="operator-overloading.html" class="page-content">
                <h2 id='operator-overloading.html_section'>연산자 오버로딩<a class='anchor' href='#%23section'> </a></h2><p>코틀린은 작성한 타입에 대해 미리 정의한 연산자의 구현을 제공할 수 있다. 이들 연산자는 (<code>+</code>나 <code>*</code>와 같은) 고정된 부호를 가지며 <a href='#grammar.html%23precedence'>우선순위</a>가 고정되어 있다.
연산자를 구현하려면 고정된 이름을 가진 <a href='#functions.html%23member-functions'>멤버 함수</a>나 <a href='#extensions.html'>확장 함수</a>를 제공하면 된다. 대응하는 타입은 이항 연산자의 경우 좌측 피연산자 타입이고 단항 연산자는 인자 타입이다.
연산자를 오버로딩하는 함수는 <code>operator</code> 제한자로 지정해야 한다.</p><h3 id='operator-overloading.html_section-1'>규칙<a class='anchor' href='#%23section-1'> </a></h3><p>다른 연산자를 위해 연산자 오버로딩을 규정하는 규칙을 설명한다.</p><h4 id='operator-overloading.html_section-2'>단항 오퍼레이션<a class='anchor' href='#%23section-2'> </a></h4><table>
  <thead>
    <tr>
      <th>식</th>
      <th>변환</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>+a</code></td>
      <td><code>a.unaryPlus()</code></td>
    </tr>
    <tr>
      <td><code>-a</code></td>
      <td><code>a.unaryMinus()</code></td>
    </tr>
    <tr>
      <td><code>!a</code></td>
      <td><code>a.not()</code></td>
    </tr>
  </tbody>
</table><p>예를 들어 컴파일러는 <code>+a</code> 식을 다음 절차에 따라 처리한다:</p><ul>
  <li><code>a</code>의 타입을 결정한다. 타입을 <code>T</code>라고 하자.</li>
  <li>리시버 <code>T</code>에서 파라미터를 갖지 않고 <code>operator</code> 제한자로 지정한 <code>unaryPlus()</code> 함수(멤버 함수나 확장 함수)를 찾는다.</li>
  <li>함수가 없거나 모호하면 컴파일 에러를 낸다.</li>
  <li>함수가 존재하고 리턴 타입이 <code>R</code>이면 <code>+a</code> 식은 <code>R</code> 타입을 갖는다.</li>
</ul><p>이 오퍼레이션과 다른 오퍼레이션은 <a href='#basic-types.html'>기본 타입</a>에 맞게 최적화되므로
오프레이션을 위한 함수 호출에 따른 오버헤드가 없다.</p><table>
  <thead>
    <tr>
      <th>식</th>
      <th>변환</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>a++</code></td>
      <td><code>a.inc()</code> + 아래 참고</td>
    </tr>
    <tr>
      <td><code>a--</code></td>
      <td><code>a.dec()</code> + 아래 참고</td>
    </tr>
  </tbody>
</table><p>이 오퍼레이션은 리시버를 변경하면서 (선택적으로) 값을 리턴해야 한다.</p><blockquote class='note'>
  <p><strong><code>inc()/dec()</code>에서 리시버 객체를 변경하면 안 된다</strong>.<br/>
“리시버를 변경한다”는 것은 리시버 객체가 아닌 _리시버-변수_를 의미한다.</p>
</blockquote><p>컴파일러는 다음 과정에 따라 <code>a++</code>와 같은 <em>후위</em> 연산자를 해석한다:</p><ul>
  <li><code>a</code>의 타입을 결정한다. 타입을 <code>T</code>라고 해 보자.</li>
  <li>리시버 타입 <code>T</code>에서 <code>operator</code> 제한자를 갖고 파라미터가 없는 <code>inc()</code> 함수를 찾는다.</li>
  <li>함수가 <code>R</code> 타입을 리턴하면 <code>R</code>은 <code>T</code>의 하위타입이어야 한다.</li>
</ul><p>식의 계산 결과는 다음과 같다:</p><ul>
  <li><code>a</code>의 초기 값을 임시 저장소인 <code>a0</code>에 보관한다,</li>
  <li><code>a.inc()</code>의 결과를 <code>a</code>에 할당한다.</li>
  <li>식의 결과로 <code>a0</code>를 리턴한다.</li>
</ul><p><code>a--</code> 처리 과정도 완전히 동일하다.</p><p><code>++a</code>와 <code>--a</code>와 같은 <em>전위</em> 식도 같은 방식으로 동작한다. 결과는 다음과 같다:</p><ul>
  <li><code>a.inc()</code>의 결과를 <code>a</code>에 할당한다,</li>
  <li>식의 결과로 <code>a</code>의 새 값을 리턴한다.</li>
</ul><h4 id='operator-overloading.html_section-3'>이항 오퍼레이션<a class='anchor' href='#%23section-3'> </a></h4><table>
  <thead>
    <tr>
      <th>식</th>
      <th>변환</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>a + b</code></td>
      <td><code>a.plus(b)</code></td>
    </tr>
    <tr>
      <td><code>a - b</code></td>
      <td><code>a.minus(b)</code></td>
    </tr>
    <tr>
      <td><code>a * b</code></td>
      <td><code>a.times(b)</code></td>
    </tr>
    <tr>
      <td><code>a / b</code></td>
      <td><code>a.div(b)</code></td>
    </tr>
    <tr>
      <td><code>a % b</code></td>
      <td><code>a.mod(b)</code></td>
    </tr>
    <tr>
      <td><code>a..b </code></td>
      <td><code>a.rangeTo(b)</code></td>
    </tr>
  </tbody>
</table><p>이 표의 오퍼레이션에 대해 컴파일러는 단순히 <em>변환</em> 칼럼의 식을 실행한다.</p><table>
  <thead>
    <tr>
      <th>Expression</th>
      <th>Translated to</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>a in b</code></td>
      <td><code>b.contains(a)</code></td>
    </tr>
    <tr>
      <td><code>a !in b</code></td>
      <td><code>!b.contains(a)</code></td>
    </tr>
  </tbody>
</table><p id='operator-overloading.html_in'><code>in</code>과 <code>!in</code>의 경우 절차는 같고 인자의 순서가 반대이다.</p><table>
  <thead>
    <tr>
      <th>심볼</th>
      <th>변환</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>a[i]</code></td>
      <td><code>a.get(i)</code></td>
    </tr>
    <tr>
      <td><code>a[i, j]</code></td>
      <td><code>a.get(i, j)</code></td>
    </tr>
    <tr>
      <td><code>a[i_1, ...,  i_n]</code></td>
      <td><code>a.get(i_1, ...,  i_n)</code></td>
    </tr>
    <tr>
      <td><code>a[i] = b</code></td>
      <td><code>a.set(i, b)</code></td>
    </tr>
    <tr>
      <td><code>a[i, j] = b</code></td>
      <td><code>a.set(i, j, b)</code></td>
    </tr>
    <tr>
      <td><code>a[i_1, ...,  i_n] = b</code></td>
      <td><code>a.set(i_1, ..., i_n, b)</code></td>
    </tr>
  </tbody>
</table><p>대괄호는 해당 개수만큼 인자를 가진 <code>get</code>과 <code>set</code> 메서드 호출로 변환된다.</p><table>
  <thead>
    <tr>
      <th>심볼</th>
      <th>변환</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>a()</code></td>
      <td><code>a.invoke()</code></td>
    </tr>
    <tr>
      <td><code>a(i)</code></td>
      <td><code>a.invoke(i)</code></td>
    </tr>
    <tr>
      <td><code>a(i, j)</code></td>
      <td><code>a.invoke(i, j)</code></td>
    </tr>
    <tr>
      <td><code>a(i_1, ...,  i_n)</code></td>
      <td><code>a.invoke(i_1, ...,  i_n)</code></td>
    </tr>
  </tbody>
</table><p>괄호는 해당 개수의 인자를 갖는 <code>invoke</code> 호출로 바뀐다.</p><table id='operator-overloading.html_assignments'>
  <thead>
    <tr>
      <th>식</th>
      <th>변환</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>a += b</code></td>
      <td><code>a.plusAssign(b)</code></td>
    </tr>
    <tr>
      <td><code>a -= b</code></td>
      <td><code>a.minusAssign(b)</code></td>
    </tr>
    <tr>
      <td><code>a *= b</code></td>
      <td><code>a.timesAssign(b)</code></td>
    </tr>
    <tr>
      <td><code>a /= b</code></td>
      <td><code>a.divAssign(b)</code></td>
    </tr>
    <tr>
      <td><code>a %= b</code></td>
      <td><code>a.modAssign(b)</code></td>
    </tr>
  </tbody>
</table><p><code>a += b</code>와 같은 할당 오퍼레이션의 경우 컴파일러가 다음 과정을 수행한다:</p><ul>
  <li>우측 칼럼의 함수를 사용할 수 있으면
    <ul>
      <li>해당 이항 함수(<code>plusAssign()</code>의 경우 <code>plus()</code>)가 존재하면 에러를 발생한다(모호함)</li>
      <li>리턴 타입이 <code>Unit</code>인지 확인하고 아니면 에러를 발생한다.</li>
      <li><code>a.plusAssign(b)</code> 코드를 생성한다.</li>
    </ul>
  </li>
  <li>그렇지 않으면, <code>a = a + b</code> 코드 생성을 시도한다(이는 타입 검사를 포함한다. <code>a + b</code>의 타입은 <code>a</code>의 하위타입이어야 한다).</li>
</ul><p id='operator-overloading.html_Equals'><em>주의</em>: 할당은 코틀린에서 식이 <em>아니다</em>.</p><table>
  <thead>
    <tr>
      <th>식</th>
      <th>변환</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>a == b</code></td>
      <td><code>a?.equals(b) ?: b === null</code></td>
    </tr>
    <tr>
      <td><code>a != b</code></td>
      <td><code>!(a?.equals(b) ?: b === null)</code></td>
    </tr>
  </tbody>
</table><p><em>노트</em>: <code>===</code>와 <code>!==</code> (동일성 검사)는 오버로딩할 수 없으므로 어떤 규칙도 존재하지 않는다</p><p><code>==</code> 오퍼레이션은 특수하다: <code>null</code>을 걸러내어 <code>null == null</code>이 <code>true</code>가 되는 복잡한 식으로 바뀐다.</p><table>
  <thead>
    <tr>
      <th>심볼</th>
      <th>볂솬</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>a &gt; b</code></td>
      <td><code>a.compareTo(b) &gt; 0</code></td>
    </tr>
    <tr>
      <td><code>a &lt; b</code></td>
      <td><code>a.compareTo(b) &lt; 0</code></td>
    </tr>
    <tr>
      <td><code>a &gt;= b</code></td>
      <td><code>a.compareTo(b) &gt;= 0</code></td>
    </tr>
    <tr>
      <td><code>a &lt;= b</code></td>
      <td><code>a.compareTo(b) &lt;= 0</code></td>
    </tr>
  </tbody>
</table><p>모든 비교는 <code>compareTo</code>에 대한 호출로 바뀐다. <code>compareTo</code> 함수는 <code>Int</code>를 리턴해야 한다.</p><h3 id='operator-overloading.html_section-4'>네임드 함수에 대한 중위 호출<a class='anchor' href='#%23section-4'> </a></h3><p><a href='#functions.html%23infix-notation'>중위 함수 호출</a>을 사용해서 커스텀 중위 오퍼레이션을 흉내낼 수 있다.</p>
              </article>
          
              <article id="null-safety.html" class="page-content">
                <h2 id='null-safety.html_null-'>Null 안전성<a class='anchor' href='#%23null-'> </a></h2><h3 id='null-safety.html_nullable--non-null-'>Nullable 타입과 non-null 타입<a class='anchor' href='#%23nullable--non-null-'> </a></h3><p>코틀린 타입 시스템은 <a href='#http%3A%2F%2Fen.wikipedia.org%2Fwiki%2FTony_Hoare%23Apologies_and_retractions'>The Billion Dollar Mistake</a>라고 불리는 null 참조 위험을 제거하는데 목표가 있다.</p><p>자바를 포함한 많은 프로그래밍 언어에서 가장 흔한 위험 중 하나가 null 레퍼런스의 멤버에 접근해서 발생하는 null 참조 익셉션이다.
자바에서는 <code>NullPointerException</code> 또는 줄여서 NPE가 이에 해당한다.</p><p>코틀린 타입 시스템은 코드에서 <code>NullPointerException</code>을 제거하려고 노력했다. 오직 다음 경우만 NPE가 발생한다.</p><ul>
  <li>직접 <code>throw NullPointerException()</code>을 실행</li>
  <li>아래 설명할 <code>!!</code> 연산자 사용</li>
  <li>외부 자바 코드에서 발생</li>
  <li>초기화에 관한 데이터 불일치 존재(생성자에서 초기화하지 않은 <em>this</em>를 어딘가에서 사용)</li>
</ul><p>코틀린 타입 시스템은 <em class='keyword'>null</em>을 가질 수 있는 레퍼런스(nullable 레퍼런스)와 가질 수 없는 레퍼런스(non-null 레퍼런스)를 구분한다.
예를 들어, 일반 <code>String</code> 타입 변수는 <em class='keyword'>null</em>을 가질 수 없다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>var</span> <span class='py'>a</span><span class='p'>:</span> <span class='n'>String</span> <span class='p'>=</span> <span class='s'>&quot;abc&quot;</span>
<span class='n'>a</span> <span class='p'>=</span> <span class='k'>null</span> <span class='c1'>// 컴파일 에러</span></code></pre><p>null을 가지려면 <code>String?</code>로 쓴 nullable String을 변수로 선언해야 한다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>var</span> <span class='py'>b</span><span class='p'>:</span> <span class='n'>String</span><span class='p'>?</span> <span class='p'>=</span> <span class='s'>&quot;abc&quot;</span>
<span class='n'>b</span> <span class='p'>=</span> <span class='k'>null</span> <span class='c1'>// ok</span></code></pre><p><code>a</code>의 프로퍼티에 접근하거나 메서드를 호출할 때 NPE가 발생하지 않음을 보장할 수 있으며 다음 코드가 안전하다고 할 수 있다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>l</span> <span class='p'>=</span> <span class='n'>a</span><span class='p'>.</span><span class='n'>length</span></code></pre><p>하지만 <code>b</code>의 프로퍼티에 접근하면 안전하지 않으므로 컴파일러는 에러를 발생한다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>l</span> <span class='p'>=</span> <span class='n'>b</span><span class='p'>.</span><span class='n'>length</span> <span class='c1'>// 에러: 변수 &#39;b&#39;가 null일 수 있다</span></code></pre><p>그래도 b의 프로퍼티에 접근하고 싶다면 몇 가지 할 수 있는 방법이 있다.</p><h3 id='null-safety.html_null-keyword--'>조건에서 <em class='keyword'>null</em>을 검사하기<a class='anchor' href='#%23null-keyword--'> </a></h3><p>첫 번째 방법은 <code>b</code>가 <em class='keyword'>null</em>인지 검사하고 두 상황을 각각 처리하는 것이다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>l</span> <span class='p'>=</span> <span class='k'>if</span> <span class='p'>(</span><span class='n'>b</span> <span class='p'>!=</span> <span class='k'>null</span><span class='p'>)</span> <span class='n'>b</span><span class='p'>.</span><span class='n'>length</span> <span class='k'>else</span> <span class='p'>-</span><span class='m'>1</span></code></pre><p>컴파일러는 검사 결과를 추적하며, <em class='keyword'>if</em> 안에서 <code>length</code>를 호출할 수 있도록 한다.
더 복잡한 조건도 지원한다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>if</span> <span class='p'>(</span><span class='n'>b</span> <span class='p'>!=</span> <span class='k'>null</span> <span class='p'>&amp;&amp;</span> <span class='n'>b</span><span class='p'>.</span><span class='n'>length</span> <span class='p'>&gt;</span> <span class='m'>0</span><span class='p'>)</span>
  <span class='n'>print</span><span class='p'>(</span><span class='s'>&quot;String of length ${b.length}&quot;</span><span class='p'>)</span>
<span class='k'>else</span>
  <span class='n'>print</span><span class='p'>(</span><span class='s'>&quot;Empty string&quot;</span><span class='p'>)</span></code></pre><p>이 코드는 오직 <code>b</code>가 불변(예, 검사와 사용 사이에 바뀌지 않는 로컬 변수 또는 backing 필드를 갖거나 오버라이딩할 수 없는 <em class='keyword'>val</em> 멤버)인 경우에만 동작한다.
왜냐면 불변이 아니면 검사 이후에 <code>b</code>를 <em class='keyword'>null</em>로 바꾸는 일이 벌어질 수 있기 때문이다.</p><h3 id='null-safety.html_section'>안전한 호출<a class='anchor' href='#%23section'> </a></h3><p>두 번째 방법은 안전 호출 연산자인 <code>?.</code>를 사용하는 것이다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>b</span><span class='o'>?.</span><span class='n'>length</span></code></pre><p><code>b</code>가 null이 아니면 <code>b.length</code>를 리턴하고 아니면 <em class='keyword'>null</em>을 리턴한다. 이 식의 타입은 <code>Int?</code>이다.</p><p>안전 호출은 연속할 때 유용하다. 예를 들어, Employee 타입 bob을 Department에 할당하거나 그렇지 않을 수 있고 또 다른 Employee를 Department의 head로 가질 수 있을 때,
Bob의 department head가 존재하면 그 이름을 구하는 코드를 다음과 같이 작성할 수 있다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>bob</span><span class='o'>?.</span><span class='n'>department</span><span class='o'>?.</span><span class='n'>head</span><span class='o'>?.</span><span class='n'>name</span></code></pre><p>프로퍼티 중 하나라도 null이면 이 체인은 <em class='keyword'>null</em>을 리턴한다.</p><h3 id='null-safety.html_section-1'>엘비스 연산자<a class='anchor' href='#%23section-1'> </a></h3><p>nullable 레퍼런스 <code>r</code>이 있을 때, “<code>r</code>이 not null이면 그것을 사용하고, 아니면 non-null 값 <code>x</code>를 사용”하는 코드는 다음과 같이 작성한다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>l</span><span class='p'>:</span> <span class='n'>Int</span> <span class='p'>=</span> <span class='k'>if</span> <span class='p'>(</span><span class='n'>b</span> <span class='p'>!=</span> <span class='k'>null</span><span class='p'>)</span> <span class='n'>b</span><span class='p'>.</span><span class='n'>length</span> <span class='k'>else</span> <span class='p'>-</span><span class='m'>1</span></code></pre><p>완전한 <em class='keyword'>if</em>-식 대신 엘비스 연산자인 <code>?:</code>를 사용해서 이를 표현할 수 있다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>l</span> <span class='p'>=</span> <span class='n'>b</span><span class='o'>?.</span><span class='n'>length</span> <span class='o'>?:</span> <span class='p'>-</span><span class='m'>1</span></code></pre><p><code>?:</code>의 왼쪽 식이 null이 아니면 엘비스 연산자는 그것을 리턴하고, 그렇지 않으면 오른쪽 식을 리턴한다.
우측 식은 왼쪽 식이 null인 경우에만 평가한다.</p><p>코틀린에서 <em class='keyword'>throw</em>와 <em class='keyword'>return</em>은 식이기 때문에 엘비스 연산자의 우측에 사용할 수 있다.
이는 함수 인자를 검사할 때 매우 유용하게 쓸 수 있다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>foo</span><span class='p'>(</span><span class='n'>node</span><span class='p'>:</span> <span class='n'>Node</span><span class='p'>):</span> <span class='n'>String</span><span class='p'>?</span> <span class='p'>{</span>
  <span class='k'>val</span> <span class='py'>parent</span> <span class='p'>=</span> <span class='n'>node</span><span class='p'>.</span><span class='n'>getParent</span><span class='p'>()</span> <span class='o'>?:</span> <span class='k'>return</span> <span class='k'>null</span>
  <span class='k'>val</span> <span class='py'>name</span> <span class='p'>=</span> <span class='n'>node</span><span class='p'>.</span><span class='n'>getName</span><span class='p'>()</span> <span class='o'>?:</span> <span class='k'>throw</span> <span class='n'>IllegalArgumentException</span><span class='p'>(</span><span class='s'>&quot;name expected&quot;</span><span class='p'>)</span>
  <span class='c1'>// ...</span>
<span class='p'>}</span></code></pre><h3 id='null-safety.html_section-2'><code>!!</code> 연산자<a class='anchor' href='#%23section-2'> </a></h3><p>세 번째 방법은 NPE-추종자를 위한 것이다. <code>b!!</code>라고 작성하면 <code>b</code>가 non-null이면 값을 리턴하고(이 예에서는 <code>String</code>)
<code>b</code>가 null이면 NPE를 발생한다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>l</span> <span class='p'>=</span> <span class='n'>b</span><span class='o'>!!</span><span class='p'>.</span><span class='n'>length</span><span class='p'>()</span></code></pre><p>따라서, NPE를 원한다면 NPE를 사용할 수 있다. 하지만, NPE를 명시적으로 써야만 한다면 생각하지 못한 곳에서 NPE가 발생하면 안 된다.</p><h3 id='null-safety.html_section-3'>안전한 변환<a class='anchor' href='#%23section-3'> </a></h3><p>일반 변환은 객체가 대상 타입이 아니면 <code>ClassCastException</code>을 발생한다.
다른 옵션은 변환에 실패할 때 <em class='keyword'>null</em>을 리턴하는 안전 변환을 사용하는 것이다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>aInt</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>?</span> <span class='p'>=</span> <span class='n'>a</span> <span class='k'>as</span><span class='p'>?</span> <span class='n'>Int</span></code></pre>
              </article>
          
              <article id="exceptions.html" class="page-content">
                <h2 id='exceptions.html_section'>익셉션<a class='anchor' href='#%23section'> </a></h2><h3 id='exceptions.html_section-1'>익셉션 클래스<a class='anchor' href='#%23section-1'> </a></h3><p>코틀린의 모든 익셉션 클래스는 <code>Throwable</code> 클래스의 자식이다.
모든 익셉션은 메시지, 스택 트레이스 그리고 선택적으로 원인을 갖는다.</p><p>익셉션 객체를 발생하려면 <em class='keyword'>throw</em>-식을 사용한다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>throw</span> <span class='n'>MyException</span><span class='p'>(</span><span class='s'>&quot;Hi There!&quot;</span><span class='p'>)</span></code></pre><p>익셉션을 잡으려면 <em class='keyword'>try</em>-식을 사용한다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>try</span> <span class='p'>{</span>
  <span class='c1'>// some code</span>
<span class='p'>}</span>
<span class='k'>catch</span> <span class='p'>(</span><span class='n'>e</span><span class='p'>:</span> <span class='n'>SomeException</span><span class='p'>)</span> <span class='p'>{</span>
  <span class='c1'>// handler</span>
<span class='p'>}</span>
<span class='k'>finally</span> <span class='p'>{</span>
  <span class='c1'>// optional finally block</span>
<span class='p'>}</span></code></pre><p><em class='keyword'>catch</em> 블록은 없거나 한 개 이상 존재할 수 있다. <em class='keyword'>finally</em> 블록은 생략할 수 있다.
하지만, 최소한 한 개의 <em class='keyword'>catch</em> 블록이나 <em class='keyword'>finally</em> 블록이 있어야 한다.</p><h4 id='exceptions.html_try-'>try는 식이다<a class='anchor' href='#%23try-'> </a></h4><p><em class='keyword'>try</em>는 식이며 리턴 값을 가질 수 있다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>a</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>?</span> <span class='p'>=</span> <span class='k'>try</span> <span class='p'>{</span> <span class='n'>parseInt</span><span class='p'>(</span><span class='n'>input</span><span class='p'>)</span> <span class='p'>}</span> <span class='k'>catch</span> <span class='p'>(</span><span class='n'>e</span><span class='p'>:</span> <span class='n'>NumberFormatException</span><span class='p'>)</span> <span class='p'>{</span> <span class='k'>null</span> <span class='p'>}</span></code></pre><p><em class='keyword'>try</em> 블록의 마지막 식이나 <em class='keyword'>catch</em> 블록(또는 블록들)의 마지막 식을 <em class='keyword'>try</em>-식의 리턴 값으로 사용한다.
<em class='keyword'>finally</em> 블록의 내용은 식 결과에 영향을 주지 않는다.</p><h3 id='exceptions.html_section-2'>체크트 익셉션<a class='anchor' href='#%23section-2'> </a></h3><p>코틀린에는 체크트 익셉션이 없다. 없는데는 여러 이유가 있는데 간단한 예로 알아보자.</p><p>다음은 <code>StringBuilder</code> 클래스가 구현한 JDK 인터페이스이다.</p><pre><code class='code-block _highlighted lang_java'><span class='n'>Appendable</span> <span class='nf'>append</span><span class='o'>(</span><span class='n'>CharSequence</span> <span class='n'>csq</span><span class='o'>)</span> <span class='kd'>throws</span> <span class='n'>IOException</span><span class='o'>;</span></code></pre><p>이 시그너처가 무엇을 말하나? 이는 문자열을 어딘가에 저장할 때마다(예를 들어, <code>StringBuilder</code>, 어떤 종류의 로그, 콘솔 등) <code>IOException</code>을 캐치해야 한다.
왜냐면 IO를 수행할지도 모르기 때문이다(<code>Writer</code>도 <code>Appendable</code>을 구현하고 있다).
따라서 도처에서 다음과 같은 코드를 작성하게 된다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>try</span> <span class='p'>{</span>
  <span class='n'>log</span><span class='p'>.</span><span class='n'>append</span><span class='p'>(</span><span class='n'>message</span><span class='p'>)</span>
<span class='p'>}</span>
<span class='k'>catch</span> <span class='p'>(</span><span class='n'>IOException</span> <span class='n'>e</span><span class='p'>)</span> <span class='p'>{</span>
  <span class='c1'>// 안전해야 함</span>
<span class='p'>}</span></code></pre><p>이는 좋지 않다. <a href='#http%3A%2F%2Fwww.oracle.com%2Ftechnetwork%2Fjava%2Feffectivejava-136174.html'>Effective Java</a>, Item 65: <em>Don’t ignore exceptions</em> 절을 보자.</p><p>Bruce Eckel는 <a href='#http%3A%2F%2Fwww.mindview.net%2FEtc%2FDiscussions%2FCheckedExceptions'>자바에 체크드 익셉션이 필요한가?</a> 라고 말했다.</p><blockquote>
  <p>작은 프로그램 조사에서는 익셉션 규약이 개발자 생산성과 코드 품질을 높여준다는 결론을 이끌지만, 대형 소프트웨어 프로젝트에서의 경험은 오히려 생산성을 낮추고 코드 품질 상승에 거의 효과가 없음이 밝혀졌다.</p>
</blockquote><p>이와 관련된 글:</p><ul>
  <li><a href='#http%3A%2F%2Fradio-weblogs.com%2F0122027%2Fstories%2F2003%2F04%2F01%2FJavasCheckedExceptionsWereAMistake.html'>Java’s checked exceptions were a mistake</a> (Rod Waldhoff)</li>
  <li><a href='#http%3A%2F%2Fwww.artima.com%2Fintv%2Fhandcuffs.html'>The Trouble with Checked Exceptions</a> (Anders Hejlsberg)</li>
</ul><h3 id='exceptions.html_section-3'>자바 상호운용<a class='anchor' href='#%23section-3'> </a></h3><p>자바 상호운용에 대한 정보는 <a href='#java-interop.html'>자바 상호운용</a>의 익셉션 절을 참고하자.</p>
              </article>
          
              <article id="annotations.html" class="page-content">
                <h2 id='annotations.html_section'>애노테이션<a class='anchor' href='#%23section'> </a></h2><h3 id='annotations.html_section-1'>애노테이션 선언<a class='anchor' href='#%23section-1'> </a></h3><p>애노테이션은 코드에 메타데이터를 추가하는 방법이다. 애노테이션을 선언하려면 <em class='keyword'>annotation</em> 제한자를 클래스 앞에 넣으면 된다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>annotation</span> <span class='k'>class</span> <span class='nc'>Fancy</span></code></pre><p>애노테이션 클래스에 메타 애노테이션을 붙여서 애노테이션의 속성을 지정할 수 있다:</p><ul>
  <li><a href='#%2Fapi%2Flatest%2Fjvm%2Fstdlib%2Fkotlin.annotation%2F-target%2Findex.html'><code>@Target</code></a>은 애노테이션을 할 수 있는 요소 종류를 지정한다(클래스, 함수, 프로퍼티, 식 등);</li>
  <li><a href='#%2Fapi%2Flatest%2Fjvm%2Fstdlib%2Fkotlin.annotation%2F-retention%2Findex.html'><code>@Retention</code></a>은 애노테이션을 컴파일한 클래스에 보관할지 여부와 런타임에 리플렉션을 통해 접근할 수 있는지 여부를 지정한다(기본은 둘 다 true);</li>
  <li><a href='#%2Fapi%2Flatest%2Fjvm%2Fstdlib%2Fkotlin.annotation%2F-repeatable%2Findex.html'><code>@Repeatable</code></a>은 같은 애노테이션을 한 요소에 여러 번 적용할 수 있는지 여부를 지정한다;</li>
  <li><a href='#%2Fapi%2Flatest%2Fjvm%2Fstdlib%2Fkotlin.annotation%2F-must-be-documented%2Findex.html'><code>@MustBeDocumented</code></a>은 애노테이션이 공개 API에 속하는지 여부와 생성한 API 문서의 클래스나 메서드 시그너처에 포함해야 하는지 여부를 지정한다.</li>
</ul><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>@Target</span><span class='p'>(</span><span class='n'>AnnotationTarget</span><span class='p'>.</span><span class='n'>CLASS</span><span class='p'>,</span> <span class='n'>AnnotationTarget</span><span class='p'>.</span><span class='n'>FUNCTION</span><span class='p'>,</span>
        <span class='n'>AnnotationTarget</span><span class='p'>.</span><span class='n'>VALUE_PARAMETER</span><span class='p'>,</span> <span class='n'>AnnotationTarget</span><span class='p'>.</span><span class='n'>EXPRESSION</span><span class='p'>)</span>
<span class='n'>@Retention</span><span class='p'>(</span><span class='n'>AnnotationRetention</span><span class='p'>.</span><span class='n'>SOURCE</span><span class='p'>)</span>
<span class='n'>@MustBeDocumented</span>
<span class='k'>public</span> <span class='k'>annotation</span> <span class='k'>class</span> <span class='nc'>Fancy</span></code></pre><h4 id='annotations.html_section-2'>용법<a class='anchor' href='#%23section-2'> </a></h4><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>@Fancy</span> <span class='k'>class</span> <span class='nc'>Foo</span> <span class='p'>{</span>
  <span class='n'>@Fancy</span> <span class='k'>fun</span> <span class='nf'>baz</span><span class='p'>(</span><span class='n'>@Fancy</span> <span class='n'>foo</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>):</span> <span class='n'>Int</span> <span class='p'>{</span>
    <span class='k'>return</span> <span class='p'>(</span><span class='n'>@Fancy</span> <span class='m'>1</span><span class='p'>)</span>
  <span class='p'>}</span>
<span class='p'>}</span></code></pre><p>클래스의 주요 생성자에 애노테이션을 하고 싶으면 <em class='keyword'>constructor</em> 키워드를 생성자 선언에 추가하고 그 키워드 앞에 애노테이션을 넣으면 된다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>class</span> <span class='nc'>Foo</span> <span class='n'>@Inject</span> <span class='n'>constructor</span><span class='p'>(</span><span class='n'>dependency</span><span class='p'>:</span> <span class='n'>MyDependency</span><span class='p'>)</span> <span class='p'>{</span>
  <span class='c1'>// ...</span>
<span class='p'>}</span></code></pre><p>프로퍼티 accessor에도 애노테이션 할 수 있다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>class</span> <span class='nc'>Foo</span> <span class='p'>{</span>
    <span class='k'>var</span> <span class='py'>x</span><span class='p'>:</span> <span class='n'>MyDependency</span><span class='p'>?</span> <span class='p'>=</span> <span class='k'>null</span>
        <span class='n'>@Inject</span> <span class='k'>set</span>
<span class='p'>}</span></code></pre><h4 id='annotations.html_section-3'>생성자<a class='anchor' href='#%23section-3'> </a></h4><p>애노테이션은 파라미터가 있는 생성자를 가질 수 있다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>annotation</span> <span class='k'>class</span> <span class='nc'>Special</span><span class='p'>(</span><span class='k'>val</span> <span class='py'>why</span><span class='p'>:</span> <span class='n'>String</span><span class='p'>)</span>

<span class='n'>@Special</span><span class='p'>(</span><span class='s'>&quot;example&quot;</span><span class='p'>)</span> <span class='k'>class</span> <span class='nc'>Foo</span> <span class='p'>{}</span></code></pre><p>허용하는 파라미터 타입은 다음과 같다:</p><ul>
  <li>자바의 기본 타입에 해당하는 타입(Int, Long 등);</li>
  <li>문자열;</li>
  <li>클래스(<code>Foo::class</code>);</li>
  <li>열거형;</li>
  <li>다른 애노테이션;</li>
  <li>위에 나열한 타입의 배열.</li>
</ul><p>애노테이션을 다른 애노테이션의 파라미터로 사용하면 @ 문자를 이름 앞에 붙이지 않는다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>public</span> <span class='k'>annotation</span> <span class='k'>class</span> <span class='nc'>ReplaceWith</span><span class='p'>(</span><span class='k'>val</span> <span class='py'>expression</span><span class='p'>:</span> <span class='n'>String</span><span class='p'>)</span>

<span class='k'>public</span> <span class='k'>annotation</span> <span class='k'>class</span> <span class='nc'>Deprecated</span><span class='p'>(</span>
        <span class='k'>val</span> <span class='py'>message</span><span class='p'>:</span> <span class='n'>String</span><span class='p'>,</span>
        <span class='k'>val</span> <span class='py'>replaceWith</span><span class='p'>:</span> <span class='n'>ReplaceWith</span> <span class='p'>=</span> <span class='n'>ReplaceWith</span><span class='p'>(</span><span class='s'>&quot;&quot;</span><span class='p'>))</span>

<span class='n'>@Deprecated</span><span class='p'>(</span><span class='s'>&quot;This function is deprecated, use === instead&quot;</span><span class='p'>,</span> <span class='n'>ReplaceWith</span><span class='p'>(</span><span class='s'>&quot;this === other&quot;</span><span class='p'>))</span></code></pre><h4 id='annotations.html_section-4'>람다<a class='anchor' href='#%23section-4'> </a></h4><p>람다에서도 애노테이션을 사용할 수 있다. 람다의 몸체를 생성할 때 <code>invoke()</code> 메서드에 애노테이션을 적용한다.
동시성 제어를 위해 애노테이션을 사용하는 <a href='#http%3A%2F%2Fwww.paralleluniverse.co%2Fquasar%2F'>Quasar</a>와 같은 프레임워크에서 이를 유용하게 쓰고 있다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>annotation</span> <span class='k'>class</span> <span class='nc'>Suspendable</span>

<span class='k'>val</span> <span class='py'>f</span> <span class='p'>=</span> <span class='n'>@Suspendable</span> <span class='p'>{</span> <span class='n'>Fiber</span><span class='p'>.</span><span class='n'>sleep</span><span class='p'>(</span><span class='m'>10</span><span class='p'>)</span> <span class='p'>}</span></code></pre><h3 id='annotations.html_use-site--'>사용-위치(Use-site) 대상 애노테이션<a class='anchor' href='#%23use-site--'> </a></h3><p>주요 생성자 파라미터나 프로퍼티는 여러 자바 요소를 생성할 수 있다.
따라서, 이 코틀린 요소에 애노테이션을 달면 생성한 자바 바이트코드의 여러 위치에 애노테이션이 붙을 수 있다.
정확하게 애노테이션을 어느 자바 요소에 생성할지 지정하려면 다음 구문을 사용한다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>class</span> <span class='nc'>Example</span><span class='p'>(</span><span class='n'>@field</span><span class='p'>:</span><span class='n'>Ann</span> <span class='k'>val</span> <span class='py'>foo</span><span class='p'>,</span>    <span class='c1'>// 자바 필드</span>
              <span class='n'>@get</span><span class='p'>:</span><span class='n'>Ann</span> <span class='k'>val</span> <span class='py'>bar</span><span class='p'>,</span>      <span class='c1'>// 자바 getter</span>
              <span class='n'>@param</span><span class='p'>:</span><span class='n'>Ann</span> <span class='k'>val</span> <span class='py'>quux</span><span class='p'>)</span>   <span class='c1'>// 자바 생성자 파라미터</span></code></pre><p>같은 구문을 전체 파일을 애노테이션 할 때에 사용할 수 있다. 이를 하기 위해 패키지 디렉티브 전에 또는 기본 패키지면 모든 임포트 전에
파일 최상단에 대상이 <code>file</code>인 애노테이션을 넣는다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>@file</span><span class='p'>:</span><span class='n'>JvmName</span><span class='p'>(</span><span class='s'>&quot;Foo&quot;</span><span class='p'>)</span>

<span class='k'>package</span> <span class='nn'>org.jetbrains.demo</span></code></pre><p>여러 애노테이션을 같은 대상에 적용하고 싶다면 대상 뒤에 대괄호 안에 모든 애노테이션을 넣어서 대상을 반복하는 것을 피할 수 있다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>class</span> <span class='nc'>Example</span> <span class='p'>{</span>
     <span class='n'>@set</span><span class='p'>:[</span><span class='n'>Inject</span> <span class='n'>VisibleForTesting</span><span class='p'>]</span>
     <span class='k'>public</span> <span class='k'>var</span> <span class='py'>collaborator</span><span class='p'>:</span> <span class='n'>Collaborator</span>
<span class='p'>}</span></code></pre><p>지원하는 전체 사용 위치(use-site) 대상은 다음과 같다:</p><ul>
  <li><code>file</code></li>
  <li><code>property</code> (이 대상을 갖는 애노테이션은 자바에는 보이지 않는다)</li>
  <li><code>field</code></li>
  <li><code>get</code> (프로퍼티 getter)</li>
  <li><code>set</code> (프로퍼티 setter)</li>
  <li><code>receiver</code> (확장 함수나 프로퍼티의 리시버 파라미터)</li>
  <li><code>param</code> (생성자 파라미터)</li>
  <li><code>setparam</code> (프로퍼티 setter 파라미터)</li>
  <li><code>delegate</code> (위임 프로퍼티를 위한 위임 인스턴스를 보관한 필드)</li>
</ul><p>확장 함수의 리시버 파라미터를 애노테이션 하려면 다음 구문을 사용한다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>@receiver</span><span class='p'>:</span><span class='n'>Fancy</span> <span class='n'>String</span><span class='p'>.</span><span class='n'>myExtension</span><span class='p'>()</span> <span class='p'>{</span> <span class='p'>}</span></code></pre><p>사용 위치(use-site) 대상을 지정하지 않으면 사용할 애노테이션의 <code>@Target</code> 애노테이션에 따라 대상을 선택한다.
만약 여러 대상이 적용 가능하면 다음 목록에서 먼저 적용할 수 있는 대상을 선택한다:</p><ul>
  <li><code>param</code></li>
  <li><code>property</code></li>
  <li><code>field</code></li>
</ul><h3 id='annotations.html_section-5'>자바 애노테이션<a class='anchor' href='#%23section-5'> </a></h3><p>자바 애노테이션은 코틀린과 100% 호환된다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>import</span> <span class='nn'>org.junit.Test</span>
<span class='k'>import</span> <span class='nn'>org.junit.Assert.*</span>

<span class='k'>class</span> <span class='nc'>Tests</span> <span class='p'>{</span>
  <span class='n'>@Test</span> <span class='k'>fun</span> <span class='nf'>simple</span><span class='p'>()</span> <span class='p'>{</span>
    <span class='n'>assertEquals</span><span class='p'>(</span><span class='m'>42</span><span class='p'>,</span> <span class='n'>getTheAnswer</span><span class='p'>())</span>
  <span class='p'>}</span>
<span class='p'>}</span></code></pre><p>자바로 작성한 애노테이션은 파라미터 순서가 없기 때문에, 인자를 전달할 때 일반 함수 호출 구문을 사용할 수 없다.
대신 네임드 인자 구문을 사용해야 한다.</p><pre><code class='code-block _highlighted lang_java'><span class='c1'>// Java</span>
<span class='kd'>public</span> <span class='nd'>@interface</span> <span class='n'>Ann</span> <span class='o'>{</span>
    <span class='kt'>int</span> <span class='nf'>intValue</span><span class='o'>();</span>
    <span class='n'>String</span> <span class='nf'>stringValue</span><span class='o'>();</span>
<span class='o'>}</span></code></pre><pre><code class='code-block _highlighted lang_kotlin'><span class='c1'>// Kotlin</span>
<span class='n'>@Ann</span><span class='p'>(</span><span class='n'>intValue</span> <span class='p'>=</span> <span class='m'>1</span><span class='p'>,</span> <span class='n'>stringValue</span> <span class='p'>=</span> <span class='s'>&quot;abc&quot;</span><span class='p'>)</span> <span class='k'>class</span> <span class='nc'>C</span></code></pre><p>자바와 마찬가지로 <code>value</code> 파라미터는 특수 케이스다. 이름 없이 이 파라미터 값을 지정할 수 있다.</p><pre><code class='code-block _highlighted lang_java'><span class='c1'>// Java</span>
<span class='kd'>public</span> <span class='nd'>@interface</span> <span class='n'>AnnWithValue</span> <span class='o'>{</span>
    <span class='n'>String</span> <span class='nf'>value</span><span class='o'>();</span>
<span class='o'>}</span></code></pre><pre><code class='code-block _highlighted lang_kotlin'><span class='c1'>// Kotlin</span>
<span class='n'>@AnnWithValue</span><span class='p'>(</span><span class='s'>&quot;abc&quot;</span><span class='p'>)</span> <span class='k'>class</span> <span class='nc'>C</span></code></pre><p>자바에서 <code>value</code> 인지가 배열 타입이면 코틀린의 <code>vararg</code> 파라미터가 된다:</p><pre><code class='code-block _highlighted lang_java'><span class='c1'>// Java</span>
<span class='kd'>public</span> <span class='nd'>@interface</span> <span class='n'>AnnWithArrayValue</span> <span class='o'>{</span>
    <span class='n'>String</span><span class='o'>[]</span> <span class='nf'>value</span><span class='o'>();</span>
<span class='o'>}</span></code></pre><pre><code class='code-block _highlighted lang_kotlin'><span class='c1'>// Kotlin</span>
<span class='n'>@AnnWithArrayValue</span><span class='p'>(</span><span class='s'>&quot;abc&quot;</span><span class='p'>,</span> <span class='s'>&quot;foo&quot;</span><span class='p'>,</span> <span class='s'>&quot;bar&quot;</span><span class='p'>)</span> <span class='k'>class</span> <span class='nc'>C</span></code></pre><p>애노테이션 인자로 클래스를 지정하고 싶다면 코틀린 클래스
(<a href='#%2Fapi%2Flatest%2Fjvm%2Fstdlib%2Fkotlin.reflect%2F-k-class%2Findex.html'>KClass</a>)를 사용한다.
코틀린 컴파일러는 KClass를 자동으로 자바 클래스로 변환하므로 자바 코드는 애노테이션과 인자를 볼 수 있다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>import</span> <span class='nn'>kotlin.reflect.KClass</span>

<span class='k'>annotation</span> <span class='k'>class</span> <span class='nc'>Ann</span><span class='p'>(</span><span class='k'>val</span> <span class='py'>arg1</span><span class='p'>:</span> <span class='n'>KClass</span><span class='p'>&lt;*&gt;,</span> <span class='k'>val</span> <span class='py'>arg2</span><span class='p'>:</span> <span class='n'>KClass</span><span class='p'>&lt;</span><span class='k'>out</span> <span class='n'>Any</span><span class='p'>?&gt;)</span>

<span class='n'>@Ann</span><span class='p'>(</span><span class='n'>String</span><span class='o'>::</span><span class='k'>class</span><span class='p'>,</span> <span class='n'>Int</span><span class='o'>::</span><span class='k'>class</span><span class='p'>)</span> <span class='k'>class</span> <span class='nc'>MyClass</span></code></pre><p>애노테이션 인스턴스의 값은 코틀린 코드에서 프로퍼티로 노출된다.</p><pre><code class='code-block _highlighted lang_java'><span class='c1'>// Java</span>
<span class='kd'>public</span> <span class='nd'>@interface</span> <span class='n'>Ann</span> <span class='o'>{</span>
    <span class='kt'>int</span> <span class='nf'>value</span><span class='o'>();</span>
<span class='o'>}</span></code></pre><pre><code class='code-block _highlighted lang_kotlin'><span class='c1'>// Kotlin</span>
<span class='k'>fun</span> <span class='nf'>foo</span><span class='p'>(</span><span class='n'>ann</span><span class='p'>:</span> <span class='n'>Ann</span><span class='p'>)</span> <span class='p'>{</span>
    <span class='k'>val</span> <span class='py'>i</span> <span class='p'>=</span> <span class='n'>ann</span><span class='p'>.</span><span class='n'>value</span>
<span class='p'>}</span></code></pre>
              </article>
          
              <article id="reflection.html" class="page-content">
                <h2 id='reflection.html_section'>리플렉션<a class='anchor' href='#%23section'> </a></h2><p>리플렉션은 런타임에 프로그램의 구조를 인트로스펙션(introspection)할 수 있는 언어와 라이브러리 기능 집합이다.
코틀린 언어에서 함수와 프로퍼티는 일급이고 그것을 인트로스펙션(예, 런타임에 함수나 프로퍼티 타입의 이름을 알아내는 것)하는 것은
단순히 함수형이나 리액티브 방식을 사용하는 것과 밀접하게 관련되어 있다.</p><blockquote class='note'>
  <p>자바 플랫폼에서, 리플렉션 기능을 사용하는데 필요한 런타임 컴포넌트를 별도 JAR 파일(<code>kotlin-reflect.jar</code>)로 배포하고 있다.
이는 리플릭센 기능을 사용하지 않는 어플리케이션이 필요로 하는 런타임 라이브러리의 크기를 줄요한다. 리플렉션을 사용하려면
이 jar 파일을 프로젝트 클래스패스에 넣어야 한다.</p>
</blockquote><h3 id='reflection.html_section-1'>클래스 레퍼런스<a class='anchor' href='#%23section-1'> </a></h3><p>가장 기본적인 리플렉션 기능은 코틀린 클래스에 대한 런타임 레퍼런스를 얻는 것이다. 정적으로 아는 코틀린 클래스의 레퍼런스를 구하러면
<em>클래스 리터럴</em> 구문을 사용하면 된다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>c</span> <span class='p'>=</span> <span class='n'>MyClass</span><span class='o'>::</span><span class='k'>class</span></code></pre><p>이 레퍼러스의 값은 <a href='#%2Fapi%2Flatest%2Fjvm%2Fstdlib%2Fkotlin.reflect%2F-k-class%2Findex.html'>KClass</a> 타입이다.</p><p>코틀린 클래스 레퍼런스는 자바 클래스 레퍼런스와 다르다. 자바 클래스 레퍼런스를 구하려면
<code>KClass</code> 인스턴스의 <code>.java</code> 프로퍼티를 사용해야 한다.</p><h3 id='reflection.html_section-2'>함수 레퍼런스<a class='anchor' href='#%23section-2'> </a></h3><p>다음과 같은 이름을 가진 함수 선언이 있다고 하자:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>isOdd</span><span class='p'>(</span><span class='n'>x</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>)</span> <span class='p'>=</span> <span class='n'>x</span> <span class='p'>%</span> <span class='m'>2</span> <span class='p'>!=</span> <span class='m'>0</span></code></pre><p>쉽게 함수를 직접 호출할 수 있다(<code>isOdd(5)</code>). 또한, 함수를 다른 함수에 값으로 전달할 수도 있다.
이를 하려면 <code>::</code> 연산자를 사용한다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>numbers</span> <span class='p'>=</span> <span class='n'>listOf</span><span class='p'>(</span><span class='m'>1</span><span class='p'>,</span> <span class='m'>2</span><span class='p'>,</span> <span class='m'>3</span><span class='p'>)</span>
<span class='n'>println</span><span class='p'>(</span><span class='n'>numbers</span><span class='p'>.</span><span class='n'>filter</span><span class='p'>(</span><span class='o'>::</span><span class='n'>isOdd</span><span class='p'>))</span> <span class='c1'>// [1, 3] 출력</span></code></pre><p>여기서 <code>::isOdd</code>는 함수 타입 <code>(Int) -&gt; Boolean</code>의 값이다.</p><p>오버로딩한 함수에 대해서는 <code>::</code> 연산자를 사용할 수 없다. 향후에 오버로딩한 함수 중에서 선택할 수 있도록 파라미터 타입을
지정하는 구문을 제공할 계획이다.</p><p>클래스의 멤버나 확장 함수를 사용해야 한다면 클래스 이름을 명시한다. 예를 들어,
<code>String::toCharArray</code>는 <code>String</code>을 위한 확장 함수인 <code>String.() -&gt; CharArray</code>를 제공한다.</p><h4 id='reflection.html_section-3'>예제: 함수 조합<a class='anchor' href='#%23section-3'> </a></h4><p>다음 함수를 보자:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='err'>&lt;</span><span class='nf'>A</span><span class='p'>,</span> <span class='n'>B</span><span class='p'>,</span> <span class='n'>C</span><span class='p'>&gt;</span> <span class='n'>compose</span><span class='p'>(</span><span class='n'>f</span><span class='p'>:</span> <span class='p'>(</span><span class='n'>B</span><span class='p'>)</span> <span class='p'>-&gt;</span> <span class='n'>C</span><span class='p'>,</span> <span class='n'>g</span><span class='p'>:</span> <span class='p'>(</span><span class='n'>A</span><span class='p'>)</span> <span class='p'>-&gt;</span> <span class='n'>B</span><span class='p'>):</span> <span class='p'>(</span><span class='n'>A</span><span class='p'>)</span> <span class='p'>-&gt;</span> <span class='n'>C</span> <span class='p'>{</span>
    <span class='k'>return</span> <span class='p'>{</span> <span class='n'>x</span> <span class='p'>-&gt;</span> <span class='n'>f</span><span class='p'>(</span><span class='n'>g</span><span class='p'>(</span><span class='n'>x</span><span class='p'>))</span> <span class='p'>}</span>
<span class='p'>}</span></code></pre><p>이는 전달한 두 함수를 조합해서 리턴한다(<code>compose(f, g) = f(g(*))</code>).
이제 이 함수에 호출할 수 있는 레퍼런스를 적용할 수 있다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>length</span><span class='p'>(</span><span class='n'>s</span><span class='p'>:</span> <span class='n'>String</span><span class='p'>)</span> <span class='p'>=</span> <span class='n'>s</span><span class='p'>.</span><span class='n'>size</span>

<span class='k'>val</span> <span class='py'>oddLength</span> <span class='p'>=</span> <span class='n'>compose</span><span class='p'>(</span><span class='o'>::</span><span class='n'>isOdd</span><span class='p'>,</span> <span class='o'>::</span><span class='n'>length</span><span class='p'>)</span>
<span class='k'>val</span> <span class='py'>strings</span> <span class='p'>=</span> <span class='n'>listOf</span><span class='p'>(</span><span class='s'>&quot;a&quot;</span><span class='p'>,</span> <span class='s'>&quot;ab&quot;</span><span class='p'>,</span> <span class='s'>&quot;abc&quot;</span><span class='p'>)</span>

<span class='n'>println</span><span class='p'>(</span><span class='n'>strings</span><span class='p'>.</span><span class='n'>filter</span><span class='p'>(</span><span class='n'>oddLength</span><span class='p'>))</span> <span class='c1'>// &quot;[a, abc]&quot; 출력</span></code></pre><h3 id='reflection.html_section-4'>프로퍼티 레퍼런스<a class='anchor' href='#%23section-4'> </a></h3><p>코틀린에서 일급 객체인 프로퍼티에 접근할 때에도 <code>::</code> 연산자를 사용한다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>var</span> <span class='py'>x</span> <span class='p'>=</span> <span class='m'>1</span>

<span class='k'>fun</span> <span class='nf'>main</span><span class='p'>(</span><span class='n'>args</span><span class='p'>:</span> <span class='n'>Array</span><span class='p'>&lt;</span><span class='n'>String</span><span class='p'>&gt;)</span> <span class='p'>{</span>
    <span class='n'>println</span><span class='p'>(</span><span class='o'>::</span><span class='n'>x</span><span class='p'>.</span><span class='k'>get</span><span class='p'>())</span> <span class='c1'>// &quot;1&quot; 출력</span>
    <span class='o'>::</span><span class='n'>x</span><span class='p'>.</span><span class='k'>set</span><span class='p'>(</span><span class='m'>2</span><span class='p'>)</span>
    <span class='n'>println</span><span class='p'>(</span><span class='n'>x</span><span class='p'>)</span>         <span class='c1'>// &quot;2&quot; 출력</span>
<span class='p'>}</span></code></pre><p><code>::x</code> 식은 <code>KProperty&lt;Int&gt;</code> 타입의 프로퍼티 객체를 구한다. 이 타입을 이용하면
<code>get()</code>을 사용해서 값을 읽거나 <code>name</code> 프로퍼티를 이용해서 프로퍼티 이름을 구할 수 있다.
더 자세한 정보는 <a href='#%2Fapi%2Flatest%2Fjvm%2Fstdlib%2Fkotlin.reflect%2F-k-property%2Findex.html'><code>KProperty</code> 클래스 문서</a>를 참고한다.</p><p><code>var y = 1</code>과 같은 수정 가능 프로퍼티의 경우 <code>::y</code>는 <a href='#%2Fapi%2Flatest%2Fjvm%2Fstdlib%2Fkotlin.reflect%2F-k-mutable-property%2Findex.html'><code>KMutableProperty&lt;Int&gt;</code></a> 타입 값을 리턴한다.
이 타입은 <code>set()</code> 메서드를 갖고 있다.</p><p>파라미터가 없는 함수가 필요한 곳에 프로퍼티 레퍼런스를 사용할 수 있다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>strs</span> <span class='p'>=</span> <span class='n'>listOf</span><span class='p'>(</span><span class='s'>&quot;a&quot;</span><span class='p'>,</span> <span class='s'>&quot;bc&quot;</span><span class='p'>,</span> <span class='s'>&quot;def&quot;</span><span class='p'>)</span>
<span class='n'>println</span><span class='p'>(</span><span class='n'>strs</span><span class='p'>.</span><span class='n'>map</span><span class='p'>(</span><span class='n'>String</span><span class='o'>::</span><span class='n'>length</span><span class='p'>))</span> <span class='c1'>// [1, 2, 3] 출력</span></code></pre><p>클래스의 멤버인 프로퍼티에 접근할 때에는 클래스를 한정한다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>class</span> <span class='nc'>A</span><span class='p'>(</span><span class='k'>val</span> <span class='py'>p</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>)</span>

<span class='k'>fun</span> <span class='nf'>main</span><span class='p'>(</span><span class='n'>args</span><span class='p'>:</span> <span class='n'>Array</span><span class='p'>&lt;</span><span class='n'>String</span><span class='p'>&gt;)</span> <span class='p'>{</span>
    <span class='k'>val</span> <span class='py'>prop</span> <span class='p'>=</span> <span class='n'>A</span><span class='o'>::</span><span class='n'>p</span>
    <span class='n'>println</span><span class='p'>(</span><span class='n'>prop</span><span class='p'>.</span><span class='k'>get</span><span class='p'>(</span><span class='n'>A</span><span class='p'>(</span><span class='m'>1</span><span class='p'>)))</span> <span class='c1'>// prints &quot;1&quot;</span>
<span class='p'>}</span></code></pre><p>확장 프로퍼티의 경우:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>String</span><span class='p'>.</span><span class='n'>lastChar</span><span class='p'>:</span> <span class='n'>Char</span>
  <span class='k'>get</span><span class='p'>()</span> <span class='p'>=</span> <span class='k'>this</span><span class='p'>[</span><span class='n'>size</span> <span class='p'>-</span> <span class='m'>1</span><span class='p'>]</span>

<span class='k'>fun</span> <span class='nf'>main</span><span class='p'>(</span><span class='n'>args</span><span class='p'>:</span> <span class='n'>Array</span><span class='p'>&lt;</span><span class='n'>String</span><span class='p'>&gt;)</span> <span class='p'>{</span>
  <span class='n'>println</span><span class='p'>(</span><span class='n'>String</span><span class='o'>::</span><span class='n'>lastChar</span><span class='p'>.</span><span class='k'>get</span><span class='p'>(</span><span class='s'>&quot;abc&quot;</span><span class='p'>))</span> <span class='c1'>// prints &quot;c&quot;</span>
<span class='p'>}</span></code></pre><h4 id='reflection.html_section-5'>자바 리플렉션과의 상호 운용성<a class='anchor' href='#%23section-5'> </a></h4><p>자바 플랫폼에서, 표준 라이브러리는 리플렉션 클래스를 위해 자바 리플렉션 객체와의 매핑을 제공하는 확장을 포함하고 있다(<code>kotlin.reflect.jvm</code> 패키지 참고).
예를 들어 backing 필드나 코틀린 프로퍼티의 getter를 위한 자바 메서드를 찾고 싶다면 다음과 같은 코드를 사용할 수 있다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>import</span> <span class='nn'>kotlin.reflect.jvm.*</span>

<span class='k'>class</span> <span class='nc'>A</span><span class='p'>(</span><span class='k'>val</span> <span class='py'>p</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>)</span>

<span class='k'>fun</span> <span class='nf'>main</span><span class='p'>(</span><span class='n'>args</span><span class='p'>:</span> <span class='n'>Array</span><span class='p'>&lt;</span><span class='n'>String</span><span class='p'>&gt;)</span> <span class='p'>{</span>
    <span class='n'>println</span><span class='p'>(</span><span class='n'>A</span><span class='o'>::</span><span class='n'>p</span><span class='p'>.</span><span class='n'>javaGetter</span><span class='p'>)</span> <span class='c1'>// &quot;public final int A.getP()&quot; 출력</span>
    <span class='n'>println</span><span class='p'>(</span><span class='n'>A</span><span class='o'>::</span><span class='n'>p</span><span class='p'>.</span><span class='n'>javaField</span><span class='p'>)</span>  <span class='c1'>// &quot;private final int A.p&quot; 출력</span>
<span class='p'>}</span></code></pre><p>자바 클래스에 해당하는 코틀린 클래스를 구하려면 확장 프로퍼티로 <code>.kotlin</code>을 사용한다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>getKClass</span><span class='p'>(</span><span class='n'>o</span><span class='p'>:</span> <span class='n'>Any</span><span class='p'>):</span> <span class='n'>KClass</span><span class='p'>&lt;</span><span class='n'>Any</span><span class='p'>&gt;</span> <span class='p'>=</span> <span class='n'>o</span><span class='p'>.</span><span class='n'>javaClass</span><span class='p'>.</span><span class='n'>kotlin</span></code></pre><h3 id='reflection.html_section-6'>생성자 레퍼런스<a class='anchor' href='#%23section-6'> </a></h3><p>메서드나 프로퍼티처럼 생성자 레퍼런스를 구할 수 있다. 생성자와 같은 파라미터를 갖고 관련 타입 객체를 리턴하는
함수 타입이 필요한 곳에 생성자 레퍼런스를 사용할 수 있다.
다음 함수는 <code>::</code> 연산자와 클래스 이름을 사용해서 생성자 레퍼런스를 구한다. 이 함수는 파라미터를 갖지 않고 리턴 타입이 <code>Foo</code>인 함수를 파라미터로 사용한다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>class</span> <span class='nc'>Foo</span>

<span class='k'>fun</span> <span class='nf'>function</span><span class='p'>(</span><span class='n'>factory</span> <span class='p'>:</span> <span class='p'>()</span> <span class='p'>-&gt;</span> <span class='n'>Foo</span><span class='p'>)</span> <span class='p'>{</span>
    <span class='k'>val</span> <span class='py'>x</span> <span class='p'>:</span> <span class='n'>Foo</span> <span class='p'>=</span> <span class='n'>factory</span><span class='p'>()</span>
<span class='p'>}</span></code></pre><p><code>::Foo</code>를 사용하면, 즉 Foo 클래스의 인자 없는 생성자 레퍼런스로, 다음처럼 간단히 생성자를 호출할 수 있다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>function</span><span class='p'>(</span><span class='o'>::</span><span class='n'>Foo</span><span class='p'>)</span></code></pre>
              </article>
          
              <article id="type-safe-builders.html" class="page-content">
                <h2 id='type-safe-builders.html_section'>타입-안전 빌더<a class='anchor' href='#%23section'> </a></h2><p><a href='#http%3A%2F%2Fwww.groovy-lang.org%2Fdsls.html%23_nodebuilder'>빌더</a> 개념은 <em>그루비</em> 커뮤니티에서 더 유명하다.
빌더는 반쯤 선언적인 방법으로 데이터를 정의할 수 있도록 해 준다. 빌더의 좋은 예로
<a href='#http%3A%2F%2Fwww.groovy-lang.org%2Fprocessing-xml.html%23_creating_xml'>XML 생성</a>,
<a href='#http%3A%2F%2Fwww.groovy-lang.org%2Fswing.html'>컴포넌트 배치</a>,
<a href='#http%3A%2F%2Fwww.artima.com%2Fweblogs%2Fviewpost.jsp%3Fthread%3D296081'>3D 장면 묘사</a> 등이 있다.</p><p>많은 유스케이스를 위해 코틀린은 <em>타입-검사(type-check)</em> 빌더를 제공한다. 이 빌더는 예로 든 것을 그루비 자체에서 만든 동적-타입 구현보다 더 매력적으로 만들어준다.</p><p>나머지 경우를 위해 코틀린은 동적 타입 빌더를 지원한다.</p><h3 id='type-safe-builders.html_section-1'>타입-안전 빌더 예제<a class='anchor' href='#%23section-1'> </a></h3><p>다음 코드를 보자:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>import</span> <span class='nn'>com.example.html.*</span> <span class='c1'>// 아래 선언 참고</span>

<span class='k'>fun</span> <span class='nf'>result</span><span class='p'>(</span><span class='n'>args</span><span class='p'>:</span> <span class='n'>Array</span><span class='p'>&lt;</span><span class='n'>String</span><span class='p'>&gt;)</span> <span class='p'>=</span>
  <span class='n'>html</span> <span class='p'>{</span>
    <span class='n'>head</span> <span class='p'>{</span>
      <span class='n'>title</span> <span class='p'>{+</span><span class='s'>&quot;XML encoding with Kotlin&quot;</span><span class='p'>}</span>
    <span class='p'>}</span>
    <span class='n'>body</span> <span class='p'>{</span>
      <span class='n'>h1</span> <span class='p'>{+</span><span class='s'>&quot;XML encoding with Kotlin&quot;</span><span class='p'>}</span>
      <span class='n'>p</span>  <span class='p'>{+</span><span class='s'>&quot;this format can be used as an alternative markup to XML&quot;</span><span class='p'>}</span>

      <span class='c1'>// 애트리뷰트와 텍스트 컨텐트를 가진 엘리먼트</span>
      <span class='n'>a</span><span class='p'>(</span><span class='n'>href</span> <span class='p'>=</span> <span class='s'>&quot;http://kotlinlang.org&quot;</span><span class='p'>)</span> <span class='p'>{+</span><span class='s'>&quot;Kotlin&quot;</span><span class='p'>}</span>

      <span class='c1'>// 혼합 컨텍트</span>
      <span class='n'>p</span> <span class='p'>{</span>
        <span class='p'>+</span><span class='s'>&quot;This is some&quot;</span>
        <span class='n'>b</span> <span class='p'>{+</span><span class='s'>&quot;mixed&quot;</span><span class='p'>}</span>
        <span class='p'>+</span><span class='s'>&quot;text. For more see the&quot;</span>
        <span class='n'>a</span><span class='p'>(</span><span class='n'>href</span> <span class='p'>=</span> <span class='s'>&quot;http://kotlinlang.org&quot;</span><span class='p'>)</span> <span class='p'>{+</span><span class='s'>&quot;Kotlin&quot;</span><span class='p'>}</span>
        <span class='p'>+</span><span class='s'>&quot;project&quot;</span>
      <span class='p'>}</span>
      <span class='n'>p</span> <span class='p'>{+</span><span class='s'>&quot;some text&quot;</span><span class='p'>}</span>

      <span class='c1'>// 생성된 컨텍트</span>
      <span class='n'>p</span> <span class='p'>{</span>
        <span class='k'>for</span> <span class='p'>(</span><span class='n'>arg</span> <span class='k'>in</span> <span class='n'>args</span><span class='p'>)</span>
          <span class='p'>+</span><span class='n'>arg</span>
      <span class='p'>}</span>
    <span class='p'>}</span>
  <span class='p'>}</span></code></pre><p>이 코드는 완전히 올바른 코틀린 코드이다.
이 코드를 브라우저에서 수정하고 실행해 볼 수 있다<a href='#http%3A%2F%2Ftry.kotlinlang.org%2F%23%2FExamples%2FLonger+examples%2FHTML+Builder%2FHTML+Builder.kt'>(여기)</a>.</p><h3 id='type-safe-builders.html_section-2'>동작 방식<a class='anchor' href='#%23section-2'> </a></h3><p>코틀린에서 타입-안전 빌더를 구현하는 기법을 차례대로 살펴보자.
먼저 만들고 싶은 모델을 정의해야 한다. 이 예제의 경우 HTML 태그의 모델을 정의할 필요가 있다.
몇 개 클래스로 쉽게 이 모델을 만들 수 있다.
예를 들어, <code>HTML</code> 클래스는 <code>&lt;html&gt;</code> 태그를 표현하며, <code>&lt;head&gt;</code>와 <code>&lt;body&gt;</code>를 자식으로 정의한다.
(<a href='#%23declarations'>아래</a> 이 클래스의 선언을 참고한다.)</p><p>이제 왜 다음과 같은 코드를 작성할 수 있는지 보자:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>html</span> <span class='p'>{</span>
 <span class='c1'>// ...</span>
<span class='p'>}</span></code></pre><p><code>html</code>은 실제로 <a href='#lambdas.html'>람다 식</a>을 인자로 받는 함수 호출이다.
이 함수는 다음과 같이 정의되어 있다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>html</span><span class='p'>(</span><span class='n'>init</span><span class='p'>:</span> <span class='n'>HTML</span><span class='p'>.()</span> <span class='p'>-&gt;</span> <span class='n'>Unit</span><span class='p'>):</span> <span class='n'>HTML</span> <span class='p'>{</span>
  <span class='k'>val</span> <span class='py'>html</span> <span class='p'>=</span> <span class='n'>HTML</span><span class='p'>()</span>
  <span class='n'>html</span><span class='p'>.</span><span class='n'>init</span><span class='p'>()</span>
  <span class='k'>return</span> <span class='n'>html</span>
<span class='p'>}</span></code></pre><p>이 함수는 이름이 <code>init</code>인 파라미터를 갖는다. 이 파라미터 자체도 함수이다.
<code>init</code> 함수 타입은 _리시버를 갖는 함수 타입_인 <code>HTML.() -&gt; Unit</code>이다.
이는 함수에 <code>HTML</code> 타입의 인스턴스(리시버)를 전달해야 하고 함수 안에서 그 인스턴스의 멤버를 호출할 수 있음을 의미한다.
<em class='keyword'>this</em> 키워드로 리시버에 접근할 수 있다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>html</span> <span class='p'>{</span>
  <span class='k'>this</span><span class='p'>.</span><span class='n'>head</span> <span class='p'>{</span> <span class='cm'>/* ... */</span> <span class='p'>}</span>
  <span class='k'>this</span><span class='p'>.</span><span class='n'>body</span> <span class='p'>{</span> <span class='cm'>/* ... */</span> <span class='p'>}</span>
<span class='p'>}</span></code></pre><p>(<code>head</code>와 <code>body</code>는 <code>html</code>의 멤버 함수이다.)</p><p>여기서 보통 <em class='keyword'>this</em>를 생략할 수 있다. 이 코드는 이미 빌더와 같은 모양이다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>html</span> <span class='p'>{</span>
  <span class='n'>head</span> <span class='p'>{</span> <span class='cm'>/* ... */</span> <span class='p'>}</span>
  <span class='n'>body</span> <span class='p'>{</span> <span class='cm'>/* ... */</span> <span class='p'>}</span>
<span class='p'>}</span></code></pre><p>그러면 이 함수 호출은 무엇을 할까? 위에 정의한 <code>html</code> 함수의 몸체를 보자.
이 함수는 새로운 <code>HTML</code> 인스턴스를 생성하고, 인자로 전달받은 함수를 호출해서 생성한 인스턴스를 초기화하고(이 예제에서는
<code>HTML</code> 인스턴스의 <code>head</code>와 <code>body</code>를 호출한다),
그 인스턴스를 리턴한다.
이것이 정확하게 빌더가 해야 하는 것이다.</p><p><code>HTML</code> 클래스의 <code>head</code>와 <code>body</code> 함수는 <code>html</code>과 비슷하게 정의한다.
유일한 차이점은 둘러싼 <code>HTML</code> 인스턴스의 <code>childrel</code> 콜렉션에 생성한 인스턴스를 추가하는 것이다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>head</span><span class='p'>(</span><span class='n'>init</span><span class='p'>:</span> <span class='n'>Head</span><span class='p'>.()</span> <span class='p'>-&gt;</span> <span class='n'>Unit</span><span class='p'>)</span> <span class='p'>:</span> <span class='n'>Head</span> <span class='p'>{</span>
  <span class='k'>val</span> <span class='py'>head</span> <span class='p'>=</span> <span class='n'>Head</span><span class='p'>()</span>
  <span class='n'>head</span><span class='p'>.</span><span class='n'>init</span><span class='p'>()</span>
  <span class='n'>children</span><span class='p'>.</span><span class='n'>add</span><span class='p'>(</span><span class='n'>head</span><span class='p'>)</span>
  <span class='k'>return</span> <span class='n'>head</span>
<span class='p'>}</span>

<span class='k'>fun</span> <span class='nf'>body</span><span class='p'>(</span><span class='n'>init</span><span class='p'>:</span> <span class='n'>Body</span><span class='p'>.()</span> <span class='p'>-&gt;</span> <span class='n'>Unit</span><span class='p'>)</span> <span class='p'>:</span> <span class='n'>Body</span> <span class='p'>{</span>
  <span class='k'>val</span> <span class='py'>body</span> <span class='p'>=</span> <span class='n'>Body</span><span class='p'>()</span>
  <span class='n'>body</span><span class='p'>.</span><span class='n'>init</span><span class='p'>()</span>
  <span class='n'>children</span><span class='p'>.</span><span class='n'>add</span><span class='p'>(</span><span class='n'>body</span><span class='p'>)</span>
  <span class='k'>return</span> <span class='n'>body</span>
<span class='p'>}</span></code></pre><p>실제 이 두 함수는 같은 것을 하므로 지네릭 버전인 <code>initTag</code>를 만들 수 있다:</p><pre><code class='code-block _highlighted lang_kotlin'>  <span class='k'>protected</span> <span class='k'>fun</span> <span class='err'>&lt;</span><span class='nf'>T</span> <span class='p'>:</span> <span class='n'>Element</span><span class='p'>&gt;</span> <span class='n'>initTag</span><span class='p'>(</span><span class='n'>tag</span><span class='p'>:</span> <span class='n'>T</span><span class='p'>,</span> <span class='n'>init</span><span class='p'>:</span> <span class='n'>T</span><span class='p'>.()</span> <span class='p'>-&gt;</span> <span class='n'>Unit</span><span class='p'>):</span> <span class='n'>T</span> <span class='p'>{</span>
    <span class='n'>tag</span><span class='p'>.</span><span class='n'>init</span><span class='p'>()</span>
    <span class='n'>children</span><span class='p'>.</span><span class='n'>add</span><span class='p'>(</span><span class='n'>tag</span><span class='p'>)</span>
    <span class='k'>return</span> <span class='n'>tag</span>
  <span class='p'>}</span></code></pre><p>이제 두 함수가 매우 간단해진다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>head</span><span class='p'>(</span><span class='n'>init</span><span class='p'>:</span> <span class='n'>Head</span><span class='p'>.()</span> <span class='p'>-&gt;</span> <span class='n'>Unit</span><span class='p'>)</span> <span class='p'>=</span> <span class='n'>initTag</span><span class='p'>(</span><span class='n'>Head</span><span class='p'>(),</span> <span class='n'>init</span><span class='p'>)</span>

<span class='k'>fun</span> <span class='nf'>body</span><span class='p'>(</span><span class='n'>init</span><span class='p'>:</span> <span class='n'>Body</span><span class='p'>.()</span> <span class='p'>-&gt;</span> <span class='n'>Unit</span><span class='p'>)</span> <span class='p'>=</span> <span class='n'>initTag</span><span class='p'>(</span><span class='n'>Body</span><span class='p'>(),</span> <span class='n'>init</span><span class='p'>)</span></code></pre><p><code>&lt;head&gt;</code>와 <code>&lt;body&gt;</code> 태그를 생성할 때 두 함수를 사용할 수 있다.</p><p>여기서 논의하는 것 중 다른 하나는 태그 몸체에 텍스트를 추가하는 것이다. 앞서 예제에서 다음과 같이 추가했다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>html</span> <span class='p'>{</span>
  <span class='n'>head</span> <span class='p'>{</span>
    <span class='n'>title</span> <span class='p'>{+</span><span class='s'>&quot;XML encoding with Kotlin&quot;</span><span class='p'>}</span>
  <span class='p'>}</span>
  <span class='c1'>// ...</span>
<span class='p'>}</span></code></pre><p>기본적으로 단순히 태그 몸체에 문자열을 넣는데, 그 앞에 <code>+</code>가 있다.
따라서 이는 접두 <code>unaryPlus()</code> 오프레이션을 실행하는 함수 호출이다.
실제로 이 오퍼레이션을 <code>TagWithText</code> 추상 클래스(<code>Title</code>의 부모)의 멤버인 <code>unaryPlus()</code> 확장 함수로 정의했다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>String</span><span class='p'>.</span><span class='n'>unaryPlus</span><span class='p'>()</span> <span class='p'>{</span>
  <span class='n'>children</span><span class='p'>.</span><span class='n'>add</span><span class='p'>(</span><span class='n'>TextElement</span><span class='p'>(</span><span class='k'>this</span><span class='p'>))</span>
<span class='p'>}</span></code></pre><p>따라서, 여기서 접두문자 <code>+</code>는 문자열을 <code>TextElement</code>의 인스턴스로 감싸고 그 인스턴스를 <code>children</code> 콜렉션에 추가해서,
그것이 태그 트리에 알맞은 부분이 되도록 한다.</p><p>이 모든 것이 <code>com.example.html</code> 패키지에 정의되어 있는데 위 벌더 예제는 처음에 이 패키지를 임포트한다.
다음 절에서 이 패키지의 전체 정의를 읽을 수 있다.</p><h3 id='type-safe-builders.html_comexamplehtml---'><code>com.example.html</code> 패키지의 전체 정의<a class='anchor' href='#%23comexamplehtml---'> </a></h3><p>다음 코드는 <code>com.example.html</code> 패키지의 코드이다(위 예제에서 사용하는 요소만 포함).
이는 HTML 트리를 만든다. <a href='#extensions.html'>확장 함수</a>와
<a href='#lambdas.html%23function-literals-with-receiver'>리시버를 가진 람다</a>를 많이 쓰고 있다.</p><p><a name='declarations'> </a></p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>package</span> <span class='nn'>com.example.html</span>

<span class='n'>interface</span> <span class='n'>Element</span> <span class='p'>{</span>
    <span class='k'>fun</span> <span class='nf'>render</span><span class='p'>(</span><span class='n'>builder</span><span class='p'>:</span> <span class='n'>StringBuilder</span><span class='p'>,</span> <span class='n'>indent</span><span class='p'>:</span> <span class='n'>String</span><span class='p'>)</span>
<span class='p'>}</span>

<span class='k'>class</span> <span class='nc'>TextElement</span><span class='p'>(</span><span class='k'>val</span> <span class='py'>text</span><span class='p'>:</span> <span class='n'>String</span><span class='p'>)</span> <span class='p'>:</span> <span class='n'>Element</span> <span class='p'>{</span>
    <span class='k'>override</span> <span class='k'>fun</span> <span class='nf'>render</span><span class='p'>(</span><span class='n'>builder</span><span class='p'>:</span> <span class='n'>StringBuilder</span><span class='p'>,</span> <span class='n'>indent</span><span class='p'>:</span> <span class='n'>String</span><span class='p'>)</span> <span class='p'>{</span>
        <span class='n'>builder</span><span class='p'>.</span><span class='n'>append</span><span class='p'>(</span><span class='s'>&quot;$indent$text\n&quot;</span><span class='p'>)</span>
    <span class='p'>}</span>
<span class='p'>}</span>

<span class='k'>abstract</span> <span class='k'>class</span> <span class='nc'>Tag</span><span class='p'>(</span><span class='k'>val</span> <span class='py'>name</span><span class='p'>:</span> <span class='n'>String</span><span class='p'>)</span> <span class='p'>:</span> <span class='n'>Element</span> <span class='p'>{</span>
    <span class='k'>val</span> <span class='py'>children</span> <span class='p'>=</span> <span class='n'>arrayListOf</span><span class='p'>&lt;</span><span class='n'>Element</span><span class='p'>&gt;()</span>
    <span class='k'>val</span> <span class='py'>attributes</span> <span class='p'>=</span> <span class='n'>hashMapOf</span><span class='p'>&lt;</span><span class='n'>String</span><span class='p'>,</span> <span class='n'>String</span><span class='p'>&gt;()</span>

    <span class='k'>protected</span> <span class='k'>fun</span> <span class='err'>&lt;</span><span class='nf'>T</span> <span class='p'>:</span> <span class='n'>Element</span><span class='p'>&gt;</span> <span class='n'>initTag</span><span class='p'>(</span><span class='n'>tag</span><span class='p'>:</span> <span class='n'>T</span><span class='p'>,</span> <span class='n'>init</span><span class='p'>:</span> <span class='n'>T</span><span class='p'>.()</span> <span class='p'>-&gt;</span> <span class='n'>Unit</span><span class='p'>):</span> <span class='n'>T</span> <span class='p'>{</span>
        <span class='n'>tag</span><span class='p'>.</span><span class='n'>init</span><span class='p'>()</span>
        <span class='n'>children</span><span class='p'>.</span><span class='n'>add</span><span class='p'>(</span><span class='n'>tag</span><span class='p'>)</span>
        <span class='k'>return</span> <span class='n'>tag</span>
    <span class='p'>}</span>

    <span class='k'>override</span> <span class='k'>fun</span> <span class='nf'>render</span><span class='p'>(</span><span class='n'>builder</span><span class='p'>:</span> <span class='n'>StringBuilder</span><span class='p'>,</span> <span class='n'>indent</span><span class='p'>:</span> <span class='n'>String</span><span class='p'>)</span> <span class='p'>{</span>
        <span class='n'>builder</span><span class='p'>.</span><span class='n'>append</span><span class='p'>(</span><span class='s'>&quot;$indent&lt;$name${renderAttributes()}&gt;\n&quot;</span><span class='p'>)</span>
        <span class='k'>for</span> <span class='p'>(</span><span class='n'>c</span> <span class='k'>in</span> <span class='n'>children</span><span class='p'>)</span> <span class='p'>{</span>
            <span class='n'>c</span><span class='p'>.</span><span class='n'>render</span><span class='p'>(</span><span class='n'>builder</span><span class='p'>,</span> <span class='n'>indent</span> <span class='p'>+</span> <span class='s'>&quot;  &quot;</span><span class='p'>)</span>
        <span class='p'>}</span>
        <span class='n'>builder</span><span class='p'>.</span><span class='n'>append</span><span class='p'>(</span><span class='s'>&quot;$indent&lt;/$name&gt;\n&quot;</span><span class='p'>)</span>
    <span class='p'>}</span>

    <span class='k'>private</span> <span class='k'>fun</span> <span class='nf'>renderAttributes</span><span class='p'>():</span> <span class='n'>String</span><span class='p'>?</span> <span class='p'>{</span>
        <span class='k'>val</span> <span class='py'>builder</span> <span class='p'>=</span> <span class='n'>StringBuilder</span><span class='p'>()</span>
        <span class='k'>for</span> <span class='p'>(</span><span class='n'>a</span> <span class='k'>in</span> <span class='n'>attributes</span><span class='p'>.</span><span class='n'>keys</span><span class='p'>)</span> <span class='p'>{</span>
            <span class='n'>builder</span><span class='p'>.</span><span class='n'>append</span><span class='p'>(</span><span class='s'>&quot; $a=\&quot;${attributes[a]}\&quot;&quot;</span><span class='p'>)</span>
        <span class='p'>}</span>
        <span class='k'>return</span> <span class='n'>builder</span><span class='p'>.</span><span class='n'>toString</span><span class='p'>()</span>
    <span class='p'>}</span>


    <span class='k'>override</span> <span class='k'>fun</span> <span class='nf'>toString</span><span class='p'>():</span> <span class='n'>String</span> <span class='p'>{</span>
        <span class='k'>val</span> <span class='py'>builder</span> <span class='p'>=</span> <span class='n'>StringBuilder</span><span class='p'>()</span>
        <span class='n'>render</span><span class='p'>(</span><span class='n'>builder</span><span class='p'>,</span> <span class='s'>&quot;&quot;</span><span class='p'>)</span>
        <span class='k'>return</span> <span class='n'>builder</span><span class='p'>.</span><span class='n'>toString</span><span class='p'>()</span>
    <span class='p'>}</span>
<span class='p'>}</span>

<span class='k'>abstract</span> <span class='k'>class</span> <span class='nc'>TagWithText</span><span class='p'>(</span><span class='n'>name</span><span class='p'>:</span> <span class='n'>String</span><span class='p'>)</span> <span class='p'>:</span> <span class='n'>Tag</span><span class='p'>(</span><span class='n'>name</span><span class='p'>)</span> <span class='p'>{</span>
    <span class='n'>operator</span> <span class='k'>fun</span> <span class='nf'>String</span><span class='p'>.</span><span class='n'>unaryPlus</span><span class='p'>()</span> <span class='p'>{</span>
        <span class='n'>children</span><span class='p'>.</span><span class='n'>add</span><span class='p'>(</span><span class='n'>TextElement</span><span class='p'>(</span><span class='k'>this</span><span class='p'>))</span>
    <span class='p'>}</span>
<span class='p'>}</span>

<span class='k'>class</span> <span class='nc'>HTML</span><span class='p'>()</span> <span class='p'>:</span> <span class='n'>TagWithText</span><span class='p'>(</span><span class='s'>&quot;html&quot;</span><span class='p'>)</span> <span class='p'>{</span>
    <span class='k'>fun</span> <span class='nf'>head</span><span class='p'>(</span><span class='n'>init</span><span class='p'>:</span> <span class='n'>Head</span><span class='p'>.()</span> <span class='p'>-&gt;</span> <span class='n'>Unit</span><span class='p'>)</span> <span class='p'>=</span> <span class='n'>initTag</span><span class='p'>(</span><span class='n'>Head</span><span class='p'>(),</span> <span class='n'>init</span><span class='p'>)</span>

    <span class='k'>fun</span> <span class='nf'>body</span><span class='p'>(</span><span class='n'>init</span><span class='p'>:</span> <span class='n'>Body</span><span class='p'>.()</span> <span class='p'>-&gt;</span> <span class='n'>Unit</span><span class='p'>)</span> <span class='p'>=</span> <span class='n'>initTag</span><span class='p'>(</span><span class='n'>Body</span><span class='p'>(),</span> <span class='n'>init</span><span class='p'>)</span>
<span class='p'>}</span>

<span class='k'>class</span> <span class='nc'>Head</span><span class='p'>()</span> <span class='p'>:</span> <span class='n'>TagWithText</span><span class='p'>(</span><span class='s'>&quot;head&quot;</span><span class='p'>)</span> <span class='p'>{</span>
    <span class='k'>fun</span> <span class='nf'>title</span><span class='p'>(</span><span class='n'>init</span><span class='p'>:</span> <span class='n'>Title</span><span class='p'>.()</span> <span class='p'>-&gt;</span> <span class='n'>Unit</span><span class='p'>)</span> <span class='p'>=</span> <span class='n'>initTag</span><span class='p'>(</span><span class='n'>Title</span><span class='p'>(),</span> <span class='n'>init</span><span class='p'>)</span>
<span class='p'>}</span>

<span class='k'>class</span> <span class='nc'>Title</span><span class='p'>()</span> <span class='p'>:</span> <span class='n'>TagWithText</span><span class='p'>(</span><span class='s'>&quot;title&quot;</span><span class='p'>)</span>

<span class='k'>abstract</span> <span class='k'>class</span> <span class='nc'>BodyTag</span><span class='p'>(</span><span class='n'>name</span><span class='p'>:</span> <span class='n'>String</span><span class='p'>)</span> <span class='p'>:</span> <span class='n'>TagWithText</span><span class='p'>(</span><span class='n'>name</span><span class='p'>)</span> <span class='p'>{</span>
    <span class='k'>fun</span> <span class='nf'>b</span><span class='p'>(</span><span class='n'>init</span><span class='p'>:</span> <span class='n'>B</span><span class='p'>.()</span> <span class='p'>-&gt;</span> <span class='n'>Unit</span><span class='p'>)</span> <span class='p'>=</span> <span class='n'>initTag</span><span class='p'>(</span><span class='n'>B</span><span class='p'>(),</span> <span class='n'>init</span><span class='p'>)</span>
    <span class='k'>fun</span> <span class='nf'>p</span><span class='p'>(</span><span class='n'>init</span><span class='p'>:</span> <span class='n'>P</span><span class='p'>.()</span> <span class='p'>-&gt;</span> <span class='n'>Unit</span><span class='p'>)</span> <span class='p'>=</span> <span class='n'>initTag</span><span class='p'>(</span><span class='n'>P</span><span class='p'>(),</span> <span class='n'>init</span><span class='p'>)</span>
    <span class='k'>fun</span> <span class='nf'>h1</span><span class='p'>(</span><span class='n'>init</span><span class='p'>:</span> <span class='n'>H1</span><span class='p'>.()</span> <span class='p'>-&gt;</span> <span class='n'>Unit</span><span class='p'>)</span> <span class='p'>=</span> <span class='n'>initTag</span><span class='p'>(</span><span class='n'>H1</span><span class='p'>(),</span> <span class='n'>init</span><span class='p'>)</span>
    <span class='k'>fun</span> <span class='nf'>a</span><span class='p'>(</span><span class='n'>href</span><span class='p'>:</span> <span class='n'>String</span><span class='p'>,</span> <span class='n'>init</span><span class='p'>:</span> <span class='n'>A</span><span class='p'>.()</span> <span class='p'>-&gt;</span> <span class='n'>Unit</span><span class='p'>)</span> <span class='p'>{</span>
        <span class='k'>val</span> <span class='py'>a</span> <span class='p'>=</span> <span class='n'>initTag</span><span class='p'>(</span><span class='n'>A</span><span class='p'>(),</span> <span class='n'>init</span><span class='p'>)</span>
        <span class='n'>a</span><span class='p'>.</span><span class='n'>href</span> <span class='p'>=</span> <span class='n'>href</span>
    <span class='p'>}</span>
<span class='p'>}</span>

<span class='k'>class</span> <span class='nc'>Body</span><span class='p'>()</span> <span class='p'>:</span> <span class='n'>BodyTag</span><span class='p'>(</span><span class='s'>&quot;body&quot;</span><span class='p'>)</span>
<span class='k'>class</span> <span class='nc'>B</span><span class='p'>()</span> <span class='p'>:</span> <span class='n'>BodyTag</span><span class='p'>(</span><span class='s'>&quot;b&quot;</span><span class='p'>)</span>
<span class='k'>class</span> <span class='nc'>P</span><span class='p'>()</span> <span class='p'>:</span> <span class='n'>BodyTag</span><span class='p'>(</span><span class='s'>&quot;p&quot;</span><span class='p'>)</span>
<span class='k'>class</span> <span class='nc'>H1</span><span class='p'>()</span> <span class='p'>:</span> <span class='n'>BodyTag</span><span class='p'>(</span><span class='s'>&quot;h1&quot;</span><span class='p'>)</span>

<span class='k'>class</span> <span class='nc'>A</span><span class='p'>()</span> <span class='p'>:</span> <span class='n'>BodyTag</span><span class='p'>(</span><span class='s'>&quot;a&quot;</span><span class='p'>)</span> <span class='p'>{</span>
    <span class='k'>public</span> <span class='k'>var</span> <span class='py'>href</span><span class='p'>:</span> <span class='n'>String</span>
        <span class='k'>get</span><span class='p'>()</span> <span class='p'>=</span> <span class='n'>attributes</span><span class='p'>[</span><span class='s'>&quot;href&quot;</span><span class='p'>]</span><span class='o'>!!</span>
        <span class='k'>set</span><span class='p'>(</span><span class='n'>value</span><span class='p'>)</span> <span class='p'>{</span>
            <span class='n'>attributes</span><span class='p'>[</span><span class='s'>&quot;href&quot;</span><span class='p'>]</span> <span class='p'>=</span> <span class='n'>value</span>
        <span class='p'>}</span>
<span class='p'>}</span>

<span class='k'>fun</span> <span class='nf'>html</span><span class='p'>(</span><span class='n'>init</span><span class='p'>:</span> <span class='n'>HTML</span><span class='p'>.()</span> <span class='p'>-&gt;</span> <span class='n'>Unit</span><span class='p'>):</span> <span class='n'>HTML</span> <span class='p'>{</span>
    <span class='k'>val</span> <span class='py'>html</span> <span class='p'>=</span> <span class='n'>HTML</span><span class='p'>()</span>
    <span class='n'>html</span><span class='p'>.</span><span class='n'>init</span><span class='p'>()</span>
    <span class='k'>return</span> <span class='n'>html</span>
<span class='p'>}</span></code></pre>
              </article>
          
              <article id="dynamic-type.html" class="page-content">
                <h2 id='dynamic-type.html_section'>동적 타입<a class='anchor' href='#%23section'> </a></h2><blockquote class='note'>
  <p>동적 타입은 JVM 대상 코드에서 지원하지 않는다</p>
</blockquote><p>정적 타입 언어이지만, 코틀린은 자바스크립트 에코시스템과 같이 untyped거나 타입이 유연한 환경에서도 돌아야 한다.
이런 환경을 쉽게 처리하기 위해 언어에서 <code>동적</code> 타입을 사용할 수 있다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>dyn</span><span class='p'>:</span> <span class='n'>dynamic</span> <span class='p'>=</span> <span class='p'>...</span></code></pre><p><code>dynamic</code> 타입은 기본적으로 코틀린의 타입 검사를 하지 않는다:
  - 이 타입의 값은 모든 변수에 할당하거나 파라미터로 어디든 전달할 수 있다,
  - <code>dynamic</code> 타입 변수에 모든 값을 할당할 수 있고, 함수의 <code>dynamic</code> 파라미터에 모든 값을 전달할 수 있다.
  - 이 값에는 <code>null</code>-검사를 할 수 없다</p><p><code>dynamic</code>의 가장 특별한 기능은 <code>dynamic</code> 변수에 대해 파라미터를 갖는 함수나 <strong>모든</strong> 프로퍼티를 호출할 수 있다는 것이다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>dyn</span><span class='p'>.</span><span class='n'>whatever</span><span class='p'>(</span><span class='m'>1</span><span class='p'>,</span> <span class='s'>&quot;foo&quot;</span><span class='p'>,</span> <span class='n'>dyn</span><span class='p'>)</span> <span class='c1'>// 어디에도 &#39;whatever&#39;가 정의되어 있지 않음</span>
<span class='n'>dyn</span><span class='p'>.</span><span class='n'>whatever</span><span class='p'>(*</span><span class='n'>arrayOf</span><span class='p'>(</span><span class='m'>1</span><span class='p'>,</span> <span class='m'>2</span><span class='p'>,</span> <span class='m'>3</span><span class='p'>))</span></code></pre><p>자바스크립트 플랫폼에서, 이 코드는 있는 그대로 컴파일된다. 즉, 코틀린의 <code>dyn.whatever(1)</code> 코드가 생성한 자바스크립트 코드에서도 <code>dyn.whatever(1)</code>가 된다.</p><p>동적 호출은 항상 결과로 <code>dynamic</code>을 리턴하므로 자유롭게 호출을 연결할 수 있다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>dyn</span><span class='p'>.</span><span class='n'>foo</span><span class='p'>().</span><span class='n'>bar</span><span class='p'>.</span><span class='n'>baz</span><span class='p'>()</span></code></pre><p>동적 호출에 람다를 전달하면 기본적으로 모든 파라미터는 <code>dynamic</code> 타입을 갖는다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>dyn</span><span class='p'>.</span><span class='n'>foo</span> <span class='p'>{</span>
  <span class='n'>x</span> <span class='p'>-&gt;</span> <span class='n'>x</span><span class='p'>.</span><span class='n'>bar</span><span class='p'>()</span> <span class='c1'>// x가 dynamic</span>
<span class='p'>}</span></code></pre><p>기술적인 내용은 <a href='#https%3A%2F%2Fgithub.com%2FJetBrains%2Fkotlin%2Fblob%2Fmaster%2Fspec-docs%2Fdynamic-types.md'>스펙 문서</a>를 참고한다.</p>
              </article>
          

        </section>
    

    
        <section>
          <h1 id="Reference"
              class="section-title">
            Reference
          </h1>

          
              <article id="grammar.html" class="page-content">
                <div class='page-title'>문법</div><p>문법 정의를 그 형식에 맞게 개정하는 중이다. 그 때까지, <a href='#http%3A%2F%2Fconfluence.jetbrains.com%2Fdisplay%2FKotlin%2FGrammar'>이전 사이트의 문법</a> 문서를 참고한다.</p>
              </article>
          

        </section>
    

    
        <section>
          <h1 id="%EC%83%81%ED%98%B8_%EC%9A%B4%EC%9A%A9"
              class="section-title">
            상호 운용
          </h1>

          
              <article id="java-interop.html" class="page-content">
                <h2 id='java-interop.html_section'>코틀린에서 자바 코드 호출하기<a class='anchor' href='#%23section'> </a></h2><p>코틀린은 자바와의 상호운용성을 염두에 두고 설계했다. 특별한 노력없이 코틀린에서 기존의 자바 코드를 호출할 수 있고, 또한 자바에서도
비교적 매끄럽게 코틀린 코드를 사용할 수 있다. 이 절에서는 코틀린에서 자바 코드를 호출하는 것에 대한 내용을 자세히 설명한다.</p><p>거의 모든 자바 코드를 별 문제 없이 사용할 수 있다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>import</span> <span class='nn'>java.util.*</span>

<span class='k'>fun</span> <span class='nf'>demo</span><span class='p'>(</span><span class='n'>source</span><span class='p'>:</span> <span class='n'>List</span><span class='p'>&lt;</span><span class='n'>Int</span><span class='p'>&gt;)</span> <span class='p'>{</span>
  <span class='k'>val</span> <span class='py'>list</span> <span class='p'>=</span> <span class='n'>ArrayList</span><span class='p'>&lt;</span><span class='n'>Int</span><span class='p'>&gt;()</span>
  <span class='c1'>// 자바 콜렉션을 &#39;for&#39;-루프에서 사용:</span>
  <span class='k'>for</span> <span class='p'>(</span><span class='n'>item</span> <span class='k'>in</span> <span class='n'>source</span><span class='p'>)</span>
    <span class='n'>list</span><span class='p'>.</span><span class='n'>add</span><span class='p'>(</span><span class='n'>item</span><span class='p'>)</span>
  <span class='c1'>// 연산자 규칙도 작동:</span>
  <span class='k'>for</span> <span class='p'>(</span><span class='n'>i</span> <span class='k'>in</span> <span class='m'>0.</span><span class='p'>.</span><span class='n'>source</span><span class='p'>.</span><span class='n'>size</span><span class='p'>()</span> <span class='p'>-</span> <span class='m'>1</span><span class='p'>)</span>
    <span class='n'>list</span><span class='p'>[</span><span class='n'>i</span><span class='p'>]</span> <span class='p'>=</span> <span class='n'>source</span><span class='p'>[</span><span class='n'>i</span><span class='p'>]</span> <span class='c1'>// get과 set 호출</span>
<span class='p'>}</span></code></pre><h3 id='java-interop.html_getters-setters'>Getters와 Setters<a class='anchor' href='#%23getters-setters'> </a></h3><p>getter와 setter를 위한 자바 규칙을 따르는 메서드는(인자가 없고 이름이 <code>get</code>으로 시작하는 메서드와 한 개 인자를 갖고 이름이 <code>set</code>으로 시작하는 메서드)
코틀린에서 프로퍼티로 표현된다. 다음 예를 보자:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>import</span> <span class='nn'>java.util.Calendar</span>

<span class='k'>fun</span> <span class='nf'>calendarDemo</span><span class='p'>()</span> <span class='p'>{</span>
    <span class='k'>val</span> <span class='py'>calendar</span> <span class='p'>=</span> <span class='n'>Calendar</span><span class='p'>.</span><span class='n'>getInstance</span><span class='p'>()</span>
    <span class='k'>if</span> <span class='p'>(</span><span class='n'>calendar</span><span class='p'>.</span><span class='n'>firstDayOfWeek</span> <span class='p'>==</span> <span class='n'>Calendar</span><span class='p'>.</span><span class='n'>SUNDAY</span><span class='p'>)</span> <span class='p'>{</span>  <span class='c1'>// getFirstDayOfWeek() 호출</span>
        <span class='n'>calendar</span><span class='p'>.</span><span class='n'>firstDayOfWeek</span> <span class='p'>=</span> <span class='n'>Calendar</span><span class='p'>.</span><span class='n'>MONDAY</span>       <span class='c1'>// setFirstDayOfWeek() 호출</span>
    <span class='p'>}</span>
<span class='p'>}</span></code></pre><p>자바 클래스가 setter만 가진 경우 코틀린에서 프로퍼티로 보이지 않는다. 왜냐면, 코틀린은 아직 쓰기 전용 프로퍼티를 지원하지 않기 때문이다.</p><h3 id='java-interop.html_void--'>void를 리턴하는 메서드<a class='anchor' href='#%23void--'> </a></h3><p>void를 리턴하는 자바 메서드를 코틀린에서 실행하면 <code>Unit</code>을 리턴한다.
그 리턴 값을 사용하려고 하면, 그 값을 코틀린 컴파일러는 미리 (<code>Unit</code> 임을) 알 수 있으므로
컴파일러가 호출 위치(call site)에 할당한다.</p><h3 id='java-interop.html_section-1'>코틀린에서 키워드인 자바 식별자를 위한 이스케이프<a class='anchor' href='#%23section-1'> </a></h3><p><em class='keyword'>in</em>, <em class='keyword'>object</em>, <em class='keyword'>is</em> 등 코틀린 키워드 중에서 일부는 자바에서 올바른 식별자이다.
자바 라이브러리가 메서드 이름으로 코틀린 키워드를 사용하면 역따옴표(`) 문자로 메서드 이름을 이스케이프해서 호출할 수 있다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>foo</span><span class='p'>.</span><span class='n'>`is`</span><span class='p'>(</span><span class='n'>bar</span><span class='p'>)</span></code></pre><h3 id='java-interop.html_null---'>Null-안전성과 플랫폼 타입<a class='anchor' href='#%23null---'> </a></h3><p>자바에서 모든 레퍼런스는 <em class='keyword'>null</em>일 수 있는데, 이는 자바에서 오는 객체는 코틀린의 엄격한 null-안정성을 쓸모없게 만든다.
코틀린은 자바 선언 타입을 <em>플랫폼 타입</em>으로 별도 처리한다. 이 타입에 대해서는 null-검사를 완화해서
그 타입에 대한 안전 보장 수준을 자바 정도로 맞춘다(<a href='#%23mapped-types'>아래</a> 참고).</p><p>다음 예를 보자:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>list</span> <span class='p'>=</span> <span class='n'>ArrayList</span><span class='p'>&lt;</span><span class='n'>String</span><span class='p'>&gt;()</span> <span class='c1'>// non-null (생성자 결과)</span>
<span class='n'>list</span><span class='p'>.</span><span class='n'>add</span><span class='p'>(</span><span class='s'>&quot;Item&quot;</span><span class='p'>)</span>
<span class='k'>val</span> <span class='py'>size</span> <span class='p'>=</span> <span class='n'>list</span><span class='p'>.</span><span class='n'>size</span><span class='p'>()</span> <span class='c1'>// non-null (int 타입)</span>
<span class='k'>val</span> <span class='py'>item</span> <span class='p'>=</span> <span class='n'>list</span><span class='p'>[</span><span class='m'>0</span><span class='p'>]</span> <span class='c1'>// 플랫폼 타입 유추 (일반 자바 객체)</span></code></pre><p>플랫폼 타입 변수의 메서드를 호출하면 코틀린은 컴파일 시점에서 null 가능성 에러를 발생하지 않는다.
하지만, 널포인터 익셉션이나 코틀린이 null 전파를 막기 위해 생성하는 assertion 때문에 런타임에 메서드 호출에 실패할 수 있다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>item</span><span class='p'>.</span><span class='n'>substring</span><span class='p'>(</span><span class='m'>1</span><span class='p'>)</span> <span class='c1'>// 컴파일은 허용, item == null 이면 익셉션이 발생할 수 있음</span></code></pre><p>플랫폼 타입은 <em>non-denotable</em>로, 이는 언어에서 직접 그 타입을 쓸 수 없음을 의미한다.
플랫폼 값을 코틀린 변수에 할당할 때, 타입 추론에 기대거나(위 예제에서 <code>item</code>처럼 변수는 추론한 플랫폼 타입을 갖는다)
또는 원하는 타입을 지정할 수 있다(둘 다 nullable과 non-null 타입을 허용한다):</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>nullable</span><span class='p'>:</span> <span class='n'>String</span><span class='p'>?</span> <span class='p'>=</span> <span class='n'>item</span> <span class='c1'>// 허용, 항상 동작</span>
<span class='k'>val</span> <span class='py'>notNull</span><span class='p'>:</span> <span class='n'>String</span> <span class='p'>=</span> <span class='n'>item</span> <span class='c1'>// 허용, 런타임에 실패할 수 있음</span></code></pre><p>non-null 타입을 선택하면, 컴파일러가 할당 시점에 assetion을 발생할 수 있다. 이는 코틀린 non-null 변수가 null을 갖는 것을 막아준다.
또한 non-null 값을 기대하는 코틀린 함수에 플랫폼 값을 전달하면 assertion을 발생한다.
이를 종합하면 컴파일러는 null이 프로그램에 전파되는 것을 최대한 막는다(지네릭때문에 완전히 막지는 못한다).</p><h4 id='java-interop.html_section-2'>플랫폼 타입을 위한 기호<a class='anchor' href='#%23section-2'> </a></h4><p>위에서 말한 것처럼, 프로그램에서 플랫폼 타입을 직접 지정할 수 없기에 언어에 플랫폼 타입을 위한 구문이 없다.
그럼에도 불구하고 컴파일러와 IDE는 플랫폼 타입을 표현해야 할 필요가 있기에(에러 메시지나 파라미터 정보 등)
다음 기호를 사용한다:
As mentioned above, platform types cannot be mentioned explicitly in the program, so there’s no syntax for them in the language.
Nevertheless, the compiler and IDE need to display them sometimes (in error messages, parameter info etc), so we have a
mnemonic notation for them:</p><ul>
  <li><code>T!</code>는 “<code>T</code> 또는 <code>T?</code>“를 의미한다,</li>
  <li><code>(Mutable)Collection&lt;T&gt;!</code>는 “<code>T</code>의 자바 콜렉션은 불변이거나 아닐 수 있고, nullable이거나 아닐 수 있다”를 의미한다,</li>
  <li><code>Array&lt;(out) T&gt;!</code>는 “<code>T</code>(또는 하위 타입)의 배열은 nullable이거나 아니다”를 의미한다,</li>
</ul><h4 id='java-interop.html_nullability-'>Nullability 애노테이션<a class='anchor' href='#%23nullability-'> </a></h4><p>nullability 애노테이션을 가진 자바 타입은 플랫폼 타입이 아닌 실제 nullable이나 non-null 코틀린 타입으로 표현한다.
현재, 컴파일러는 <a href='#https%3A%2F%2Fwww.jetbrains.com%2Fidea%2Fhelp%2Fnullable-and-notnull-annotations.html'>JetBrains의 nullability 애노테이션</a>(<code>org.jetbrains.annotations</code> 패키지의 <code>@Nullable</code>과 <code>@NotNull</code>)을 지원한다.</p><h3 id='java-interop.html_section-3'>매핑한 타입<a class='anchor' href='#%23section-3'> </a></h3><p>코틀린은 자바 타입을 특별하게 처리한다. 자바 타입을 <em>그대로</em> 로딩하지 않고 해당하는 코틀린 타입으로 매핑한다.
매핑은 컴파일 타임에만 일어나며 런타임 표현은 그대로 유지된다.
자바의 기본 데이터 타입은 해당하는 코틀린 타입으로 매핑된다(<a href='#%23platform-types'>플랫폼 타입</a>을 유념한다).</p><table class='zebra'>
  <thead>
    <tr>
      <th><strong>자바 타입</strong></th>
      <th><strong>코틀린 타입</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>byte</code></td>
      <td><code>kotlin.Byte</code></td>
    </tr>
    <tr>
      <td><code>short</code></td>
      <td><code>kotlin.Short</code></td>
    </tr>
    <tr>
      <td><code>int</code></td>
      <td><code>kotlin.Int</code></td>
    </tr>
    <tr>
      <td><code>long</code></td>
      <td><code>kotlin.Long</code></td>
    </tr>
    <tr>
      <td><code>char</code></td>
      <td><code>kotlin.Char</code></td>
    </tr>
    <tr>
      <td><code>float</code></td>
      <td><code>kotlin.Float</code></td>
    </tr>
    <tr>
      <td><code>double</code></td>
      <td><code>kotlin.Double</code></td>
    </tr>
    <tr>
      <td><code>boolean</code></td>
      <td><code>kotlin.Boolean</code></td>
    </tr>
  </tbody>
</table><p>기본 타입이 아닌 일부 내장 클래스도 매핑한다.</p><table class='zebra'>
  <thead>
    <tr>
      <th><strong>자바 타입</strong></th>
      <th><strong>코틀린 타입</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>java.lang.Object</code></td>
      <td><code>kotlin.Any!</code></td>
    </tr>
    <tr>
      <td><code>java.lang.Cloneable</code></td>
      <td><code>kotlin.Cloneable!</code></td>
    </tr>
    <tr>
      <td><code>java.lang.Comparable</code></td>
      <td><code>kotlin.Comparable!</code></td>
    </tr>
    <tr>
      <td><code>java.lang.Enum</code></td>
      <td><code>kotlin.Enum!</code></td>
    </tr>
    <tr>
      <td><code>java.lang.Annotation</code></td>
      <td><code>kotlin.Annotation!</code></td>
    </tr>
    <tr>
      <td><code>java.lang.Deprecated</code></td>
      <td><code>kotlin.Deprecated!</code></td>
    </tr>
    <tr>
      <td><code>java.lang.Void</code></td>
      <td><code>kotlin.Nothing!</code></td>
    </tr>
    <tr>
      <td><code>java.lang.CharSequence</code></td>
      <td><code>kotlin.CharSequence!</code></td>
    </tr>
    <tr>
      <td><code>java.lang.String</code></td>
      <td><code>kotlin.String!</code></td>
    </tr>
    <tr>
      <td><code>java.lang.Number</code></td>
      <td><code>kotlin.Number!</code></td>
    </tr>
    <tr>
      <td><code>java.lang.Throwable</code></td>
      <td><code>kotlin.Throwable!</code></td>
    </tr>
  </tbody>
</table><p>코틀린에서 콜렉션 타입은 읽기 전용이거나 변경 가능할 수 있으므로, 다음과 같이 자바 콜렉션을 매핑한다(이 표의
모든 코틀린 타입은 <code>kotlin</code> 패키지에 위치한다):</p><table class='zebra'>
  <thead>
    <tr>
      <th><strong>자바 타입</strong></th>
      <th><strong>코틀린 읽기 전용 타입</strong></th>
      <th><strong>코틀린 수정 가능 타입</strong></th>
      <th><strong>로딩한 플랫폼 타입</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>Iterator&lt;T&gt;</code></td>
      <td><code>Iterator&lt;T&gt;</code></td>
      <td><code>MutableIterator&lt;T&gt;</code></td>
      <td><code>(Mutable)Iterator&lt;T&gt;!</code></td>
    </tr>
    <tr>
      <td><code>Iterable&lt;T&gt;</code></td>
      <td><code>Iterable&lt;T&gt;</code></td>
      <td><code>MutableIterable&lt;T&gt;</code></td>
      <td><code>(Mutable)Iterable&lt;T&gt;!</code></td>
    </tr>
    <tr>
      <td><code>Collection&lt;T&gt;</code></td>
      <td><code>Collection&lt;T&gt;</code></td>
      <td><code>MutableCollection&lt;T&gt;</code></td>
      <td><code>(Mutable)Collection&lt;T&gt;!</code></td>
    </tr>
    <tr>
      <td><code>Set&lt;T&gt;</code></td>
      <td><code>Set&lt;T&gt;</code></td>
      <td><code>MutableSet&lt;T&gt;</code></td>
      <td><code>(Mutable)Set&lt;T&gt;!</code></td>
    </tr>
    <tr>
      <td><code>List&lt;T&gt;</code></td>
      <td><code>List&lt;T&gt;</code></td>
      <td><code>MutableList&lt;T&gt;</code></td>
      <td><code>(Mutable)List&lt;T&gt;!</code></td>
    </tr>
    <tr>
      <td><code>ListIterator&lt;T&gt;</code></td>
      <td><code>ListIterator&lt;T&gt;</code></td>
      <td><code>MutableListIterator&lt;T&gt;</code></td>
      <td><code>(Mutable)ListIterator&lt;T&gt;!</code></td>
    </tr>
    <tr>
      <td><code>Map&lt;K, V&gt;</code></td>
      <td><code>Map&lt;K, V&gt;</code></td>
      <td><code>MutableMap&lt;K, V&gt;</code></td>
      <td><code>(Mutable)Map&lt;K, V&gt;!</code></td>
    </tr>
    <tr>
      <td><code>Map.Entry&lt;K, V&gt;</code></td>
      <td><code>Map.Entry&lt;K, V&gt;</code></td>
      <td><code>MutableMap.MutableEntry&lt;K,V&gt;</code></td>
      <td><code>(Mutable)Map.(Mutable)Entry&lt;K, V&gt;!</code></td>
    </tr>
  </tbody>
</table><p>자바 배열은 <a href='#java-interop.html%23java-arrays'>아래</a> 언급한 것처럼 매핑한다.</p><table class='zebra'>
  <thead>
    <tr>
      <th><strong>자바 타입</strong></th>
      <th><strong>코틀린 타입</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>int[]</code></td>
      <td><code>kotlin.IntArray!</code></td>
    </tr>
    <tr>
      <td><code>String[]</code></td>
      <td><code>kotlin.Array&lt;(out) String&gt;!</code></td>
    </tr>
  </tbody>
</table><h3 id='java-interop.html_section-4'>코틀린에서 자바 지네릭<a class='anchor' href='#%23section-4'> </a></h3><p>코틀린의 지네릭은 자바와 약간 다르다(<a href='#generics.html'>지네릭</a> 참고). 자바 타입을 코틀린에 임포트할 때, 일부 변환이 발생한다:</p><ul>
  <li>자바 와일드 카드를 타입 프로젝션으로 변환
    <ul>
      <li><code>Foo&lt;? extends Bar&gt;</code>는 <code>Foo&lt;out Bar!&gt;!</code>이 된다</li>
      <li><code>Foo&lt;? super Bar&gt;</code>는 <code>Foo&lt;in Bar!&gt;!</code>이 된다</li>
    </ul>
  </li>
  <li>자바의 raw 타입을 스타-프로젝션으로 변환
    <ul>
      <li><code>List</code>는 <code>List&lt;*&gt;!</code>, 즉 <code>List&lt;out Any?&gt;!</code>이 된다.</li>
    </ul>
  </li>
</ul><p>자바처럼 코틀린도 런타임에 지네릭을 유지하지 않으므로 객체는 생성자에 전달한 실제 타입 파라미터에 대한 정보를 갖지 않는다.
즉, <code>ArrayList&lt;Integer&gt;()</code>와 <code>ArrayList&lt;Character&gt;()</code>는 구분되지 않는다.
이는 지네릭을 <em class='keyword'>is</em>-검사에 사용할 수 없게 만든다.
코틀린은 스타-프로젝션 지네릭 타입에 대한 <em class='keyword'>is</em>-검사만 허용한다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>if</span> <span class='p'>(</span><span class='n'>a</span> <span class='k'>is</span> <span class='n'>List</span><span class='p'>&lt;</span><span class='n'>Int</span><span class='p'>&gt;)</span> <span class='c1'>// 에러: 실제 Int의 List인지 검사할 수 없다</span>
<span class='c1'>// but</span>
<span class='k'>if</span> <span class='p'>(</span><span class='n'>a</span> <span class='k'>is</span> <span class='n'>List</span><span class='p'>&lt;*&gt;)</span> <span class='c1'>// OK: List의 내용에 대해 보장하지 않는다</span></code></pre><h3 id='java-interop.html_section-5'>자바 배열<a class='anchor' href='#%23section-5'> </a></h3><p>코틀린 배열은 자바와 달리 무공변(invariant)하다. 이는 코틀린에서 <code>Array&lt;Any&gt;</code>에 <code>Array&lt;String&gt;</code>를 할당할 수 없음을 의미하며, 가능한 런타임 실패를 막아준다.
또한 하위클래스 배열을 코틀린 메서드의 상위클래스 배열 파라미터에 전달하는 것도 막아준다. 자바 메서드는 (<code>Array&lt;(out) String&gt;!</code> 형식의 <a href='#%23platform-types'>플랫폼 타입</a>) 이를 허용한다.</p><p>자바 플랫폼에서는 박싱/언박싱 비용을 없애기 위해 배열에 기본 데이터타입을 사용한다.
코틀린은 이런 구현 상세를 감추므로, 자바 코드를 사용하려면 우회방법이 필요하다.
이를 위해 모든 기본 데이터타입의 배열을 위한 별도 클래스(<code>IntArray</code>, <code>DoubleArray</code>, <code>CharArray</code> 등)를 제공한다.
이 클래스는 <code>Array</code> 클래스와는 관련이 없으며 최대 성능을 위해 자바의 기본 데이터타입 배열로 컴파일된다.</p><p>int 배열을 받는 자바 메서드가 있다고 가정하자:</p><pre><code class='code-block _highlighted lang_java'><span class='kd'>public</span> <span class='kd'>class</span> <span class='nc'>JavaArrayExample</span> <span class='o'>{</span>

    <span class='kd'>public</span> <span class='kt'>void</span> <span class='nf'>removeIndices</span><span class='o'>(</span><span class='kt'>int</span><span class='o'>[]</span> <span class='n'>indices</span><span class='o'>)</span> <span class='o'>{</span>
        <span class='c1'>// code here...</span>
    <span class='o'>}</span>
<span class='o'>}</span></code></pre><p>코틀린에서 기본 데이터타입의 배열을 전달하려면 다음과 같이 할 수 있다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>javaObj</span> <span class='p'>=</span> <span class='n'>JavaArrayExample</span><span class='p'>()</span>
<span class='k'>val</span> <span class='py'>array</span> <span class='p'>=</span> <span class='n'>intArrayOf</span><span class='p'>(</span><span class='m'>0</span><span class='p'>,</span> <span class='m'>1</span><span class='p'>,</span> <span class='m'>2</span><span class='p'>,</span> <span class='m'>3</span><span class='p'>)</span>
<span class='n'>javaObj</span><span class='p'>.</span><span class='n'>removeIndices</span><span class='p'>(</span><span class='n'>array</span><span class='p'>)</span>  <span class='c1'>// int[]를 메서드에 전달</span></code></pre><p>JVM 바이트 코드로 컴파일할 때, 컴파일러는 배열 접근을 최적화해서 추가 오버헤드를 없앤다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>array</span> <span class='p'>=</span> <span class='n'>arrayOf</span><span class='p'>(</span><span class='m'>1</span><span class='p'>,</span> <span class='m'>2</span><span class='p'>,</span> <span class='m'>3</span><span class='p'>,</span> <span class='m'>4</span><span class='p'>)</span>
<span class='n'>array</span><span class='p'>[</span><span class='n'>x</span><span class='p'>]</span> <span class='p'>=</span> <span class='n'>array</span><span class='p'>[</span><span class='n'>x</span><span class='p'>]</span> <span class='p'>*</span> <span class='m'>2</span> <span class='c1'>// get()과 set()을 호출하지 않음</span>
<span class='k'>for</span> <span class='p'>(</span><span class='n'>x</span> <span class='k'>in</span> <span class='n'>array</span><span class='p'>)</span> <span class='c1'>// Iterator를 생성하지 않음</span>
  <span class='n'>print</span><span class='p'>(</span><span class='n'>x</span><span class='p'>)</span></code></pre><p>인덱스로 접근할 때도 오버헤드가 발생하지 않는다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>for</span> <span class='p'>(</span><span class='n'>i</span> <span class='k'>in</span> <span class='n'>array</span><span class='p'>.</span><span class='n'>indices</span><span class='p'>)</span> <span class='c1'>// Iterator를 생성하지 않음</span>
  <span class='n'>array</span><span class='p'>[</span><span class='n'>i</span><span class='p'>]</span> <span class='p'>+=</span> <span class='m'>2</span></code></pre><p>마지막으로 <em class='keyword'>in</em>-검사도 오버헤드가 없다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>if</span> <span class='p'>(</span><span class='n'>i</span> <span class='k'>in</span> <span class='n'>array</span><span class='p'>.</span><span class='n'>indices</span><span class='p'>)</span> <span class='p'>{</span> <span class='c1'>// (i &gt;= 0 &amp;&amp; i &lt; array.size)와 동일</span>
  <span class='n'>print</span><span class='p'>(</span><span class='n'>array</span><span class='p'>[</span><span class='n'>i</span><span class='p'>])</span>
<span class='p'>}</span></code></pre><h3 id='java-interop.html_section-6'>자바 가변인자<a class='anchor' href='#%23section-6'> </a></h3><p>가변 개수의 인자를 갖는 메서드를 사용하는 자바 클래스가 종종 있다.</p><pre><code class='code-block _highlighted lang_java'><span class='kd'>public</span> <span class='kd'>class</span> <span class='nc'>JavaArrayExample</span> <span class='o'>{</span>

    <span class='kd'>public</span> <span class='kt'>void</span> <span class='nf'>removeIndices</span><span class='o'>(</span><span class='kt'>int</span><span class='o'>...</span> <span class='n'>indices</span><span class='o'>)</span> <span class='o'>{</span>
        <span class='c1'>// code here...</span>
    <span class='o'>}</span>
<span class='o'>}</span></code></pre><p>이 경우 <code>IntArray</code>를 파라미터로 전달하려면 spread 연산자인 <code>*</code>를 사용해야 한다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>javaObj</span> <span class='p'>=</span> <span class='n'>JavaArray</span><span class='p'>()</span>
<span class='k'>val</span> <span class='py'>array</span> <span class='p'>=</span> <span class='n'>intArrayOf</span><span class='p'>(</span><span class='m'>0</span><span class='p'>,</span> <span class='m'>1</span><span class='p'>,</span> <span class='m'>2</span><span class='p'>,</span> <span class='m'>3</span><span class='p'>)</span>
<span class='n'>javaObj</span><span class='p'>.</span><span class='n'>removeIndicesVarArg</span><span class='p'>(*</span><span class='n'>array</span><span class='p'>)</span></code></pre><p>현재는 가변 인자 메서드에 <em class='keyword'>null</em>을 전달할 수 없다.</p><h3 id='java-interop.html_section-7'>연산자<a class='anchor' href='#%23section-7'> </a></h3><p>자바는 메서드를 연산자 구문으로 사용할 수 있는 방법이 없기 때문에,
코틀린은 올바른 이름과 시그너처를 가진 모든 자바 메서드를 연산자 오버로딩과 다른 규칙(<code>invoke()</code> 등)으로 사용할 수 있도록 한다.
자바 메서드를 중위 호출 구문을 이용해서 호출하는 것을 허용하지 않는다.</p><h3 id='java-interop.html_section-8'>체크드 익셉션<a class='anchor' href='#%23section-8'> </a></h3><p>코틀린의 모든 익셉션은 언체크드인데 이는 컴파일러가 익셉션 catch를 강제하지 않는다는 것을 의미한다.
따라서 체크드 익셉션을 선언한 자바 메서드를 호출할 때 코틀린은 익셉션 cath를 강제하지 않는다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>render</span><span class='p'>(</span><span class='n'>list</span><span class='p'>:</span> <span class='n'>List</span><span class='p'>&lt;*&gt;,</span> <span class='n'>to</span><span class='p'>:</span> <span class='n'>Appendable</span><span class='p'>)</span> <span class='p'>{</span>
  <span class='k'>for</span> <span class='p'>(</span><span class='n'>item</span> <span class='k'>in</span> <span class='n'>list</span><span class='p'>)</span>
    <span class='n'>to</span><span class='p'>.</span><span class='n'>append</span><span class='p'>(</span><span class='n'>item</span><span class='p'>.</span><span class='n'>toString</span><span class='p'>())</span> <span class='c1'>// 자바는 여기에 IOException catch를 요구한다</span>
<span class='p'>}</span></code></pre><h3 id='java-interop.html_object-'>Object 메서드<a class='anchor' href='#%23object-'> </a></h3><p>자바 타입을 코틀린에 임포트할 때, <code>java.lang.Object</code> 타입의 모든 레퍼런스는 <code>Any</code>로 바뀐다.
<code>Any</code>는 플랫폼에 특화되어 있지 않기에 멤버로 <code>toString()</code>, <code>hashCode()</code> 그리고 <code>equals()</code>만 선언하고 있다.
따라서 <code>java.lang.Object</code>의 다른 멤버를 사용할 수 있도록 코틀린은 <a href='#extensions.html'>확장 함수</a>를 사용한다.</p><h4 id='java-interop.html_waitnotify'>wait()/notify()<a class='anchor' href='#%23waitnotify'> </a></h4><p><a href='#http%3A%2F%2Fwww.oracle.com%2Ftechnetwork%2Fjava%2Feffectivejava-136174.html'>Effective Java</a> Item 69는 <code>wait()</code>와 <code>notify()</code>보다 병렬 유틸리티를 쓰라고 제안하고 있다.
<code>Any</code> 타입 레퍼런스에는 이 메서드를 사용할 수 없다.
만약 그 메서드를 실제로 호출해야 한다면 <code>java.lang.Object</code>로 변환하면 된다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='p'>(</span><span class='n'>foo</span> <span class='k'>as</span> <span class='n'>java</span><span class='p'>.</span><span class='n'>lang</span><span class='p'>.</span><span class='n'>Object</span><span class='p'>).</span><span class='n'>wait</span><span class='p'>()</span></code></pre><h4 id='java-interop.html_getclass'>getClass()<a class='anchor' href='#%23getclass'> </a></h4><p>객체의 타입 정보를 구하려면 javaClass 확장 프로퍼티를 사용한다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>fooClass</span> <span class='p'>=</span> <span class='n'>foo</span><span class='p'>.</span><span class='n'>javaClass</span></code></pre><p>자바의 <code>Foo.class</code> 대신에 Foo::class.java를 사용한다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>fooClass</span> <span class='p'>=</span> <span class='n'>Foo</span><span class='o'>::</span><span class='k'>class</span><span class='p'>.</span><span class='n'>java</span></code></pre><h4 id='java-interop.html_clone'>clone()<a class='anchor' href='#%23clone'> </a></h4><p><code>clone()</code>을 오버라이드하려면, <code>kotlin.Cloneable</code>을 확장해야 한다.:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>class</span> <span class='nc'>Example</span> <span class='p'>:</span> <span class='n'>Cloneable</span> <span class='p'>{</span>
  <span class='k'>override</span> <span class='k'>fun</span> <span class='nf'>clone</span><span class='p'>():</span> <span class='n'>Any</span> <span class='p'>{</span> <span class='p'>...</span> <span class='p'>}</span>
<span class='p'>}</span></code></pre><p><a href='#http%3A%2F%2Fwww.oracle.com%2Ftechnetwork%2Fjava%2Feffectivejava-136174.html'>Effective Java</a>, Item 11: <em>Override clone judiciously</em>를 잊지 말자.</p><h4 id='java-interop.html_finalize'>finalize()<a class='anchor' href='#%23finalize'> </a></h4><p><code>finalize()</code>를 오버라이드하려면, <em class='keyword'>override</em> 키워드를 사용하지 않고 단순히 메서드를 선언만 하면 된다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>class</span> <span class='nc'>C</span> <span class='p'>{</span>
  <span class='k'>protected</span> <span class='k'>fun</span> <span class='nf'>finalize</span><span class='p'>()</span> <span class='p'>{</span>
    <span class='c1'>// finalization logic</span>
  <span class='p'>}</span>
<span class='p'>}</span></code></pre><p>자바 규칙에 따라 <code>finalize()</code>는 <em class='keyword'>private</em>이면 안 된다.</p><h3 id='java-interop.html_section-9'>자바 클래스를 상속하기<a class='anchor' href='#%23section-9'> </a></h3><p>코틀린 클래스의 상위타입으로 최대 한 개의 자바 클래스를(자바 인터페이스는 여러 개) 사용할 수 있다.</p><h3 id='java-interop.html_section-10'>정적 멤버 접근<a class='anchor' href='#%23section-10'> </a></h3><p>자바 클래스의 정적 멤버는 이 클래스의 “컴페니언 오브젝트”를 만든다. 값으로 “컴페니언 오브젝트”를 전달할 수 없지만
멤버에 직접 접근할 수는 있다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>if</span> <span class='p'>(</span><span class='n'>Character</span><span class='p'>.</span><span class='n'>isLetter</span><span class='p'>(</span><span class='n'>a</span><span class='p'>))</span> <span class='p'>{</span>
  <span class='c1'>// ...</span>
<span class='p'>}</span></code></pre><h3 id='java-interop.html_section-11'>자바 리플렉션<a class='anchor' href='#%23section-11'> </a></h3><p>자바 리플렉션은 코틀린 클래스에 동작하며 반대로도 된다. 위에서 말한 것처럼 <code>java.lang.Class</code>로 자바 리플렉션을 사용하려면
<code>instance.javaClass</code>나 <code>ClassName::class.java</code>를 사용할 수 있다.</p><p>이 외에 코틀린 프로퍼티를 위한 자바 getter/setter 메서드나 backing 필드 구하기, 자바 필드를 위한 <code>KProperty</code>, <code>KFunction</code>을 위한 자바 메서드나 생성자 구하기 그리고 그 반대 기능을 지원한다.</p><h3 id='java-interop.html_sam-'>SAM 변환<a class='anchor' href='#%23sam-'> </a></h3><p>자바 8과 같이 코틀린은 SAM 변환을 지원한다. 이는 코틀린 함수 리터럴을 (인터페이스 파라미터 타입이 코틀린 함수의 파라미터 타입에 매칭되는 함수)
자동으로 한 개의 non-default 메서드를 갖는 자바 인터페이스 구현으로 변경한다는 것을 의미한다.</p><p>SAM 인터페이스의 인스턴스를 생성하러면 SAM 변환을 사용할 수 있다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>runnable</span> <span class='p'>=</span> <span class='n'>Runnable</span> <span class='p'>{</span> <span class='n'>println</span><span class='p'>(</span><span class='s'>&quot;This runs in a runnable&quot;</span><span class='p'>)</span> <span class='p'>}</span></code></pre><p>…메서드 호출에서 SAM 변환:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>executor</span> <span class='p'>=</span> <span class='n'>ThreadPoolExecutor</span><span class='p'>()</span>
<span class='c1'>// Java signature: void execute(Runnable command)</span>
<span class='n'>executor</span><span class='p'>.</span><span class='n'>execute</span> <span class='p'>{</span> <span class='n'>println</span><span class='p'>(</span><span class='s'>&quot;This runs in a thread pool&quot;</span><span class='p'>)</span> <span class='p'>}</span></code></pre><p>자바 클래스가 함수형 인터페이스를 받는 메서드를 여러 개 가지면 람다를 특정 SAM 타입으로 변환하는 어댑터 함수를 호출해서
사용할 메서드를 선택할 수 있다. 컴파일러는 필요한 곳에 이 어댑터 함수를 생성한다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>executor</span><span class='p'>.</span><span class='n'>execute</span><span class='p'>(</span><span class='n'>Runnable</span> <span class='p'>{</span> <span class='n'>println</span><span class='p'>(</span><span class='s'>&quot;This runs in a thread pool&quot;</span><span class='p'>)</span> <span class='p'>})</span></code></pre><p>SAM 변환은 인터페이스에만 적용되며, 추상 클래스의 경우 추상 메서드 한 개만 가진 경우라도 적용되지 않는다.</p><p>또한 이 기능은 자바 상호운용에 대해서만 동작한다. 코틀린은 적당한 함수 타입을 갖고 있기 때문에
함수를 코틀린 인터페이스 구현으로 자동 변환하는 기능은 필요 없고 따라서 지원하지 않는다.</p><h3 id='java-interop.html_jni-'>코틀린에서 JNI 사용하기<a class='anchor' href='#%23jni-'> </a></h3><p>네이티브 (C나 C++) 코드로 구현한 함수를 선언하려면 <code>external</code> 제한자를 사용하면 된다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>external</span> <span class='k'>fun</span> <span class='nf'>foo</span><span class='p'>(</span><span class='n'>x</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>):</span> <span class='n'>Double</span></code></pre><p>이를 뺀 나머지는 자바와 정확하게 같은 방식으로 동작한다.</p>
              </article>
          
              <article id="java-to-kotlin-interop.html" class="page-content">
                <h2 id='java-to-kotlin-interop.html_section'>자바에서 코틀린 실행하기<a class='anchor' href='#%23section'> </a></h2><p>자바에서 쉽게 코틀린 코드를 실행할 수 있다.</p><h3 id='java-to-kotlin-interop.html_section-1'>프로퍼티<a class='anchor' href='#%23section-1'> </a></h3><p>프로퍼티 getter는 <em>get</em>-메서드로 setter는 <em>set</em>-메서드로 바뀐다.</p><h3 id='java-to-kotlin-interop.html_section-2'>패키지 수준 함수<a class='anchor' href='#%23section-2'> </a></h3><p><code>example.kt</code> 파일의 <code>org.foo.bar</code> 패키지에 선언한 함수와 프로퍼티는
<code>org.foo.bar.ExampleKt</code>라 불리는 자바 클래스에 위치한다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='c1'>// example.kt</span>
<span class='k'>package</span> <span class='nn'>demo</span>

<span class='k'>class</span> <span class='nc'>Foo</span>

<span class='k'>fun</span> <span class='nf'>bar</span><span class='p'>()</span> <span class='p'>{</span>
<span class='p'>}</span></code></pre><pre><code class='code-block _highlighted lang_java'><span class='c1'>// Java</span>
<span class='k'>new</span> <span class='n'>demo</span><span class='o'>.</span><span class='na'>Foo</span><span class='o'>();</span>
<span class='n'>demo</span><span class='o'>.</span><span class='na'>ExampleKt</span><span class='o'>.</span><span class='na'>bar</span><span class='o'>();</span></code></pre><p><code>@JvmName</code> 애노테이션을 사용하면 생성할 자바 클래스의 이름을 바꿀 수 있다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>@file</span><span class='p'>:</span><span class='n'>JvmName</span><span class='p'>(</span><span class='s'>&quot;DemoUtils&quot;</span><span class='p'>)</span>

<span class='k'>package</span> <span class='nn'>demo</span>

<span class='k'>class</span> <span class='nc'>Foo</span>

<span class='k'>fun</span> <span class='nf'>bar</span><span class='p'>()</span> <span class='p'>{</span>
<span class='p'>}</span></code></pre><pre><code class='code-block _highlighted lang_java'><span class='c1'>// Java</span>
<span class='k'>new</span> <span class='n'>demo</span><span class='o'>.</span><span class='na'>Foo</span><span class='o'>();</span>
<span class='n'>demo</span><span class='o'>.</span><span class='na'>DemoUtils</span><span class='o'>.</span><span class='na'>bar</span><span class='o'>();</span></code></pre><p>(같은 패키지나 같은 이름 또는 같은 @JvmName 애노테이션을 사용해서) 생성할 자바 클래스 이름이 같은 파일이 여러 개인 경우 보통 에러가 발생한다.
하지만, 컴파일러는 같은 이름을(파일 이름이나 <code>@JvmName</code> 값) 갖는 모든 파일에 선언한 모든 것을 포함하는 단일 자바 파사드 클래스를 만드는 기능을 제공한다.
파사드 생성을 활성화하려면 모든 파일에 @JvmMultifileClass 애노테이션을 사용하면 된다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='c1'>// oldutils.kt</span>
<span class='n'>@file</span><span class='p'>:</span><span class='n'>JvmName</span><span class='p'>(</span><span class='s'>&quot;Utils&quot;</span><span class='p'>)</span>
<span class='n'>@file</span><span class='p'>:</span><span class='n'>JvmMultifileClass</span>

<span class='k'>package</span> <span class='nn'>demo</span>

<span class='k'>fun</span> <span class='nf'>foo</span><span class='p'>()</span> <span class='p'>{</span>
<span class='p'>}</span></code></pre><pre><code class='code-block _highlighted lang_kotlin'><span class='c1'>// newutils.kt</span>
<span class='n'>@file</span><span class='p'>:</span><span class='n'>JvmName</span><span class='p'>(</span><span class='s'>&quot;Utils&quot;</span><span class='p'>)</span>
<span class='n'>@file</span><span class='p'>:</span><span class='n'>JvmMultifileClass</span>

<span class='k'>package</span> <span class='nn'>demo</span>

<span class='k'>fun</span> <span class='nf'>bar</span><span class='p'>()</span> <span class='p'>{</span>
<span class='p'>}</span></code></pre><pre><code class='code-block _highlighted lang_java'><span class='c1'>// Java</span>
<span class='n'>demo</span><span class='o'>.</span><span class='na'>Utils</span><span class='o'>.</span><span class='na'>foo</span><span class='o'>();</span>
<span class='n'>demo</span><span class='o'>.</span><span class='na'>Utils</span><span class='o'>.</span><span class='na'>bar</span><span class='o'>();</span></code></pre><h3 id='java-to-kotlin-interop.html_section-3'>인스턴스 필드<a class='anchor' href='#%23section-3'> </a></h3><p>코틀린 프로퍼티를 자바의 필드로 노출하고 싶다면 <code>@JvmField</code> 애노테이션을 프로퍼티에 적용해야 한다.
필드는 해당하는 프로퍼티와 같은 가시성을 갖는다. 프로퍼티가 backing 필드를 갖거나, 가시성이 private이 아니거나,
<code>open</code>, <code>override</code> 또는 <code>const</code> 제한자를 갖지 않거나, 위임 프로퍼티가 아니면
프로퍼티에 <code>@JvmField</code>를 붙일 수 없다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>class</span> <span class='nc'>C</span><span class='p'>(</span><span class='n'>id</span><span class='p'>:</span> <span class='n'>String</span><span class='p'>)</span> <span class='p'>{</span>
    <span class='n'>@JvmField</span> <span class='k'>val</span> <span class='py'>ID</span> <span class='p'>=</span> <span class='n'>id</span>
<span class='p'>}</span></code></pre><pre><code class='code-block _highlighted lang_java'><span class='c1'>// Java</span>
<span class='kd'>class</span> <span class='nc'>JavaClient</span> <span class='o'>{</span>
    <span class='kd'>public</span> <span class='n'>String</span> <span class='nf'>getID</span><span class='o'>(</span><span class='n'>C</span> <span class='n'>c</span><span class='o'>)</span> <span class='o'>{</span>
        <span class='k'>return</span> <span class='n'>c</span><span class='o'>.</span><span class='na'>ID</span><span class='o'>;</span>
    <span class='o'>}</span>
<span class='o'>}</span></code></pre><p><a href='#properties.html%23late-initialized-properties'>Late-Initialized</a> 프로퍼티도 필드로 노출된다.
필드는 <code>lateinit</code> 프로퍼티의 setter와 같은 가시성을 갖는다.</p><h3 id='java-to-kotlin-interop.html_section-4'>정적 필드<a class='anchor' href='#%23section-4'> </a></h3><p>네임드 오브젝트나 컴페니언 오브젝트에 선언한 코틀린 프로퍼티는 네임드 오브젝트나 컴페니언 오브젝트를 포함하는 클래스에서
정적 backing 필드를 갖는다.</p><p>보통 이 필드는 private이지만 다음 중 한 가지 방법으로 노출할 수 있다:</p><ul>
  <li><code>@JvmField</code> 애노테이션;</li>
  <li><code>lateinit</code> 제한자;</li>
  <li><code>const</code> 제한자.</li>
</ul><p><code>@JvmField</code>을 붙인 프로퍼티는 프로퍼티 자체와 같은 가시성을 갖는 정적 필드가 된다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>class</span> <span class='nc'>Key</span><span class='p'>(</span><span class='k'>val</span> <span class='py'>value</span><span class='p'>:</span> <span class='n'>Int</span><span class='p'>)</span> <span class='p'>{</span>
    <span class='n'>companion</span> <span class='k'>object</span> <span class='err'>{</span>
        <span class='n'>@JvmField</span>
        <span class='k'>val</span> <span class='py'>COMPARATOR</span><span class='p'>:</span> <span class='n'>Comparator</span><span class='p'>&lt;</span><span class='n'>Key</span><span class='p'>&gt;</span> <span class='p'>=</span> <span class='n'>compareBy</span><span class='p'>&lt;</span><span class='n'>Key</span><span class='p'>&gt;</span> <span class='p'>{</span> <span class='n'>it</span><span class='p'>.</span><span class='n'>value</span> <span class='p'>}</span>
    <span class='p'>}</span>
<span class='p'>}</span></code></pre><pre><code class='code-block _highlighted lang_java'><span class='c1'>// Java</span>
<span class='n'>Key</span><span class='o'>.</span><span class='na'>COMPARATOR</span><span class='o'>.</span><span class='na'>compare</span><span class='o'>(</span><span class='n'>key1</span><span class='o'>,</span> <span class='n'>key2</span><span class='o'>);</span>
<span class='c1'>// Key 클래스에 public static final 필드</span></code></pre><p>오브젝트나 컴페니언 오브젝트의 <a href='#properties.html%23late-initialized-properties'>late-initialized</a> 프로퍼티는
프로퍼티 setter와 같은 가시성을 갖는 정적 backing 필드를 갖는다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>object</span> <span class='nc'>Singleton</span> <span class='p'>{</span>
    <span class='n'>lateinit</span> <span class='k'>var</span> <span class='py'>provider</span><span class='p'>:</span> <span class='n'>Provider</span>
<span class='p'>}</span></code></pre><pre><code class='code-block _highlighted lang_java'><span class='c1'>// Java</span>
<span class='n'>Singleton</span><span class='o'>.</span><span class='na'>provider</span> <span class='o'>=</span> <span class='k'>new</span> <span class='nf'>Provider</span><span class='o'>();</span>
<span class='c1'>// public static non-final field in Singleton class</span></code></pre><p>(최상위 수준 또는 클래스에 있는) <code>const</code> 프로퍼티는 자바에서 정적 필드가 된다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='c1'>// file example.kt</span>

<span class='k'>object</span> <span class='nc'>Obj</span> <span class='p'>{</span>
  <span class='n'>const</span> <span class='k'>val</span> <span class='py'>CONST</span> <span class='p'>=</span> <span class='m'>1</span>
<span class='p'>}</span>

<span class='k'>class</span> <span class='nc'>C</span> <span class='p'>{</span>
    <span class='n'>companion</span> <span class='k'>object</span> <span class='err'>{</span>
        <span class='n'>const</span> <span class='k'>val</span> <span class='py'>VERSION</span> <span class='p'>=</span> <span class='m'>9</span>
    <span class='p'>}</span>
<span class='p'>}</span>

<span class='n'>const</span> <span class='k'>val</span> <span class='py'>MAX</span> <span class='p'>=</span> <span class='m'>239</span></code></pre><p>자바:</p><pre><code class='code-block _highlighted lang_java'><span class='kt'>int</span> <span class='n'>c</span> <span class='o'>=</span> <span class='n'>Obj</span><span class='o'>.</span><span class='na'>CONST</span><span class='o'>;</span>
<span class='kt'>int</span> <span class='n'>d</span> <span class='o'>=</span> <span class='n'>ExampleKt</span><span class='o'>.</span><span class='na'>MAX</span><span class='o'>;</span>
<span class='kt'>int</span> <span class='n'>v</span> <span class='o'>=</span> <span class='n'>C</span><span class='o'>.</span><span class='na'>VERSION</span><span class='o'>;</span></code></pre><h3 id='java-to-kotlin-interop.html_section-5'>정적 메서드<a class='anchor' href='#%23section-5'> </a></h3><p>앞서 언급했듯이 패키지 수준 함수에 대해 코틀린은 정적 메서드를 생성한다.
또한 코틀린은 네임드 오브젝트나 컴페니언 오브젝트에 정의한 함수에 <code>@JvmStatic</code>을 붙이면 정적 메서드를 생성한다.
다음 예를 보자:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>class</span> <span class='nc'>C</span> <span class='p'>{</span>
  <span class='n'>companion</span> <span class='k'>object</span> <span class='err'>{</span>
    <span class='n'>@JvmStatic</span> <span class='k'>fun</span> <span class='nf'>foo</span><span class='p'>()</span> <span class='p'>{}</span>
    <span class='k'>fun</span> <span class='nf'>bar</span><span class='p'>()</span> <span class='p'>{}</span>
  <span class='p'>}</span>
<span class='p'>}</span></code></pre><p>여기서 <code>foo()</code>는 자바에서 정적이지만 <code>bar()</code>는 아니다:</p><pre><code class='code-block _highlighted lang_java'><span class='n'>C</span><span class='o'>.</span><span class='na'>foo</span><span class='o'>();</span> <span class='c1'>// 잘 동작</span>
<span class='n'>C</span><span class='o'>.</span><span class='na'>bar</span><span class='o'>();</span> <span class='c1'>// 에러: 정적 메서드 아님</span></code></pre><p>네임드 오브젝트도 같다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>object</span> <span class='nc'>Obj</span> <span class='p'>{</span>
    <span class='n'>@JvmStatic</span> <span class='k'>fun</span> <span class='nf'>foo</span><span class='p'>()</span> <span class='p'>{}</span>
    <span class='k'>fun</span> <span class='nf'>bar</span><span class='p'>()</span> <span class='p'>{}</span>
<span class='p'>}</span></code></pre><p>자바:</p><pre><code class='code-block _highlighted lang_java'><span class='n'>Obj</span><span class='o'>.</span><span class='na'>foo</span><span class='o'>();</span> <span class='c1'>// 잘 동작</span>
<span class='n'>Obj</span><span class='o'>.</span><span class='na'>bar</span><span class='o'>();</span> <span class='c1'>// 에러</span>
<span class='n'>Obj</span><span class='o'>.</span><span class='na'>INSTANCE</span><span class='o'>.</span><span class='na'>bar</span><span class='o'>();</span> <span class='c1'>// 싱글톤 인스턴스를 통해서 호출</span>
<span class='n'>Obj</span><span class='o'>.</span><span class='na'>INSTANCE</span><span class='o'>.</span><span class='na'>foo</span><span class='o'>();</span> <span class='c1'>// 역시 동작</span></code></pre><p><code>@JvmStatic</code> 애노테이션을 오브젝트 프로퍼티나 컴페니언 오브젝트에 적용할 수 있다.
이는 getter와 setter 메서드를 그 오브젝트나 컴페니언 오브젝트를 포함한 클래스의 정적 메서드로 만든다.</p><h3 id='java-to-kotlin-interop.html_jvmname---'>@JvmName으로 시그너처 충돌 처리하기<a class='anchor' href='#%23jvmname---'> </a></h3><p>때때로 코틀린에서 네임드 함수가 JVM 바이트 코드 상의 이름과 달라야 할 때가 있다.
가장 두드러진 예는 <em>타입 제거(type erasure)</em> 때문에 발생한다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>List</span><span class='p'>&lt;</span><span class='n'>String</span><span class='p'>&gt;.</span><span class='n'>filterValid</span><span class='p'>():</span> <span class='n'>List</span><span class='p'>&lt;</span><span class='n'>String</span><span class='p'>&gt;</span>
<span class='k'>fun</span> <span class='nf'>List</span><span class='p'>&lt;</span><span class='n'>Int</span><span class='p'>&gt;.</span><span class='n'>filterValid</span><span class='p'>():</span> <span class='n'>List</span><span class='p'>&lt;</span><span class='n'>Int</span><span class='p'>&gt;</span></code></pre><p>이 두 함수는 함께 정의할 수 없다. 왜냐면 JVM 시그너처가 <code>filterValid(Ljava/util/List;)Ljava/util/List;</code>로 같기 때문이다.
코틀린에서 같은 이름을 갖는 함수를 정의하고 싶다면 두 함수 중 하나에 (또는 두 함수 모두에) <code>@JvmName</code>의 인자로 다른 이름을 지정해야 한다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>List</span><span class='p'>&lt;</span><span class='n'>String</span><span class='p'>&gt;.</span><span class='n'>filterValid</span><span class='p'>():</span> <span class='n'>List</span><span class='p'>&lt;</span><span class='n'>String</span><span class='p'>&gt;</span>

<span class='n'>@JvmName</span><span class='p'>(</span><span class='s'>&quot;filterValidInt&quot;</span><span class='p'>)</span>
<span class='k'>fun</span> <span class='nf'>List</span><span class='p'>&lt;</span><span class='n'>Int</span><span class='p'>&gt;.</span><span class='n'>filterValid</span><span class='p'>():</span> <span class='n'>List</span><span class='p'>&lt;</span><span class='n'>Int</span><span class='p'>&gt;</span></code></pre><p>코틀린에서는 같은 이름인 <code>filterValid</code>로 접근할 수 있지만 자바에서는 이름이 <code>filterValid</code>와 <code>filterValidInt</code>가 된다.</p><p>함수 <code>getX()</code>를 갖는 이름이 <code>x</code>인 프로퍼티에 대해서도 같은 트릭을 사용할 수 있다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>val</span> <span class='py'>x</span><span class='p'>:</span> <span class='n'>Int</span>
  <span class='n'>@JvmName</span><span class='p'>(</span><span class='s'>&quot;getX_prop&quot;</span><span class='p'>)</span>
  <span class='k'>get</span><span class='p'>()</span> <span class='p'>=</span> <span class='m'>15</span>

<span class='k'>fun</span> <span class='nf'>getX</span><span class='p'>()</span> <span class='p'>=</span> <span class='m'>10</span></code></pre><h3 id='java-to-kotlin-interop.html_section-6'>오버로딩 생성<a class='anchor' href='#%23section-6'> </a></h3><p>보통 기본 파라미터 값을 갖는 코틀린 메서드를 작성하면 자바에서는 모든 파라미터가 있는 전체 시그너처만 사용 가능하다.
만약 자바 코드에 오버로드한 여러 메서드를 노출하고 싶다면 @JvmOverloads 애노테이션을 사용할 수 있다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>@JvmOverloads</span> <span class='k'>fun</span> <span class='nf'>f</span><span class='p'>(</span><span class='n'>a</span><span class='p'>:</span> <span class='n'>String</span><span class='p'>,</span> <span class='n'>b</span><span class='p'>:</span> <span class='n'>Int</span> <span class='p'>=</span> <span class='m'>0</span><span class='p'>,</span> <span class='n'>c</span><span class='p'>:</span> <span class='n'>String</span> <span class='p'>=</span> <span class='s'>&quot;abc&quot;</span><span class='p'>)</span> <span class='p'>{</span>
    <span class='p'>...</span>
<span class='p'>}</span></code></pre><p>기본 값을 가진 모든 파라미터에 대해 오버로드 메서드를 생성한다. 기본 값을 가진 파라미터와 그 오른쪽에 위치한 파라미터를 파라미터 목록에서 제거한다.
이 예는 다음 메서드를 생성한다:</p><pre><code class='code-block _highlighted lang_java'><span class='c1'>// 자바</span>
<span class='kt'>void</span> <span class='nf'>f</span><span class='o'>(</span><span class='n'>String</span> <span class='n'>a</span><span class='o'>,</span> <span class='kt'>int</span> <span class='n'>b</span><span class='o'>,</span> <span class='n'>String</span> <span class='n'>c</span><span class='o'>)</span> <span class='o'>{</span> <span class='o'>}</span>
<span class='kt'>void</span> <span class='nf'>f</span><span class='o'>(</span><span class='n'>String</span> <span class='n'>a</span><span class='o'>,</span> <span class='kt'>int</span> <span class='n'>b</span><span class='o'>)</span> <span class='o'>{</span> <span class='o'>}</span>
<span class='kt'>void</span> <span class='nf'>f</span><span class='o'>(</span><span class='n'>String</span> <span class='n'>a</span><span class='o'>)</span> <span class='o'>{</span> <span class='o'>}</span></code></pre><p>생성자와 정적 메서드에도 이 애노테이션을 적용할 수 있다. 인터페이스에 정의한 메서드를 포함해서 추상 메서드에는 사용할 수 없다.</p><p><a href='#classes.html%23secondary-constructors'>보조 생성자</a>에서 설명한 것처럼, 클래스가 모든 생성자 파라미터에 대해 기본 값을 가지면
인자 없는 public 생성자를 생성한다.
이는 @JvmOverloads 애노테이션을 지정하지 않아도 적용된다.</p><h3 id='java-to-kotlin-interop.html_section-7'>체크드 익셉션<a class='anchor' href='#%23section-7'> </a></h3><p>코틀린에는 체크드 익셉션이 없다.
따라서 보통은 코틀린 함수의 자바 시그너처는 익셉션을 선언하지 않는다.
다음과 같은 코틀린 함수를 가졌다고 해보자:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='c1'>// example.kt</span>
<span class='k'>package</span> <span class='nn'>demo</span>

<span class='k'>fun</span> <span class='nf'>foo</span><span class='p'>()</span> <span class='p'>{</span>
  <span class='k'>throw</span> <span class='n'>IOException</span><span class='p'>()</span>
<span class='p'>}</span></code></pre><p>그리고 자바에서 위 함수를 호출할 때 익셉션을 catch하고 싶다고 하자:</p><pre><code class='code-block _highlighted lang_java'><span class='c1'>// 자바</span>
<span class='k'>try</span> <span class='o'>{</span>
  <span class='n'>demo</span><span class='o'>.</span><span class='na'>Example</span><span class='o'>.</span><span class='na'>foo</span><span class='o'>();</span>
<span class='o'>}</span>
<span class='k'>catch</span> <span class='o'>(</span><span class='n'>IOException</span> <span class='n'>e</span><span class='o'>)</span> <span class='o'>{</span> <span class='c1'>// 에러: foo()는 throws 목록에 IOException을 선언하지 않았다</span>
  <span class='c1'>// ...</span>
<span class='o'>}</span></code></pre><p><code>foo()</code>가 <code>IOException</code>을 선언하고 있지 않으므로 자바 컴파일러는 에러를 발생한다.
이 문제를 피하려면 코틀린 코드에 <code>@Throws</code> 애노테이션을 사용하면 된다.</p><pre><code class='code-block _highlighted lang_kotlin'><span class='n'>@Throws</span><span class='p'>(</span><span class='n'>IOException</span><span class='o'>::</span><span class='k'>class</span><span class='p'>)</span>
<span class='k'>fun</span> <span class='nf'>foo</span><span class='p'>()</span> <span class='p'>{</span>
    <span class='k'>throw</span> <span class='n'>IOException</span><span class='p'>()</span>
<span class='p'>}</span></code></pre><h3 id='java-to-kotlin-interop.html_null-'>Null-안전성<a class='anchor' href='#%23null-'> </a></h3><p>자바에서 코틀린 함수를 호출할 때 non-null 파라미터에 <em class='keyword'>null</em>을 전달하는 것을 막을 수가 없다.
이런 이유로 코틀린은 non-null을 요구하는 모든 public 함수에 대해 런타임 검사를 추가한다.
이것이 자바 코드에서 즉시 <code>NullPointerException</code>을 얻는 방법이다.</p><h3 id='java-to-kotlin-interop.html_variant-'>기변(Variant) 지네릭<a class='anchor' href='#%23variant-'> </a></h3><p>코틀린이 <a href='#generics.html%23declaration-site-variance'>선언-위치 가변</a>을 사용하면,
자바 코드에서 이를 사용하는 두 가지 선택이 있다. 다음 클래스와 이 클래스를 사용하는 두 함수를 보자:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>class</span> <span class='nc'>Box</span><span class='p'>&lt;</span><span class='k'>out</span> <span class='n'>T</span><span class='p'>&gt;(</span><span class='k'>val</span> <span class='py'>value</span><span class='p'>:</span> <span class='n'>T</span><span class='p'>)</span>

<span class='n'>interface</span> <span class='n'>Base</span>
<span class='k'>class</span> <span class='nc'>Derived</span> <span class='p'>:</span> <span class='n'>Base</span>

<span class='k'>fun</span> <span class='nf'>boxDerived</span><span class='p'>(</span><span class='n'>value</span><span class='p'>:</span> <span class='n'>Derived</span><span class='p'>):</span> <span class='n'>Box</span><span class='p'>&lt;</span><span class='n'>Derived</span><span class='p'>&gt;</span> <span class='p'>=</span> <span class='n'>Box</span><span class='p'>(</span><span class='n'>value</span><span class='p'>)</span>
<span class='k'>fun</span> <span class='nf'>unboxBase</span><span class='p'>(</span><span class='n'>box</span><span class='p'>:</span> <span class='n'>Box</span><span class='p'>&lt;</span><span class='n'>Base</span><span class='p'>&gt;):</span> <span class='n'>Base</span> <span class='p'>=</span> <span class='n'>box</span><span class='p'>.</span><span class='n'>value</span></code></pre><p>이 함수를 자바로 변환하는 가장 단순한 방법은 다음과 같다:</p><pre><code class='code-block _highlighted lang_java'><span class='n'>Box</span><span class='o'>&lt;</span><span class='n'>Derived</span><span class='o'>&gt;</span> <span class='nf'>boxDerived</span><span class='o'>(</span><span class='n'>Derived</span> <span class='n'>value</span><span class='o'>)</span> <span class='o'>{</span> <span class='o'>...</span> <span class='o'>}</span>
<span class='n'>Base</span> <span class='nf'>unboxBase</span><span class='o'>(</span><span class='n'>Box</span><span class='o'>&lt;</span><span class='n'>Base</span><span class='o'>&gt;</span> <span class='n'>box</span><span class='o'>)</span> <span class='o'>{</span> <span class='o'>...</span> <span class='o'>}</span></code></pre><p>문제는 코틀린에서는 <code>unboxBase(boxDerived("s"))</code>가 가능하지만 자바에서는 가능하지 않다는 것이다.
왜냐면 자바에서 <code>Box</code> 클래스는 <code>T</code> 파라미터에 대해 <em>무공변(invariant)</em>이라서 <code>Box&lt;Derived&gt;</code>가 <code>Box&lt;Base&gt;</code>의 하위타입이 아니기 때문이다.
자바에서 이게 동작하도록 하려면 <code>unboxBase</code>를 다음과 같이 정의해야 한다:</p><pre><code class='code-block _highlighted lang_java'><span class='n'>Base</span> <span class='nf'>unboxBase</span><span class='o'>(</span><span class='n'>Box</span><span class='o'>&lt;?</span> <span class='kd'>extends</span> <span class='n'>Base</span><span class='o'>&gt;</span> <span class='n'>box</span><span class='o'>)</span> <span class='o'>{</span> <span class='o'>...</span> <span class='o'>}</span></code></pre><p>여기서 사용-위치 가변(use-site variance)을 이용해서 선언-위치 가변(declaration-site variance)을 흉내내기 위해
자바의 <em>와일드카드 타입</em>(<code>? extends Base</code>)을 사용했다. 왜냐면 자바로는 이렇게밖에 못하기 때문이다.</p><p>코틀린 API를 자바에서 쓸 수 있게 하기 위해 파라미터로 쓰이는 <code>Box&lt;Super&gt;</code>를 (공변으로 정의한 Box인) <code>Box&lt;? extends Super&gt;</code>로 생성한다(또는 반공변으로 정의한 Foo인 <code>Foo&lt;? super Bar&gt;</code>로 생성).
그것이 리턴 값이면 와일드카드를 생성하지 않는다. 그렇지 않을 경우 자바 클라이언트가 그것을 처리해야 하기 때문이다(그리고 이는 보통의 자바 코딩 방식과 반대된다).
따라서 위 예의 함수는 실제로 다음과 같이 번역된다:</p><pre><code class='code-block _highlighted lang_java'><span class='c1'>// 리턴 타입 - 와일드카드 없음</span>
<span class='n'>Box</span><span class='o'>&lt;</span><span class='n'>Derived</span><span class='o'>&gt;</span> <span class='nf'>boxDerived</span><span class='o'>(</span><span class='n'>Derived</span> <span class='n'>value</span><span class='o'>)</span> <span class='o'>{</span> <span class='o'>...</span> <span class='o'>}</span>

<span class='c1'>// 파라미터 - 와일드카드</span>
<span class='n'>Base</span> <span class='nf'>unboxBase</span><span class='o'>(</span><span class='n'>Box</span><span class='o'>&lt;?</span> <span class='kd'>extends</span> <span class='n'>Base</span><span class='o'>&gt;</span> <span class='n'>box</span><span class='o'>)</span> <span class='o'>{</span> <span class='o'>...</span> <span class='o'>}</span></code></pre><p>노트: 인지 타입이 final이면, 보통 와일드카드를 생성해도 얻는게 없기 때문에 <code>Box&lt;String&gt;</code>은 인자 위치에 상관없이 항상 <code>Box&lt;String&gt;</code>이다.</p><p>기본적으로 와일드카드를 생성할 수 없는 곳에서 와일드카드가 필요하면 <code>@JvmWildcard</code> 애노테이션을 사용할 수 있다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>boxDerived</span><span class='p'>(</span><span class='n'>value</span><span class='p'>:</span> <span class='n'>Derived</span><span class='p'>):</span> <span class='n'>Box</span><span class='p'>&lt;</span><span class='n'>@JvmWildcard</span> <span class='n'>Derived</span><span class='p'>&gt;</span> <span class='p'>=</span> <span class='n'>Box</span><span class='p'>(</span><span class='n'>value</span><span class='p'>)</span>
<span class='c1'>// 다음으로 번역</span>
<span class='c1'>// Box&lt;? extends Derived&gt; boxDerived(Derived value) { ... }</span></code></pre><p>반면에 와일드카드 생성이 필요 없으면 <code>@JvmSuppressWildcards</code>를 사용한다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>unboxBase</span><span class='p'>(</span><span class='n'>box</span><span class='p'>:</span> <span class='n'>Box</span><span class='p'>&lt;</span><span class='n'>@JvmSuppressWildcards</span> <span class='n'>Base</span><span class='p'>&gt;):</span> <span class='n'>Base</span> <span class='p'>=</span> <span class='n'>box</span><span class='p'>.</span><span class='n'>value</span>
<span class='c1'>// 다음으로 번역</span>
<span class='c1'>// Base unboxBase(Box&lt;Base&gt; box) { ... }</span></code></pre><p>노트: <code>@JvmSuppressWildcards</code>을 개별 타입 인자에만 사용할 수 있는 것은 아니다. 함수나 클래스처럼 전체 선언에도 사용할 수 있다. 이는 선언 안의 모든 와일드카드를 제한한다.</p><h4 id='java-to-kotlin-interop.html_nothing--'>Nothing 타입의 번역<a class='anchor' href='#%23nothing--'> </a></h4><p><code>Nothing</code> 타입은 특별하다. 왜냐면 자바에 이와 딱들어맞는 요소가 없기 때문이다. 사실 <code>java.lang.Void</code>를 포함한 모든 자바 레퍼런스 타입은
값으로 <code>null</code>을 가질 수 있는데 <code>Nothing</code>은 그것조차 안 된다. 따라서 자바에서 이 타입을 완벽하게 표현할 수는 없다.
이것이 코틀린이 <code>Nothing</code> 타입을 사용하는 인자에 raw 타입을 생성하는 이유이다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='k'>fun</span> <span class='nf'>emptyList</span><span class='p'>():</span> <span class='n'>List</span><span class='p'>&lt;</span><span class='n'>Nothing</span><span class='p'>&gt;</span> <span class='p'>=</span> <span class='n'>listOf</span><span class='p'>()</span>
<span class='c1'>// is translated to</span>
<span class='c1'>// List emptyList() { ... }</span></code></pre>
              </article>
          

        </section>
    

    
        <section>
          <h1 id="%EB%8F%84%EA%B5%AC"
              class="section-title">
            도구
          </h1>

          
              <article id="kotlin-doc.html" class="page-content">
                <h2 id='kotlin-doc.html_section'>코틀린 코드 문서화<a class='anchor' href='#%23section'> </a></h2><p>코틀린 코드를 문서화하기 위해 사용하는 언어를 <strong>KDoc</strong>이라 한다. 이것의 핵심은 블록 태그를 위한 Javadoc 구문(코틀린에 맞는 요소를 지원하기 위해 확장)과 인라인 마크업을 위해 마크다운을 조합한 것이다.</p><h3 id='kotlin-doc.html_section-1'>문서 생성하기<a class='anchor' href='#%23section-1'> </a></h3><p><a href='#https%3A%2F%2Fgithub.com%2FKotlin%2Fdokka'>Dokka</a>라는 도구를 이용해서 코틀린 문서를 생성한다.
사용법은 <a href='#https%3A%2F%2Fgithub.com%2FKotlin%2Fdokka%2Fblob%2Fmaster%2FREADME.md'>Dokka README</a> 문서를 참고한다.</p><p>Dokka는 그래들, 메이븐, 앤트 플러그인을 갖고 있어서 빌드 과정에 문서 생성을 통합할 수 있다.</p><h3 id='kotlin-doc.html_kdoc-'>KDoc 구문<a class='anchor' href='#%23kdoc-'> </a></h3><p>JavaDoc처럼 KDoc 주석도 <code>/**</code>로 시작해서 <code>*/</code>로 끝난다. 모든 주석 줄은 애스터리크(*)를 포함할 수 있지만 애스터리크는 주석 내용에 포함되진 않는다.</p><p>보통 주석 내용의 첫 번째 단락(첫 번째 빈 행이 올 때까지)에는 요소의 요약 설명을 넣고 자세한 내용은 그 뒤에 넣는다.</p><p>모든 블록 태그는 새 줄에서 <code>@</code> 문자로 시작한다.</p><p>다음은 KDoc을 이용해서 클래스를 문서화한 예이다:</p><pre><code class='code-block _highlighted lang_kotlin'><span class='cm'>/**</span>
<span class='cm'> * A group of *members*.</span>
<span class='cm'> *</span>
<span class='cm'> * This class has no useful logic; it&#39;s just a documentation example.</span>
<span class='cm'> *</span>
<span class='cm'> * @param T the type of a member in this group.</span>
<span class='cm'> * @property name the name of this group.</span>
<span class='cm'> * @constructor Creates an empty group.</span>
<span class='cm'> */</span>
<span class='k'>class</span> <span class='nc'>Group</span><span class='p'>&lt;</span><span class='n'>T</span><span class='p'>&gt;(</span><span class='k'>val</span> <span class='py'>name</span><span class='p'>:</span> <span class='n'>String</span><span class='p'>)</span> <span class='p'>{</span>
    <span class='cm'>/**</span>
<span class='cm'>     * Adds a [member] to this group.</span>
<span class='cm'>     * @return the new size of the group.</span>
<span class='cm'>     */</span>
    <span class='k'>fun</span> <span class='nf'>add</span><span class='p'>(</span><span class='n'>member</span><span class='p'>:</span> <span class='n'>T</span><span class='p'>):</span> <span class='n'>Int</span> <span class='p'>{</span> <span class='p'>...</span> <span class='p'>}</span>
<span class='p'>}</span></code></pre><h3 id='kotlin-doc.html_section-2'>블록 태그<a class='anchor' href='#%23section-2'> </a></h3><p>현재 KDoc은 다음 블록 태그를 지원한다:</p><h5 id='kotlin-doc.html_param-name'><code>@param &lt;name&gt;</code></h5><p>함수의 파라미터나 클래스의 타입 파라미터 값을 문서화한다.
설명과 파라미터 이름을 더 잘 구분하고 싶다면 파라미터 이름을 대괄호로 둘러쌀 수 있다.
그래서 다음 두 구문은 동일하다:</p><pre>@param name description.
@param[name] description.
</pre><h5 id='kotlin-doc.html_return'><code>@return</code></h5><p>함수의 리턴 값을 문서화한다.</p><h5 id='kotlin-doc.html_constructor'><code>@constructor</code></h5><p>클래스의 주요 생성자를 문서화한다.</p><h5 id='kotlin-doc.html_property-name'><code>@property &lt;name&gt;</code></h5><p>지정한 이름을 가진 클래스의 프로퍼티를 문서화한다. 주요 생성자에 선언한 (프로퍼티 정의 앞에 주석을 직접 넣는게 어색한)
프로퍼티를 문서화하는데 이 태그를 사용할 수 있다.</p><h5 id='kotlin-doc.html_throws-class-exception-class'><code>@throws &lt;class&gt;</code>, <code>@exception &lt;class&gt;</code></h5><p>메서드가 발생할 수 있는 익셉션을 문서화한다. 코틀린에는 체크드 익셉션이 없기 때문에
발생 가능한 모든 익셉션을 문서화할 것이라고 기대하진 않는다. 하지만 클래스 사용자에게 익셉션에 대한 정보가 유용하면
이 태그를 사용하면 된다.</p><h5 id='kotlin-doc.html_sample-identifier'><code>@sample &lt;identifier&gt;</code></h5><p>지정한 이름을 가진 함수의 몸체를 현재 요소의 문서화 결과에 삽입한다.
해당 요소를 어떻게 사용하는지 예를 보여주기 위한 용도로 사용한다.</p><h5 id='kotlin-doc.html_see-identifier'><code>@see &lt;identifier&gt;</code></h5><p>문서의 <strong>See Also</strong> 블록에 지정한 클래스나 메서드에 대한 링크를 추가한다.</p><h5 id='kotlin-doc.html_author'><code>@author</code></h5><p>문서화 대상 요소의 작성자를 지정한다.</p><h5 id='kotlin-doc.html_since'><code>@since</code></h5><p>문서화 대상 요소를 추가한 소프트웨어 버전을 지정한다.</p><h5 id='kotlin-doc.html_suppress'><code>@suppress</code></h5><p>문서 생성 대상에서 요소를 제외한다. 모듈의 공식 API에 포함은 되지 않지만 외부에 노출해야 하는 요소를 문서화할 때 사용할 수 있다.</p><blockquote class='note'>
  <p>KDoc은 <code>@deprecated</code>를 지원하지 않는다. 대신 <code>@Deprecated</code>를 사용해야 한다.</p>
</blockquote><h3 id='kotlin-doc.html_section-3'>인라인 마크업<a class='anchor' href='#%23section-3'> </a></h3><p>인라인 마크업을 위해 KDoc은 정규 <a href='#http%3A%2F%2Fdaringfireball.net%2Fprojects%2Fmarkdown%2Fsyntax'>Markdown</a> 구문을 사용하며
코드에 있는 다른 요소에 링크하기 위한 약식 구문 지원을 확장했다.</p><h4 id='kotlin-doc.html_section-4'>요소에 링크하기<a class='anchor' href='#%23section-4'> </a></h4><p>다른 요소(클래스, 메서드, 프로퍼티 또는 파라미터)에 링크하려면 단순히 대괄호 안에 이름을 넣으면 된다:</p><pre>Use the method [foo] for this purpose.
</pre><p>링크에 커스텀 라벨을 지정하고 싶다면 마크다운의 레퍼런스-스타일 구문을 사용한다:</p><pre>Use [this method][foo] for this purpose.
</pre><p>링크에 전체 이름을 사용할 수도 있다. JavaDoc과 달리 전체 이름은 항상 컴포넌트를 구분할 때 점 문자를 사용해야 하며, 이는 메서드 이름 전이라도 마찬가지다:</p><pre>Use [kotlin.reflect.KClass.properties] to enumerate the properties of the class.
</pre><p>링크에 있는 이름을 해석할 때에는 문서화할 대상 안에서 사용할 이름과 같은 규칙을 사용한다.
특히, 이는 현재 파일에 이름을 임포트하면 KDoc 주석에서 그 이름을 사용할 때 완전한 이름을 사용할 필요가 없다는 것을 뜻한다.</p><p>KDoc은 링크에서 오버로딩한 멤버를 찾기 위한 별도 구문을 제공하지 않는다. 코틀린 문서 생성 도구는
같은 페이지에 있는 모든 오버로딩 함수를 문서화에 넣기 때문에, 오버로딩한 함수 중에서 링크 적용 대상을 식별할 필요가 없다.</p>
              </article>
          
              <article id="using-maven.html" class="page-content">
                <h2 id='using-maven.html_section'>메이븐 사용하기<a class='anchor' href='#%23section'> </a></h2><h3 id='using-maven.html_section-1'>플러그인과 버전<a class='anchor' href='#%23section-1'> </a></h3><p><em>kotlin-maven-plugin</em>은 코틀린 소스와 모듈을 컴파일한다. 현재는 메이븐 v3만 지원한다.</p><p><em>kotlin.version</em>으로 사용할 코틀린 버전을 정의한다. 코틀린 릴리즈와 버전 간의 관계를 아래 표시했다:</p><table>
<thead>
<tr>
  <th>Milestone</th>
  <th>Version</th>
</tr>
</thead>
<tbody>

<tr>
  <td>1.0.1 hotfix update 2</td>
  <td>1.0.1-2</td>
</tr>

<tr>
  <td>1.0.1 hotfix update</td>
  <td>1.0.1-1</td>
</tr>

<tr>
  <td>1.0.1</td>
  <td>1.0.1</td>
</tr>

<tr>
  <td>1.0 GA</td>
  <td>1.0.0</td>
</tr>

<tr>
  <td>Release Candidate</td>
  <td>1.0.0-rc-1036</td>
</tr>

<tr>
  <td>Beta 4</td>
  <td>1.0.0-beta-4589</td>
</tr>

<tr>
  <td>Beta 3</td>
  <td>1.0.0-beta-3595</td>
</tr>

<tr>
  <td>Beta 2</td>
  <td>1.0.0-beta-2423</td>
</tr>

<tr>
  <td>Beta</td>
  <td>1.0.0-beta-1103</td>
</tr>

<tr>
  <td>Beta Candidate</td>
  <td>1.0.0-beta-1038</td>
</tr>

<tr>
  <td>M14</td>
  <td>0.14.449</td>
</tr>

<tr>
  <td>M13</td>
  <td>0.13.1514</td>
</tr>

<tr>
  <td>M12.1</td>
  <td>0.12.613</td>
</tr>

<tr>
  <td>M12</td>
  <td>0.12.200</td>
</tr>

<tr>
  <td>M11.1</td>
  <td>0.11.91.1</td>
</tr>

<tr>
  <td>M11</td>
  <td>0.11.91</td>
</tr>

<tr>
  <td>M10.1</td>
  <td>0.10.195</td>
</tr>

<tr>
  <td>M10</td>
  <td>0.10.4</td>
</tr>

<tr>
  <td>M9</td>
  <td>0.9.66</td>
</tr>

<tr>
  <td>M8</td>
  <td>0.8.11</td>
</tr>

<tr>
  <td>M7</td>
  <td>0.7.270</td>
</tr>

<tr>
  <td>M6.2</td>
  <td>0.6.1673</td>
</tr>

<tr>
  <td>M6.1</td>
  <td>0.6.602</td>
</tr>

<tr>
  <td>M6</td>
  <td>0.6.69</td>
</tr>

<tr>
  <td>M5.3</td>
  <td>0.5.998</td>
</tr>

</tbody>
</table><h3 id='using-maven.html_section-2'>의존<a class='anchor' href='#%23section-2'> </a></h3><p>코틀린은 애플리케이션이 사용할 수 있는 방대한 표준 라이브러리를 갖고 있다.
pom 파일에 다음 의존을 설정한다.</p><pre><code class='code-block _highlighted lang_xml'><span class='nt'>&lt;dependencies&gt;</span>
    <span class='nt'>&lt;dependency&gt;</span>
        <span class='nt'>&lt;groupId&gt;</span>org.jetbrains.kotlin<span class='nt'>&lt;/groupId&gt;</span>
        <span class='nt'>&lt;artifactId&gt;</span>kotlin-stdlib<span class='nt'>&lt;/artifactId&gt;</span>
        <span class='nt'>&lt;version&gt;</span>${kotlin.version}<span class='nt'>&lt;/version&gt;</span>
    <span class='nt'>&lt;/dependency&gt;</span>
<span class='nt'>&lt;/dependencies&gt;</span></code></pre><h3 id='using-maven.html_section-3'>코틀린 소스 코드만 컴파일하기<a class='anchor' href='#%23section-3'> </a></h3><p>소스 코드를 컴파일하려면 <build> 태그에 소스 디렉토리를 지정한다:</build></p><pre><code class='code-block _highlighted lang_xml'><span class='nt'>&lt;sourceDirectory&gt;</span>${project.basedir}/src/main/kotlin<span class='nt'>&lt;/sourceDirectory&gt;</span>
<span class='nt'>&lt;testSourceDirectory&gt;</span>${project.basedir}/src/test/kotlin<span class='nt'>&lt;/testSourceDirectory&gt;</span></code></pre><p>코틀린 메이븐 플러그인에 소스 컴파일을 참조해야 한다:</p><pre><code class='code-block _highlighted lang_xml'><span class='nt'>&lt;plugin&gt;</span>
    <span class='nt'>&lt;artifactId&gt;</span>kotlin-maven-plugin<span class='nt'>&lt;/artifactId&gt;</span>
    <span class='nt'>&lt;groupId&gt;</span>org.jetbrains.kotlin<span class='nt'>&lt;/groupId&gt;</span>
    <span class='nt'>&lt;version&gt;</span>${kotlin.version}<span class='nt'>&lt;/version&gt;</span>

    <span class='nt'>&lt;executions&gt;</span>
        <span class='nt'>&lt;execution&gt;</span>
            <span class='nt'>&lt;id&gt;</span>compile<span class='nt'>&lt;/id&gt;</span>
            <span class='nt'>&lt;goals&gt;</span> <span class='nt'>&lt;goal&gt;</span>compile<span class='nt'>&lt;/goal&gt;</span> <span class='nt'>&lt;/goals&gt;</span>
        <span class='nt'>&lt;/execution&gt;</span>

        <span class='nt'>&lt;execution&gt;</span>
            <span class='nt'>&lt;id&gt;</span>test-compile<span class='nt'>&lt;/id&gt;</span>
            <span class='nt'>&lt;goals&gt;</span> <span class='nt'>&lt;goal&gt;</span>test-compile<span class='nt'>&lt;/goal&gt;</span> <span class='nt'>&lt;/goals&gt;</span>
        <span class='nt'>&lt;/execution&gt;</span>
    <span class='nt'>&lt;/executions&gt;</span>
<span class='nt'>&lt;/plugin&gt;</span></code></pre><h3 id='using-maven.html_section-4'>코틀린과 자바 소스 컴파일하기<a class='anchor' href='#%23section-4'> </a></h3><p>자바와 코틀린을 함께 사용하는 애플리케이션 코드를 컴파일하려면 자바 컴파일러 전에 코틀린 컴파일을 실행해야 한다.
메이븐에서는 maven-compiler-plugin 전에 kotlin-maven-plugin를 실행해야 함을 의미한다.</p><p>코틀린 컴파일을 실행하려면 코틀린 컴파일 과정을 이전 단계인 process-sources로 옮기면 된다(더 나은 방법을 알고 있다면 자유롭게 제안해 달라):</p><pre><code class='code-block _highlighted lang_xml'><span class='nt'>&lt;plugin&gt;</span>
    <span class='nt'>&lt;artifactId&gt;</span>kotlin-maven-plugin<span class='nt'>&lt;/artifactId&gt;</span>
    <span class='nt'>&lt;groupId&gt;</span>org.jetbrains.kotlin<span class='nt'>&lt;/groupId&gt;</span>
    <span class='nt'>&lt;version&gt;</span>${kotlin.version}<span class='nt'>&lt;/version&gt;</span>

    <span class='nt'>&lt;executions&gt;</span>
        <span class='nt'>&lt;execution&gt;</span>
            <span class='nt'>&lt;id&gt;</span>compile<span class='nt'>&lt;/id&gt;</span>
            <span class='nt'>&lt;phase&gt;</span>process-sources<span class='nt'>&lt;/phase&gt;</span>
            <span class='nt'>&lt;goals&gt;</span> <span class='nt'>&lt;goal&gt;</span>compile<span class='nt'>&lt;/goal&gt;</span> <span class='nt'>&lt;/goals&gt;</span>
        <span class='nt'>&lt;/execution&gt;</span>

        <span class='nt'>&lt;execution&gt;</span>
            <span class='nt'>&lt;id&gt;</span>test-compile<span class='nt'>&lt;/id&gt;</span>
            <span class='nt'>&lt;phase&gt;</span>process-test-sources<span class='nt'>&lt;/phase&gt;</span>
            <span class='nt'>&lt;goals&gt;</span> <span class='nt'>&lt;goal&gt;</span>test-compile<span class='nt'>&lt;/goal&gt;</span> <span class='nt'>&lt;/goals&gt;</span>
        <span class='nt'>&lt;/execution&gt;</span>
    <span class='nt'>&lt;/executions&gt;</span>
<span class='nt'>&lt;/plugin&gt;</span></code></pre><h3 id='using-maven.html_osgi'>OSGi<a class='anchor' href='#%23osgi'> </a></h3><p>OSGi에 대한 지원은 <a href='#kotlin-osgi.html'>Kotlin OSGi 페이지</a>를 참고한다.</p><h3 id='using-maven.html_section-5'>예제<a class='anchor' href='#%23section-5'> </a></h3><p>모든 메이븐 프로젝트 예제는 <a href='#https%3A%2F%2Fgithub.com%2FJetBrains%2Fkotlin-examples%2Farchive%2Fmaster%2Fmaven.zip'>GitHub 리포지토리에 직접 다운로드</a>할 수 있다.</p>
              </article>
          
              <article id="using-ant.html" class="page-content">
                <h2 id='using-ant.html_section'>앤트 사용하기<a class='anchor' href='#%23section'> </a></h2><h3 id='using-ant.html_section-1'>앤트 태스크 얻기<a class='anchor' href='#%23section-1'> </a></h3><p>코틀린은 세 개의 앤트 태스크를 제공한다:</p><ul>
  <li>kotlinc: JVM 대상 한 코틀린 컴파일러</li>
  <li>kotlin2js: 자바스크립트 대상 코틀린 컴파일러</li>
  <li>withKotlin: 표준 <em>javac</em> 앤트 태크스를 사용할 때 코틀린 파일을 컴파일하는 태스크</li>
</ul><p><a href='#https%3A%2F%2Fgithub.com%2FJetBrains%2Fkotlin%2Freleases%2Ftag%2F1.0.1-2'>코틀린 컴파일러</a>의 <em>lib</em> 폴더에 위치한 <em>kotlin-ant.jar</em> 라이브러리에 이 태스크가 정의되어 있다.</p><h3 id='using-ant.html_jvm----'>JVM 대상으로 코틀린 소스만 컴파일하기<a class='anchor' href='#%23jvm----'> </a></h3><p>프로젝트가 코틀린 소스 코드로만 구성되어 있을 때 프로젝트를 컴파일하는 가장 쉬운 방법은 <em>kotlinc</em> 태스크를 사용하는 것이다.</p><pre><code class='code-block _highlighted lang_xml'><span class='nt'>&lt;project</span> <span class='na'>name=</span><span class='s'>&quot;Ant Task Test&quot;</span> <span class='na'>default=</span><span class='s'>&quot;build&quot;</span><span class='nt'>&gt;</span>
    <span class='nt'>&lt;typedef</span> <span class='na'>resource=</span><span class='s'>&quot;org/jetbrains/kotlin/ant/antlib.xml&quot;</span> <span class='na'>classpath=</span><span class='s'>&quot;${kotlin.lib}/kotlin-ant.jar&quot;</span><span class='nt'>/&gt;</span>

    <span class='nt'>&lt;target</span> <span class='na'>name=</span><span class='s'>&quot;build&quot;</span><span class='nt'>&gt;</span>
        <span class='nt'>&lt;kotlinc</span> <span class='na'>src=</span><span class='s'>&quot;hello.kt&quot;</span> <span class='na'>output=</span><span class='s'>&quot;hello.jar&quot;</span><span class='nt'>/&gt;</span>
    <span class='nt'>&lt;/target&gt;</span>
<span class='nt'>&lt;/project&gt;</span></code></pre><p>${kotlin.lib}는 코틀린 표준 컴파일러의 압축을 푼 폴더를 가리킨다.</p><h3 id='using-ant.html_jvm-------'>JVM 대상으로 여러 루트를 갖는 코틀린 소스만 컴파일하기<a class='anchor' href='#%23jvm-------'> </a></h3><p>프로젝트가 여러 소스 루트를 가지면 <em>src</em> 요소를 사용해서 경로를 정의한다.</p><pre><code class='code-block _highlighted lang_xml'><span class='nt'>&lt;project</span> <span class='na'>name=</span><span class='s'>&quot;Ant Task Test&quot;</span> <span class='na'>default=</span><span class='s'>&quot;build&quot;</span><span class='nt'>&gt;</span>
    <span class='nt'>&lt;typedef</span> <span class='na'>resource=</span><span class='s'>&quot;org/jetbrains/kotlin/ant/antlib.xml&quot;</span> <span class='na'>classpath=</span><span class='s'>&quot;${kotlin.lib}/kotlin-ant.jar&quot;</span><span class='nt'>/&gt;</span>

    <span class='nt'>&lt;target</span> <span class='na'>name=</span><span class='s'>&quot;build&quot;</span><span class='nt'>&gt;</span>
        <span class='nt'>&lt;kotlinc</span> <span class='na'>output=</span><span class='s'>&quot;hello.jar&quot;</span><span class='nt'>&gt;</span>
            <span class='nt'>&lt;src</span> <span class='na'>path=</span><span class='s'>&quot;root1&quot;</span><span class='nt'>/&gt;</span>
            <span class='nt'>&lt;src</span> <span class='na'>path=</span><span class='s'>&quot;root2&quot;</span><span class='nt'>/&gt;</span>
        <span class='nt'>&lt;/kotlinc&gt;</span>
    <span class='nt'>&lt;/target&gt;</span>
<span class='nt'>&lt;/project&gt;</span></code></pre><h3 id='using-ant.html_jvm------'>JVM 대상으로 코틀린과 자바 소스가 함께 컴파일하기<a class='anchor' href='#%23jvm------'> </a></h3><p>프로젝트에 코틀린과 자바 소스 코드가 함께 있다면 <em>kotlinc</em>를 사용할 수도 있지만,
태스크 파라미터 중복을 피하기 위해 <em>withKotlin</em> 태스크를 사용할 것을 권한다.</p><pre><code class='code-block _highlighted lang_xml'><span class='nt'>&lt;project</span> <span class='na'>name=</span><span class='s'>&quot;Ant Task Test&quot;</span> <span class='na'>default=</span><span class='s'>&quot;build&quot;</span><span class='nt'>&gt;</span>
    <span class='nt'>&lt;typedef</span> <span class='na'>resource=</span><span class='s'>&quot;org/jetbrains/kotlin/ant/antlib.xml&quot;</span> <span class='na'>classpath=</span><span class='s'>&quot;${kotlin.lib}/kotlin-ant.jar&quot;</span><span class='nt'>/&gt;</span>

    <span class='nt'>&lt;target</span> <span class='na'>name=</span><span class='s'>&quot;build&quot;</span><span class='nt'>&gt;</span>
        <span class='nt'>&lt;delete</span> <span class='na'>dir=</span><span class='s'>&quot;classes&quot;</span> <span class='na'>failonerror=</span><span class='s'>&quot;false&quot;</span><span class='nt'>/&gt;</span>
        <span class='nt'>&lt;mkdir</span> <span class='na'>dir=</span><span class='s'>&quot;classes&quot;</span><span class='nt'>/&gt;</span>
        <span class='nt'>&lt;javac</span> <span class='na'>destdir=</span><span class='s'>&quot;classes&quot;</span> <span class='na'>includeAntRuntime=</span><span class='s'>&quot;false&quot;</span> <span class='na'>srcdir=</span><span class='s'>&quot;src&quot;</span><span class='nt'>&gt;</span>
            <span class='nt'>&lt;withKotlin/&gt;</span>
        <span class='nt'>&lt;/javac&gt;</span>
        <span class='nt'>&lt;jar</span> <span class='na'>destfile=</span><span class='s'>&quot;hello.jar&quot;</span><span class='nt'>&gt;</span>
            <span class='nt'>&lt;fileset</span> <span class='na'>dir=</span><span class='s'>&quot;classes&quot;</span><span class='nt'>/&gt;</span>
        <span class='nt'>&lt;/jar&gt;</span>
    <span class='nt'>&lt;/target&gt;</span>
<span class='nt'>&lt;/project&gt;</span></code></pre><p><code>&lt;withKotlin&gt;</code>에 추가 명령행 인자를 지정하려면 <code>&lt;compilerArg&gt;</code> 파라미터를 사용하면 된다.
<code>kotlinc -help</code>로 사용할 수 있는 전체 인자 목록을 볼 수 있다.
<code>moduleName</code> 애트리뷰로 컴파일 할 모듈 이름을 지정할 수 있다:</p><pre><code class='code-block _highlighted lang_xml'><span class='nt'>&lt;withKotlin</span> <span class='na'>moduleName=</span><span class='s'>&quot;myModule&quot;</span><span class='nt'>&gt;</span>
    <span class='nt'>&lt;compilerarg</span> <span class='na'>value=</span><span class='s'>&quot;-no-stdlib&quot;</span><span class='nt'>/&gt;</span>
<span class='nt'>&lt;/withKotlin&gt;</span></code></pre><h3 id='using-ant.html_section-2'>자바 스크립트 대상으로 한 개 소스 폴더를 컴파일하기<a class='anchor' href='#%23section-2'> </a></h3><pre><code class='code-block _highlighted lang_xml'><span class='nt'>&lt;project</span> <span class='na'>name=</span><span class='s'>&quot;Ant Task Test&quot;</span> <span class='na'>default=</span><span class='s'>&quot;build&quot;</span><span class='nt'>&gt;</span>
    <span class='nt'>&lt;typedef</span> <span class='na'>resource=</span><span class='s'>&quot;org/jetbrains/kotlin/ant/antlib.xml&quot;</span> <span class='na'>classpath=</span><span class='s'>&quot;${kotlin.lib}/kotlin-ant.jar&quot;</span><span class='nt'>/&gt;</span>

    <span class='nt'>&lt;target</span> <span class='na'>name=</span><span class='s'>&quot;build&quot;</span><span class='nt'>&gt;</span>
        <span class='nt'>&lt;kotlin2js</span> <span class='na'>src=</span><span class='s'>&quot;root1&quot;</span> <span class='na'>output=</span><span class='s'>&quot;out.js&quot;</span><span class='nt'>/&gt;</span>
    <span class='nt'>&lt;/target&gt;</span>
<span class='nt'>&lt;/project&gt;</span></code></pre><h3 id='using-ant.html_prefix-postfix--sourcemap--'>자바 스크립트 대상으로 prefix, postfix, 그리고 sourcemap 옵션 사용하기<a class='anchor' href='#%23prefix-postfix--sourcemap--'> </a></h3><pre><code class='code-block _highlighted lang_xml'><span class='nt'>&lt;project</span> <span class='na'>name=</span><span class='s'>&quot;Ant Task Test&quot;</span> <span class='na'>default=</span><span class='s'>&quot;build&quot;</span><span class='nt'>&gt;</span>
    <span class='nt'>&lt;taskdef</span> <span class='na'>resource=</span><span class='s'>&quot;org/jetbrains/kotlin/ant/antlib.xml&quot;</span> <span class='na'>classpath=</span><span class='s'>&quot;${kotlin.lib}/kotlin-ant.jar&quot;</span><span class='nt'>/&gt;</span>

    <span class='nt'>&lt;target</span> <span class='na'>name=</span><span class='s'>&quot;build&quot;</span><span class='nt'>&gt;</span>
        <span class='nt'>&lt;kotlin2js</span> <span class='na'>src=</span><span class='s'>&quot;root1&quot;</span> <span class='na'>output=</span><span class='s'>&quot;out.js&quot;</span> <span class='na'>outputPrefix=</span><span class='s'>&quot;prefix&quot;</span> <span class='na'>outputPostfix=</span><span class='s'>&quot;postfix&quot;</span> <span class='na'>sourcemap=</span><span class='s'>&quot;true&quot;</span><span class='nt'>/&gt;</span>
    <span class='nt'>&lt;/target&gt;</span>
<span class='nt'>&lt;/project&gt;</span></code></pre><h3 id='using-ant.html_meatinfo--'>자바스크립트 대상으로 한 개 소스 폴더와 meatInfo 옵션 사용하기<a class='anchor' href='#%23meatinfo--'> </a></h3><p>코틀린/자바스크립트 라이브러리로 변환 결과를 배포하길 원한다면 <code>metaInfo</code> 옵션을 유용하게 사용할 수 있다.
<code>metaInfo</code> 옵션을 <code>true</code>로 설정하면 컴파일할 때 바이너리 메타데이터를 가진 JS 파일을 추가로 생성한다. 변환 결과와 함께 이 파일을 배포해야 한다.</p><pre><code class='code-block _highlighted lang_xml'><span class='nt'>&lt;project</span> <span class='na'>name=</span><span class='s'>&quot;Ant Task Test&quot;</span> <span class='na'>default=</span><span class='s'>&quot;build&quot;</span><span class='nt'>&gt;</span>
    <span class='nt'>&lt;typedef</span> <span class='na'>resource=</span><span class='s'>&quot;org/jetbrains/kotlin/ant/antlib.xml&quot;</span> <span class='na'>classpath=</span><span class='s'>&quot;${kotlin.lib}/kotlin-ant.jar&quot;</span><span class='nt'>/&gt;</span>

    <span class='nt'>&lt;target</span> <span class='na'>name=</span><span class='s'>&quot;build&quot;</span><span class='nt'>&gt;</span>
        <span class='c'>&lt;!-- 바이너리 디스크립터를 포함한 out.meta.js 파일을 생성한다. --&gt;</span>
        <span class='nt'>&lt;kotlin2js</span> <span class='na'>src=</span><span class='s'>&quot;root1&quot;</span> <span class='na'>output=</span><span class='s'>&quot;out.js&quot;</span> <span class='na'>metaInfo=</span><span class='s'>&quot;true&quot;</span><span class='nt'>/&gt;</span>
    <span class='nt'>&lt;/target&gt;</span>
<span class='nt'>&lt;/project&gt;</span></code></pre><h3 id='using-ant.html_section-3'>레퍼런스<a class='anchor' href='#%23section-3'> </a></h3><p>요소와 애트리트뷰 전체 목록을 아래에 나열했다.</p><h4 id='using-ant.html_kotlinc-kotlin2js---'>kotlinc와 kotlin2js의 위한 공통 애트리뷰트<a class='anchor' href='#%23kotlinc-kotlin2js---'> </a></h4><table>
  <thead>
    <tr>
      <th>이름</th>
      <th>설명</th>
      <th>필수</th>
      <th>기본 값</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>src</code></td>
      <td>컴파일할 코틀린 소스 파일 또는 디렉토리</td>
      <td>Yes</td>
      <td> </td>
    </tr>
    <tr>
      <td><code>nowarn</code></td>
      <td>모든 컴파일 경고를 무시함</td>
      <td>No</td>
      <td>false</td>
    </tr>
    <tr>
      <td><code>noStdlib</code></td>
      <td>클래스패스에 코틀린 표준 라이브러리를 포함하지 않음</td>
      <td>No</td>
      <td>false</td>
    </tr>
    <tr>
      <td><code>failOnError</code></td>
      <td>컴파일하는 동안 에러를 발견하면 빌드에 실패함</td>
      <td>No</td>
      <td>true</td>
    </tr>
  </tbody>
</table><h4 id='using-ant.html_kotlinc-'>kotlinc 애트리뷰트<a class='anchor' href='#%23kotlinc-'> </a></h4><table>
  <thead>
    <tr>
      <th>이름</th>
      <th>설명</th>
      <th>필수</th>
      <th>기본 값</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>output</code></td>
      <td>대상 디렉토리나 jar 파일 이름</td>
      <td>Yes</td>
      <td> </td>
    </tr>
    <tr>
      <td><code>classpath</code></td>
      <td>컴파일 클래스패스</td>
      <td>No</td>
      <td> </td>
    </tr>
    <tr>
      <td><code>classpathref</code></td>
      <td>컴파일 클래스패스 참조</td>
      <td>No</td>
      <td> </td>
    </tr>
    <tr>
      <td><code>includeRuntime</code></td>
      <td><code>output</code>이 jar 파일일 때 코틀린 런타임 라이브러리를 jar에 포함할지 여부를 지정</td>
      <td>No</td>
      <td>true</td>
    </tr>
    <tr>
      <td><code>moduleName</code></td>
      <td>컴파일 할 모듈 이름</td>
      <td>No</td>
      <td>(대상을 지정했다면) 대상 이름 아니면 프로젝트 이름</td>
    </tr>
  </tbody>
</table><h4 id='using-ant.html_kotlin2js-'>kotlin2js 애트리뷰트<a class='anchor' href='#%23kotlin2js-'> </a></h4><table>
  <thead>
    <tr>
      <th>이름</th>
      <th>설명</th>
      <th>필수</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>output</code></td>
      <td>대상 파일</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td><code>library</code></td>
      <td>라이브러리 파일 (kt, dir, jar)</td>
      <td>No</td>
    </tr>
    <tr>
      <td><code>outputPrefix</code></td>
      <td>생성할 자바스크립트 파일에 사용할 접두사</td>
      <td>No</td>
    </tr>
    <tr>
      <td><code>outputSuffix</code></td>
      <td>생성할 자바스크립트 파일에 사용할 접미사</td>
      <td>No</td>
    </tr>
    <tr>
      <td><code>sourcemap</code></td>
      <td>sourcemap 파일을 생성할지 여부</td>
      <td>No</td>
    </tr>
    <tr>
      <td><code>metaInfo</code></td>
      <td>바이너리 디스크립터를 가진 메타데이터 파일을 생성할지 여부</td>
      <td>No</td>
    </tr>
    <tr>
      <td><code>main</code></td>
      <td>컴파일러가 생성한 코드가 메인 함수를 호출하는지</td>
      <td>No</td>
    </tr>
  </tbody>
</table>
              </article>
          
              <article id="using-gradle.html" class="page-content">
                <h2 id='using-gradle.html_section'>그래들 사용하기<a class='anchor' href='#%23section'> </a></h2><table>
  <tbody>
    <tr>
      <td>그래들에서 코틀린을 빌드하려면 <a href='#%23plugin-and-versions'><em>kotlin-gradle</em> 플러그인을 설정</a>하고 프로젝트에 <a href='#%23targeting-the-jvm'>플러그인을 적용</a>하고 <a href='#%23configuring-dependencies'><em>kotlin-stdlib</em> 의존을 추가</a>해야 한다. IntelliJ IDEA에서는 Tools</td>
      <td>Kotlin</td>
      <td>Configure Kotlin를 사용하면 자동으로 처리한다.</td>
    </tr>
  </tbody>
</table><h3 id='using-gradle.html_section-1'>플러그인과 버전<a class='anchor' href='#%23section-1'> </a></h3><p><em>kotlin-gradle-plugin</em>은 코틀린 소스와 모듈을 컴파일한다.</p><p>보통 사용할 코틀린 버전은 <em>kotlin_version</em> 프로퍼티로 정의한다.:</p><pre><code class='code-block _highlighted lang_groovy'><span class='n'>buildscript</span> <span class='o'>{</span>
   <span class='n'>ext</span><span class='o'>.</span><span class='na'>kotlin_version</span> <span class='o'>=</span> <span class='s1'>&#39;&lt;version to use&gt;&#39;</span>

   <span class='n'>repositories</span> <span class='o'>{</span>
     <span class='n'>mavenCentral</span><span class='o'>()</span>
   <span class='o'>}</span>

   <span class='n'>dependencies</span> <span class='o'>{</span>
     <span class='n'>classpath</span> <span class='s2'>&quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot;</span>
   <span class='o'>}</span>
<span class='o'>}</span></code></pre><p>코틀린 릴리즈와 버전 간의 관계를 아래 표시했다:</p><table>
<thead>
<tr>
  <th>Milestone</th>
  <th>Version</th>
</tr>
</thead>
<tbody>

<tr>
  <td>1.0.1 hotfix update 2</td>
  <td>1.0.1-2</td>
</tr>

<tr>
  <td>1.0.1 hotfix update</td>
  <td>1.0.1-1</td>
</tr>

<tr>
  <td>1.0.1</td>
  <td>1.0.1</td>
</tr>

<tr>
  <td>1.0 GA</td>
  <td>1.0.0</td>
</tr>

<tr>
  <td>Release Candidate</td>
  <td>1.0.0-rc-1036</td>
</tr>

<tr>
  <td>Beta 4</td>
  <td>1.0.0-beta-4589</td>
</tr>

<tr>
  <td>Beta 3</td>
  <td>1.0.0-beta-3595</td>
</tr>

<tr>
  <td>Beta 2</td>
  <td>1.0.0-beta-2423</td>
</tr>

<tr>
  <td>Beta</td>
  <td>1.0.0-beta-1103</td>
</tr>

<tr>
  <td>Beta Candidate</td>
  <td>1.0.0-beta-1038</td>
</tr>

<tr>
  <td>M14</td>
  <td>0.14.449</td>
</tr>

<tr>
  <td>M13</td>
  <td>0.13.1514</td>
</tr>

<tr>
  <td>M12.1</td>
  <td>0.12.613</td>
</tr>

<tr>
  <td>M12</td>
  <td>0.12.200</td>
</tr>

<tr>
  <td>M11.1</td>
  <td>0.11.91.1</td>
</tr>

<tr>
  <td>M11</td>
  <td>0.11.91</td>
</tr>

<tr>
  <td>M10.1</td>
  <td>0.10.195</td>
</tr>

<tr>
  <td>M10</td>
  <td>0.10.4</td>
</tr>

<tr>
  <td>M9</td>
  <td>0.9.66</td>
</tr>

<tr>
  <td>M8</td>
  <td>0.8.11</td>
</tr>

<tr>
  <td>M7</td>
  <td>0.7.270</td>
</tr>

<tr>
  <td>M6.2</td>
  <td>0.6.1673</td>
</tr>

<tr>
  <td>M6.1</td>
  <td>0.6.602</td>
</tr>

<tr>
  <td>M6</td>
  <td>0.6.69</td>
</tr>

<tr>
  <td>M5.3</td>
  <td>0.5.998</td>
</tr>

</tbody>
</table><h3 id='using-gradle.html_jvm-'>JVM 대상<a class='anchor' href='#%23jvm-'> </a></h3><p>JVM을 대상으로 하려면 kotlin 플러그인을 적용하면 된다.</p><pre><code class='code-block _highlighted lang_groovy'><span class='n'>apply</span> <span class='nl'>plugin:</span> <span class='s2'>&quot;kotlin&quot;</span></code></pre><p>코틀린 소스와 자바 소스를 같은 폴더나 다른 폴더에 위치시킬 수 있다. 기본 규칙은 다른 폴더를 사용하는 것이다:</p><pre><code class='code-block _highlighted lang_groovy'><span class='n'>project</span>
    <span class='o'>-</span> <span class='n'>src</span>
        <span class='o'>-</span> <span class='n'>main</span> <span class='o'>(</span><span class='n'>root</span><span class='o'>)</span>
            <span class='o'>-</span> <span class='n'>kotlin</span>
            <span class='o'>-</span> <span class='n'>java</span></code></pre><p>기본 규칙을 사용하지 않을 경우 해당하는 <em>sourceSets</em> 프로퍼티를 수정해야 한다.</p><pre><code class='code-block _highlighted lang_groovy'><span class='n'>sourceSets</span> <span class='o'>{</span>
    <span class='n'>main</span><span class='o'>.</span><span class='na'>kotlin</span><span class='o'>.</span><span class='na'>srcDirs</span> <span class='o'>+=</span> <span class='s1'>&#39;src/main/myKotlin&#39;</span>
    <span class='n'>main</span><span class='o'>.</span><span class='na'>java</span><span class='o'>.</span><span class='na'>srcDirs</span> <span class='o'>+=</span> <span class='s1'>&#39;src/main/myJava&#39;</span>
<span class='o'>}</span></code></pre><h3 id='using-gradle.html_section-2'>자바스크립트 대상<a class='anchor' href='#%23section-2'> </a></h3><p>자바 스크립트가 대상이면 다른 플러그인을 사용한다:</p><pre><code class='code-block _highlighted lang_groovy'><span class='n'>apply</span> <span class='nl'>plugin:</span> <span class='s2'>&quot;kotlin2js&quot;</span></code></pre><p>이 플러그인은 코틀린 파일만 처리하므로 (동일 프로젝트에 자바 파일을 포함하고 있다면) 코틀린과 자바 파일을 별도로 구분하는게 좋다. JVM도 대상으로 하면서 기본 규칙을 사용하지 않으면, <em>sourceSets</em>으로 소스 폴더를 지정해야 한다.</p><pre><code class='code-block _highlighted lang_groovy'><span class='n'>sourceSets</span> <span class='o'>{</span>
    <span class='n'>main</span><span class='o'>.</span><span class='na'>kotlin</span><span class='o'>.</span><span class='na'>srcDirs</span> <span class='o'>+=</span> <span class='s1'>&#39;src/main/myKotlin&#39;</span>
<span class='o'>}</span></code></pre><p>재사용 가능한 라이브러리를 만드려면 바이너리 디스크립터를 가진 JS 파일을 추가로 생성하기 위해 <code>kotlinOptions.metaInfo</code>를 사용한다.
이 파일을 변환 결과와 함께 배포해야 한다.</p><pre><code class='code-block _highlighted lang_groovy'><span class='n'>compileKotlin2Js</span> <span class='o'>{</span>
	<span class='n'>kotlinOptions</span><span class='o'>.</span><span class='na'>metaInfo</span> <span class='o'>=</span> <span class='kc'>true</span>
<span class='o'>}</span></code></pre><h3 id='using-gradle.html_section-3'>안드로이드 대상<a class='anchor' href='#%23section-3'> </a></h3><p>안드로이드의 그래들 모델은 일반적인 그래들과 약간 다르다. 따라서 코틀린으로 작성한 안드로이드 프롤젝트를 빌드하려면 <em>kotlin</em> 대신 <em>kotlin-android</em> 플러그인을 사용해야 한다:</p><pre><code class='code-block _highlighted lang_groovy'><span class='n'>buildscript</span> <span class='o'>{</span>
    <span class='o'>...</span>
<span class='o'>}</span>
<span class='n'>apply</span> <span class='nl'>plugin:</span> <span class='s1'>&#39;com.android.application&#39;</span>
<span class='n'>apply</span> <span class='nl'>plugin:</span> <span class='s1'>&#39;kotlin-android&#39;</span></code></pre><h4 id='using-gradle.html_section-4'>안드로이드 스튜디오<a class='anchor' href='#%23section-4'> </a></h4><p>안드로이드 스튜디오를 사용하면 android에 다음 코드를 추가해야 한다:</p><pre><code class='code-block _highlighted lang_groovy'><span class='n'>android</span> <span class='o'>{</span>
  <span class='o'>...</span>

  <span class='n'>sourceSets</span> <span class='o'>{</span>
    <span class='n'>main</span><span class='o'>.</span><span class='na'>java</span><span class='o'>.</span><span class='na'>srcDirs</span> <span class='o'>+=</span> <span class='s1'>&#39;src/main/kotlin&#39;</span>
  <span class='o'>}</span>
<span class='o'>}</span></code></pre><p>이 설정은 안드로이드 스튜디오가 코틀린 디렉토리를 소스 루트로 사용하게 한다. 따라서 프로젝트 모델을 IDE에 로딩할 때 올바르게 인식한다.</p><h3 id='using-gradle.html_section-5'>의존 설정<a class='anchor' href='#%23section-5'> </a></h3><p>kotlin-gradle-plugin 의존과 함께 코틀린 표준 라이브러리에 대한 의존을 추가해야 한다.</p><pre><code class='code-block _highlighted lang_groovy'><span class='n'>buildscript</span> <span class='o'>{</span>
   <span class='n'>ext</span><span class='o'>.</span><span class='na'>kotlin_version</span> <span class='o'>=</span> <span class='s1'>&#39;&lt;사용할 버전&gt;&#39;</span>
  <span class='n'>repositories</span> <span class='o'>{</span>
    <span class='n'>mavenCentral</span><span class='o'>()</span>
  <span class='o'>}</span>
  <span class='n'>dependencies</span> <span class='o'>{</span>
    <span class='n'>classpath</span> <span class='s2'>&quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot;</span>
  <span class='o'>}</span>
<span class='o'>}</span>

<span class='n'>apply</span> <span class='nl'>plugin:</span> <span class='s2'>&quot;kotlin&quot;</span> <span class='c1'>// 또는 자바 스크립트가 대상이면 apply plugin: &quot;kotlin2js&quot;</span>

<span class='n'>repositories</span> <span class='o'>{</span>
  <span class='n'>mavenCentral</span><span class='o'>()</span>
<span class='o'>}</span>

<span class='n'>dependencies</span> <span class='o'>{</span>
  <span class='n'>compile</span> <span class='s2'>&quot;org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version&quot;</span>
<span class='o'>}</span></code></pre><p>프로젝트에서 코틀린 리플렉션이나 테스트 기능을 사용하려면 해당 의존을 추가로 넣는다:</p><pre><code class='code-block _highlighted lang_groovy'><span class='n'>compile</span> <span class='s2'>&quot;org.jetbrains.kotlin:kotlin-reflect:$kotlin_version&quot;</span>
<span class='n'>testCompile</span> <span class='s2'>&quot;org.jetbrains.kotlin:kotlin-test:$kotlin_version&quot;</span></code></pre><h3 id='using-gradle.html_osgi'>OSGi<a class='anchor' href='#%23osgi'> </a></h3><p>OSGi 지원은 <a href='#kotlin-osgi.html'>Kotlin OSGi 페이지</a>를 참고한다.</p><h3 id='using-gradle.html_section-6'>예제<a class='anchor' href='#%23section-6'> </a></h3><p><a href='#https%3A%2F%2Fgithub.com%2Fjetbrains%2Fkotlin'>코틀린 리포지토리</a>에 있는 예제:</p><ul>
  <li><a href='#https%3A%2F%2Fgithub.com%2FJetBrains%2Fkotlin-examples%2Ftree%2Fmaster%2Fgradle%2Fhello-world'>코틀린</a></li>
  <li><a href='#https%3A%2F%2Fgithub.com%2FJetBrains%2Fkotlin-examples%2Ftree%2Fmaster%2Fgradle%2Fmixed-java-kotlin-hello-world'>자바와 코틀린 함께 사용</a></li>
  <li><a href='#https%3A%2F%2Fgithub.com%2FJetBrains%2Fkotlin-examples%2Ftree%2Fmaster%2Fgradle%2Fandroid-mixed-java-kotlin-project'>안드로이드</a></li>
  <li><a href='#https%3A%2F%2Fgithub.com%2FJetBrains%2Fkotlin%2Ftree%2Fmaster%2Flibraries%2Ftools%2Fkotlin-gradle-plugin%2Fsrc%2Ftest%2Fresources%2FtestProject%2Fkotlin2JsProject'>자바스크립트</a></li>
</ul>
              </article>
          
              <article id="kotlin-osgi.html" class="page-content">
                <h2 id='kotlin-osgi.html_osgi'>코틀린과 OSGi<a class='anchor' href='#%23osgi'> </a></h2><p>코틀린 OSGi 지원 기능을 활성화려면 일반 코틀린 라이브러리 대신 <code>kotlin-osgi-bundle</code>를 포함하면 된다.
<code>kotlin-osgi-bundle</code>가 <code>kotlin-runtime</code>, <code>kotlin-stdlib</code> 그리고 <code>kotlin-reflect</code>를 모두 포함하고 있으므로 이 세 의존을 제거한다.
또한 외부 코틀린 라이브러리를 포함한 경우 주의해야 한다.
대부분 일반 코틀린 의존은 OSGi를 지원하지 않으므로 사용하면 안 되고 프로젝트에서 제거해야 한다.</p><h3 id='kotlin-osgi.html_section'>메이븐<a class='anchor' href='#%23section'> </a></h3><p>메이븐 프로젝트에 코틀린 OSGi 번들을 포함하기:</p><pre><code class='code-block _highlighted lang_xml'>   <span class='nt'>&lt;dependencies&gt;</span>
        <span class='nt'>&lt;dependency&gt;</span>
            <span class='nt'>&lt;groupId&gt;</span>org.jetbrains.kotlin<span class='nt'>&lt;/groupId&gt;</span>
            <span class='nt'>&lt;artifactId&gt;</span>kotlin-osgi-bundle<span class='nt'>&lt;/artifactId&gt;</span>
            <span class='nt'>&lt;version&gt;</span>${kotlin.version}<span class='nt'>&lt;/version&gt;</span>
        <span class='nt'>&lt;/dependency&gt;</span>
    <span class='nt'>&lt;/dependencies&gt;</span></code></pre><p>외부 라이브러리에서 표준 라이브러리 제외하기(“* 제외”는 메이븐 3에서만 동작한다).</p><pre><code class='code-block _highlighted lang_xml'>        <span class='nt'>&lt;dependency&gt;</span>
            <span class='nt'>&lt;groupId&gt;</span>some.group.id<span class='nt'>&lt;/groupId&gt;</span>
            <span class='nt'>&lt;artifactId&gt;</span>some.library<span class='nt'>&lt;/artifactId&gt;</span>
            <span class='nt'>&lt;version&gt;</span>some.library.version<span class='nt'>&lt;/version&gt;</span>

            <span class='nt'>&lt;exclusions&gt;</span>
                <span class='nt'>&lt;exclusion&gt;</span>
                    <span class='nt'>&lt;groupId&gt;</span>org.jetbrains.kotlin<span class='nt'>&lt;/groupId&gt;</span>
                    <span class='nt'>&lt;artifactId&gt;</span>*<span class='nt'>&lt;/artifactId&gt;</span>
                <span class='nt'>&lt;/exclusion&gt;</span>
            <span class='nt'>&lt;/exclusions&gt;</span>
        <span class='nt'>&lt;/dependency&gt;</span></code></pre><h3 id='kotlin-osgi.html_gradle'>Gradle<a class='anchor' href='#%23gradle'> </a></h3><p>그래들 프로젝트에 <code>kotlin-osgi-bundle</code> 포함하기:</p><pre><code class='code-block _highlighted lang_groovy'><span class='n'>compile</span> <span class='s2'>&quot;org.jetbrains.kotlin:kotlin-osgi-bundle:$kotlinVersion&quot;</span></code></pre><p>의존성 전이로 포함되는 기본 코틀린 라이브러리를 제외하려면 다음 방법을 사용한다.</p><pre><code class='code-block _highlighted lang_groovy'><span class='n'>dependencies</span> <span class='o'>{</span>
 <span class='n'>compile</span> <span class='o'>(</span>
   <span class='o'>[</span><span class='nl'>group:</span> <span class='s1'>&#39;some.group.id&#39;</span><span class='o'>,</span> <span class='nl'>name:</span> <span class='s1'>&#39;some.library&#39;</span><span class='o'>,</span> <span class='nl'>version:</span> <span class='s1'>&#39;someversion&#39;</span><span class='o'>],</span>
   <span class='o'>.....)</span> <span class='o'>{</span>
  <span class='n'>exclude</span> <span class='nl'>group:</span> <span class='s1'>&#39;org.jetbrains.kotlin&#39;</span>
<span class='o'>}</span></code></pre><h3 id='kotlin-osgi.html_faq'>FAQ<a class='anchor' href='#%23faq'> </a></h3><h5 id='kotlin-osgi.html_section-1'>왜 모든 코틀린 라이브러리에 필요한 매니페스트 옵션을 넣지 않았나?</h5><p>메니페스트 옵션이 OSGi를 지원하는 가장 선호하는 방법이긴 하지만, 아쉽게도
<a href='#http%3A%2F%2Fwiki.osgi.org%2Fwiki%2FSplit_Packages'>“패키지 분리” 문제</a>라 불리는 문제 때문에 할 수 없다.
이 문제는 쉽게 제거할 수 없고 아직 그렇게 큰 변경을 할 계획이 없다.
<code>Require-Bundle</code> 피처가 있지만 이 역시 최고의 선택은 아니며 사용을 추천하지 않는다.
그래서 SOGi를 위한 별도 아티팩트를 만들기로 결정했다.</p>
              </article>
          

        </section>
    

    
        <section>
          <h1 id="FAQ"
              class="section-title">
            FAQ
          </h1>

          
              <article id="faq.html" class="page-content">
                <h2 id='faq.html_faq'>FAQ<a class='anchor' href='#%23faq'> </a></h2><h3 id='faq.html_section'>일반 질문<a class='anchor' href='#%23section'> </a></h3><h4 id='faq.html_section-1'>코틀린이 무엇인가?<a class='anchor' href='#%23section-1'> </a></h4><p>코틀린은 정적 타입 언어로 JVM과 자바스크립트를 대상으로 한다. 산업에서 사용할 목적으로 만든 범용 언어이다.</p><p>코틀린은 OSS 언어이고 (JetBrains 소속이 아닌) 외부 기여자가 있지만, JetBrains에 있는 팀에서 만들고 있다.</p><h4 id='faq.html_section-2'>왜 새로운 언어를 만들었나?<a class='anchor' href='#%23section-2'> </a></h4><p>JetBrains에서 오랫동안 자바 플랫폼으로 개발을 진행했고 자바가 얼마나 좋은지 알고 있다.
하지만 자바 언어에는 일부 한계가 있고 하위호환 이슈 때문에 불가능하거나 고치기 힘든 문제가 있다는 것도 알고 있다.
자바가 오래 갈 거라는 건 알고 있다. 그래도 커뮤니티는 레거시 문제에서 벗어나 개발자가 절실하게 원하는 기능을 갖고 있는
JVM 대상 정적 타입 언어의 장점을 누려야 한다고 믿고 있다.</p><p>이 프로젝트의 주요 설계 목적은 다음과 같다.</p><ul>
  <li>자바와 호환되는 언어 만들기,</li>
  <li>적어도 자바만큼 빠르게 컴파일해야 함,</li>
  <li>자바보다 안전해야 함, 예를 들어 null pointer 값 참조와 같은 일반적인 문제를 정적으로 검사함,</li>
  <li>변수 타입 추론, 고차 함수(클로저), 확장 함수, 믹스인, 일급 위임과 같은 걸 지원해서 자바보다 더 간결해야 함;</li>
  <li>그리고 스칼라와 같은 가장 성숙한(mature) 경쟁 언어보다 방법을 더 간단하게 (위에서 언급한) 유용한 수준의 표현력을 유지하게 만든다.</li>
</ul><h4 id='faq.html_section-3'>라이선스는 어떻게 되나?<a class='anchor' href='#%23section-3'> </a></h4><p>Kotlin은 OSS 언어로 Apache 2 OSS 라이선스를 따른다. IntelliJ 플러그인도 OSS이다.</p><p>GitHub에 호스팅하고 있으며 기여자를 행복하게 받아들이고 있다.</p><h4 id='faq.html_section-4'>자바와 호환되나?<a class='anchor' href='#%23section-4'> </a></h4><p>물론이다. 컴파일러는 자바 바이트 코드를 생성한다. 코틀린에서 자바를 호출할 수 있고 자바에서 코틀린을 호출할 수 있다. <a href='#java-interop.html'>자바 상호운용</a>을 참고한다.</p><h4 id='faq.html_section-5'>코틀린 코드를 실행하는데 필요한 최소 자바 버전은 어떻게 되나?<a class='anchor' href='#%23section-5'> </a></h4><p>코틀린은 자바 6 또는 상위 버전과 호환되는 바이트코드를 생성한다. 안드로이드처럼 최근 버전이 자바 6을 지원하는 환경에서 코틀린을 사용할 수 있다.</p><h4 id='faq.html_section-6'>지원하는 도구는 있나?<a class='anchor' href='#%23section-6'> </a></h4><p>있다. Apache 2 라이선스 기반 OSS 프로젝트로 사용 가능한 IntelliJ IDEA 플러그인이 있다. IntelliJ IDEA의 <a href='#http%3A%2F%2Fwww.jetbrains.com%2Fidea%2Ffeatures%2Feditions_comparison_matrix.html'>free OSS Community Edition과 Ultimate Edition</a> 두 버전에서 코틀린을 사용할 수 있다.</p><h4 id='faq.html_section-7'>이클립스는 지원하나?<a class='anchor' href='#%23section-7'> </a></h4><p>지원한다. <a href='#%2Fdocs%2Ftutorials%2Fgetting-started-eclipse.html'>튜토리얼</a>에서 설치 과정을 참고한다.</p><h4 id='faq.html_section-8'>단독 컴파일러가 있나?<a class='anchor' href='#%23section-8'> </a></h4><p>있다. <a href='#https%3A%2F%2Fgithub.com%2FJetBrains%2Fkotlin%2Freleases%2Ftag%2F1.0.1-2'>GitHub 릴리즈 페이지</a>에서 단독 컴파일러와 다른 빌드 도구를 다운로드 할 수 있다.</p><h4 id='faq.html_section-9'>코틀린은 함수형 언어인가?<a class='anchor' href='#%23section-9'> </a></h4><p>코틀린은 객체 지향 언어이다. 추가로 고차 함수나 람다 식 그리고 최상위 함수를 지원한다. 표준 코틀린 라이브러리에는 (map, flatMap, reduce 등) 함수형 언어에서 일반적인 요소가 상당히 많이 존재한다.
또한 함수형 언어가 무엇이고 코틀린은 그게 아니라고 할 만한 명확한 정의가 없다.</p><h4 id='faq.html_section-10'>코틀린은 지네릭을 지원하나?<a class='anchor' href='#%23section-10'> </a></h4><p>코틀린은 지네릭을 지원한다. 또한, 선언-위치 가변(declaration-site variance)과 사용-위치 가변(usage-site variance)을 지원한다. 코틀린에는 또한 와일드카트 타입이 없다. 인라인 함수는 reified 타입 파라미터를 지원한다.</p><h4 id='faq.html_section-11'>세미콜린이 필요한가?<a class='anchor' href='#%23section-11'> </a></h4><p>필요없다. 선택적으로 사용할 수 있다.</p><h4 id='faq.html_section-12'>중괄호가 필요한가?<a class='anchor' href='#%23section-12'> </a></h4><p>필요하다.</p><h4 id='faq.html_section-13'>왜 타입 선언이 우측에 위치하나?<a class='anchor' href='#%23section-13'> </a></h4><p>이 방식이 코드 가독성을 높여준다고 믿는다. 뿐만 아니라 일부 좋은 구문 기능을 가능하게 해준다. 예를 들어, 타입 애노테이션을 쉽게 뺄 수 있다(?). 스칼라가 이것이 문제가 없음을 거의 보여줬다.</p><h4 id='faq.html_section-14'>우측에 위치한 타입 선언이 도구에 영향을 미치나?<a class='anchor' href='#%23section-14'> </a></h4><p>영향 없다. 변수 이름 추천과 같은 기능을 여전히 구현할 수 있다.</p><h4 id='faq.html_section-15'>코틀린은 확장 가능한가?<a class='anchor' href='#%23section-15'> </a></h4><p>인라인 함수에서 애노테이션과 타입 로더까지 몇 가지 방법으로 코틀린을 확장할 계획이다.</p><h4 id='faq.html_dsl----'>DSL을 언어에 삽입할 수 있나?<a class='anchor' href='#%23dsl----'> </a></h4><p>있다. 코틀린은 이를 위해 연산자 오버로딩, 인라인 함수를 통한 커스텀 컨트롤 구조, 중위 함수 호출, 확장 함수, 애노테이션, 언어 인용과 같은 기능을 제공한다.</p><h4 id='faq.html_ecmascript-'>자바스크립는 몇 레벨의 ECMAScript를 지원하나?<a class='anchor' href='#%23ecmascript-'> </a></h4><p>현재 5 레벨을 지원한다.</p><h4 id='faq.html_section-16'>자바 스크립트 백엔드는 모듈 시스템을 지원하나?<a class='anchor' href='#%23section-16'> </a></h4><p>지원한다. CommonJS와 AMD를 지원할 계획이다.</p>
              </article>
          
              <article id="comparison-to-java.html" class="page-content">
                <h2 id='comparison-to-java.html_section'>자바와 비교<a class='anchor' href='#%23section'> </a></h2><h3 id='comparison-to-java.html_section-1'>코틀린에 있는 몇 가지 자바 이슈<a class='anchor' href='#%23section-1'> </a></h3><p>코틀린은 자바가 겪고 있는 여러 문제를 해결한다.</p><ul>
  <li><a href='#null-safety.html'>타입 시스템에서 null 참조를 제어</a>한다</li>
  <li><a href='#java-interop.html'>raw 타입 없음</a></li>
  <li>코틀린의 배열은 <a href='#basic-types.html%23Arrays'>invariant</a>하다</li>
  <li>자바의 SAM-변환과 달리 코틀린은 올바른 <a href='#lambdas.html%23function-types'>function types</a>을 갖는다</li>
  <li>와일드카드 없는 <a href='#generics.html%23use-site-variance'>Use-site variance</a></li>
  <li>코틀린은 체크드 <a href='#exceptions.html'>익셉션</a>이 없다</li>
</ul><h3 id='comparison-to-java.html_section-2'>코틀린에 없고 자바에 있는 것<a class='anchor' href='#%23section-2'> </a></h3><ul>
  <li><a href='#exceptions.html'>체크드 익셉션</a></li>
  <li>클래스가 아닌 <a href='#basic-types.html'>기본 타입</a></li>
  <li><a href='#classes.html'>정적 멤버</a></li>
  <li><a href='#properties.html'>비-private 필드</a></li>
  <li><a href='#generics.html'>와일드카드-타입</a></li>
</ul><h3 id='comparison-to-java.html_section-3'>자바에 없고 코틀린에 있는 것<a class='anchor' href='#%23section-3'> </a></h3><ul>
  <li><a href='#lambdas.html'>람다 식</a> + <a href='#inline-functions.html'>안리안 함수</a> = 훌륭한 커스텀 제어 구조</li>
  <li><a href='#extensions.html'>확장 함수</a></li>
  <li><a href='#null-safety.html'>Null-안전성</a></li>
  <li><a href='#typecasts.html'>스마트 타입변환</a></li>
  <li><a href='#basic-types.html%23strings'>문자열 템플릿</a></li>
  <li><a href='#properties.html'>프로퍼티</a></li>
  <li><a href='#classes.html'>주요 생성자</a></li>
  <li><a href='#delegation.html'>필드-클래스 위임</a></li>
  <li><a href='#basic-types.html'>변수와 프로퍼티 타입을 위한 타입 추론</a></li>
  <li><a href='#object-declarations.html'>싱글톤</a></li>
  <li><a href='#generics.html'>Declaration-site variance &amp; Type projections</a></li>
  <li><a href='#ranges.html'>Range 식</a></li>
  <li><a href='#operator-overloading.html'>연산자 오버로딩</a></li>
  <li><a href='#classes.html%23companion-objects'>컴페니언 오브젝트</a></li>
  <li><a href='#data-classes.html'>데이터 클래스</a></li>
  <li><a href='#collections.html'>읽기 전용 콜렉션과 변경 가능 콜렉션 인터페이스 분리</a></li>
</ul>
              </article>
          
              <article id="comparison-to-scala.html" class="page-content">
                <h2 id='comparison-to-scala.html_section'>스칼라와 비교<a class='anchor' href='#%23section'> </a></h2><p>코틀린 팀의 주요 목적은 실용적이고 생산적인 프로그래밍 언어를 만드는 것이다. 프로그래밍 언어 연구 용으로 앞서가는 최신 언어를 만드는 건 목적이 아니다.
이를 고려해서, 만약 스칼라에 만족한다면, 아마도 코틀린이 필요하지 않을 것이다.</p><h3 id='comparison-to-scala.html_section-1'>코틀린에 없고 스칼라에 있는 것<a class='anchor' href='#%23section-1'> </a></h3><ul>
  <li>암묵적 변환, 파라미터, etc
    <ul>
      <li>스클라는 때때로 디버거 없이 코드에서 무슨 일이 벌어지고 있는지 말하기 어렵다. 왜냐면 동작하기 위해 암묵적으로 너무 많은 것이 일어나기 때문이다.</li>
      <li>코틀린에서 타입에 함수를 추가하고 싶으면 <a href='#extensions.html'>확장 함수</a>를 사용한다.</li>
    </ul>
  </li>
  <li>오버라이딩할 수 있는 타입 멤버</li>
  <li>경로-의존 타입(Path-dependent types)</li>
  <li>매크로</li>
  <li>Existential types
    <ul>
      <li><a href='#generics.html%23type-projections'>타입 프로젝션</a>은 매우 특수한 경우이다</li>
    </ul>
  </li>
  <li>트레잇 초기화를 위한 복잡한 로직
    <ul>
      <li><a href='#classes.html'>클래스와 상속</a> 참고</li>
    </ul>
  </li>
  <li>커스텀 오퍼레이션 심볼
    <ul>
      <li><a href='#operator-overloading.html'>연산자 오버로딩</a> 참고</li>
    </ul>
  </li>
  <li>XML 기본 지원
    <ul>
      <li><a href='#type-safe-builders.html'>Type-safe Groovy-style builders</a> 참고</li>
    </ul>
  </li>
  <li>Structural types</li>
  <li>값 타입(Value types)
    <ul>
      <li><a href='#http%3A%2F%2Fopenjdk.java.net%2Fprojects%2Fvalhalla%2F'>Project Valhalla</a>가 JDK에 일부로 릴리즈되면 지원할 계획이다.</li>
    </ul>
  </li>
  <li>Yield 연산자</li>
  <li>액터
    <ul>
      <li>JVM에 액터를 지원하기 위한 외부 프레임워크인 <a href='#http%3A%2F%2Fwww.paralleluniverse.co%2Fquasar%2F'>Quasar</a>를 지원한다.</li>
    </ul>
  </li>
  <li>병렬 콜렉션
    <ul>
      <li>코틀린은 유사한 기능을 제공하는 자바 8 스트림을 지원한다</li>
    </ul>
  </li>
</ul><h3 id='comparison-to-scala.html_section-2'>스칼라에 없고 코틀린에 있는 것<a class='anchor' href='#%23section-2'> </a></h3><ul>
  <li><a href='#null-safety.html'>오버헤드 없는 null-안정성</a>
    <ul>
      <li>스칼라는 신택틱(syntactic)하고 런타임 래퍼인 Option을 갖는다.</li>
    </ul>
  </li>
  <li><a href='#typecasts.html'>스마트 변환</a></li>
  <li><a href='#inline-functions.html%23inline-functions'>코틀린의 인라인 함수는 non-로컬 점프를 쉽게할 수 있다</a></li>
  <li><a href='#delegation.html'>일급 위임</a>. 또한 외부 플러그인인 Autoproxy로 구현된다.</li>
  <li><a href='#reflection.html%23function-references'>멤버 참조</a> (자바 8에서도 지원한다).</li>
</ul>
              </article>
          

        </section>
    


</body>
</html>